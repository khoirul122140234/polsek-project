
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model LeaderProfile
 * 
 */
export type LeaderProfile = $Result.DefaultSelection<Prisma.$LeaderProfilePayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model Anggota
 * 
 */
export type Anggota = $Result.DefaultSelection<Prisma.$AnggotaPayload>
/**
 * Model Facility
 * 
 */
export type Facility = $Result.DefaultSelection<Prisma.$FacilityPayload>
/**
 * Model News
 * 
 */
export type News = $Result.DefaultSelection<Prisma.$NewsPayload>
/**
 * Model Education
 * 
 */
export type Education = $Result.DefaultSelection<Prisma.$EducationPayload>
/**
 * Model LetterCounter
 * *
 *  * ✅ BARU:
 *  * Counter nomor surat agar:
 *  * - Nomor dibuat saat admin set SELESAI (tidak loncat)
 *  * - Bisa di-set "mulai dari nomor berapa"
 *  * - Disimpan per type + year (reset otomatis per tahun)
 */
export type LetterCounter = $Result.DefaultSelection<Prisma.$LetterCounterPayload>
/**
 * Model LetterApplication
 * 
 */
export type LetterApplication = $Result.DefaultSelection<Prisma.$LetterApplicationPayload>
/**
 * Model OnlineReport
 * 
 */
export type OnlineReport = $Result.DefaultSelection<Prisma.$OnlineReportPayload>
/**
 * Model SuratRekap
 * 
 */
export type SuratRekap = $Result.DefaultSelection<Prisma.$SuratRekapPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model PushSubscription
 * ///////////////////////////////////////////////////////////
 * ///////////////////////////////////////////////////////////
 */
export type PushSubscription = $Result.DefaultSelection<Prisma.$PushSubscriptionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN_INTELKAM: 'ADMIN_INTELKAM',
  ADMIN_KASIUM: 'ADMIN_KASIUM',
  ADMIN_SPKT: 'ADMIN_SPKT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const LetterType: {
  IZIN_KERAMAIAN: 'IZIN_KERAMAIAN',
  TANDA_KEHILANGAN: 'TANDA_KEHILANGAN'
};

export type LetterType = (typeof LetterType)[keyof typeof LetterType]


export const LetterStatus: {
  DRAFT: 'DRAFT',
  DIAJUKAN: 'DIAJUKAN',
  DIVERIFIKASI: 'DIVERIFIKASI',
  DITOLAK: 'DITOLAK',
  SELESAI: 'SELESAI'
};

export type LetterStatus = (typeof LetterStatus)[keyof typeof LetterStatus]


export const OnlineReportStatus: {
  BARU: 'BARU',
  DIPROSES: 'DIPROSES',
  SELESAI: 'SELESAI',
  DITOLAK: 'DITOLAK'
};

export type OnlineReportStatus = (typeof OnlineReportStatus)[keyof typeof OnlineReportStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type LetterType = $Enums.LetterType

export const LetterType: typeof $Enums.LetterType

export type LetterStatus = $Enums.LetterStatus

export const LetterStatus: typeof $Enums.LetterStatus

export type OnlineReportStatus = $Enums.OnlineReportStatus

export const OnlineReportStatus: typeof $Enums.OnlineReportStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaderProfile`: Exposes CRUD operations for the **LeaderProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaderProfiles
    * const leaderProfiles = await prisma.leaderProfile.findMany()
    * ```
    */
  get leaderProfile(): Prisma.LeaderProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.anggota`: Exposes CRUD operations for the **Anggota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Anggotas
    * const anggotas = await prisma.anggota.findMany()
    * ```
    */
  get anggota(): Prisma.AnggotaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facility`: Exposes CRUD operations for the **Facility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facilities
    * const facilities = await prisma.facility.findMany()
    * ```
    */
  get facility(): Prisma.FacilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.news`: Exposes CRUD operations for the **News** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News
    * const news = await prisma.news.findMany()
    * ```
    */
  get news(): Prisma.NewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.education`: Exposes CRUD operations for the **Education** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Educations
    * const educations = await prisma.education.findMany()
    * ```
    */
  get education(): Prisma.EducationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.letterCounter`: Exposes CRUD operations for the **LetterCounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LetterCounters
    * const letterCounters = await prisma.letterCounter.findMany()
    * ```
    */
  get letterCounter(): Prisma.LetterCounterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.letterApplication`: Exposes CRUD operations for the **LetterApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LetterApplications
    * const letterApplications = await prisma.letterApplication.findMany()
    * ```
    */
  get letterApplication(): Prisma.LetterApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.onlineReport`: Exposes CRUD operations for the **OnlineReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OnlineReports
    * const onlineReports = await prisma.onlineReport.findMany()
    * ```
    */
  get onlineReport(): Prisma.OnlineReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.suratRekap`: Exposes CRUD operations for the **SuratRekap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuratRekaps
    * const suratRekaps = await prisma.suratRekap.findMany()
    * ```
    */
  get suratRekap(): Prisma.SuratRekapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pushSubscription`: Exposes CRUD operations for the **PushSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PushSubscriptions
    * const pushSubscriptions = await prisma.pushSubscription.findMany()
    * ```
    */
  get pushSubscription(): Prisma.PushSubscriptionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    LeaderProfile: 'LeaderProfile',
    Unit: 'Unit',
    Anggota: 'Anggota',
    Facility: 'Facility',
    News: 'News',
    Education: 'Education',
    LetterCounter: 'LetterCounter',
    LetterApplication: 'LetterApplication',
    OnlineReport: 'OnlineReport',
    SuratRekap: 'SuratRekap',
    Document: 'Document',
    PushSubscription: 'PushSubscription'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "leaderProfile" | "unit" | "anggota" | "facility" | "news" | "education" | "letterCounter" | "letterApplication" | "onlineReport" | "suratRekap" | "document" | "pushSubscription"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      LeaderProfile: {
        payload: Prisma.$LeaderProfilePayload<ExtArgs>
        fields: Prisma.LeaderProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderProfilePayload>
          }
          findFirst: {
            args: Prisma.LeaderProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderProfilePayload>
          }
          findMany: {
            args: Prisma.LeaderProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderProfilePayload>[]
          }
          create: {
            args: Prisma.LeaderProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderProfilePayload>
          }
          createMany: {
            args: Prisma.LeaderProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaderProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderProfilePayload>[]
          }
          delete: {
            args: Prisma.LeaderProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderProfilePayload>
          }
          update: {
            args: Prisma.LeaderProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderProfilePayload>
          }
          deleteMany: {
            args: Prisma.LeaderProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaderProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderProfilePayload>[]
          }
          upsert: {
            args: Prisma.LeaderProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderProfilePayload>
          }
          aggregate: {
            args: Prisma.LeaderProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaderProfile>
          }
          groupBy: {
            args: Prisma.LeaderProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaderProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderProfileCountArgs<ExtArgs>
            result: $Utils.Optional<LeaderProfileCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      Anggota: {
        payload: Prisma.$AnggotaPayload<ExtArgs>
        fields: Prisma.AnggotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnggotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnggotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnggotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnggotaPayload>
          }
          findFirst: {
            args: Prisma.AnggotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnggotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnggotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnggotaPayload>
          }
          findMany: {
            args: Prisma.AnggotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnggotaPayload>[]
          }
          create: {
            args: Prisma.AnggotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnggotaPayload>
          }
          createMany: {
            args: Prisma.AnggotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnggotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnggotaPayload>[]
          }
          delete: {
            args: Prisma.AnggotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnggotaPayload>
          }
          update: {
            args: Prisma.AnggotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnggotaPayload>
          }
          deleteMany: {
            args: Prisma.AnggotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnggotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnggotaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnggotaPayload>[]
          }
          upsert: {
            args: Prisma.AnggotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnggotaPayload>
          }
          aggregate: {
            args: Prisma.AnggotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnggota>
          }
          groupBy: {
            args: Prisma.AnggotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnggotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnggotaCountArgs<ExtArgs>
            result: $Utils.Optional<AnggotaCountAggregateOutputType> | number
          }
        }
      }
      Facility: {
        payload: Prisma.$FacilityPayload<ExtArgs>
        fields: Prisma.FacilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findFirst: {
            args: Prisma.FacilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findMany: {
            args: Prisma.FacilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          create: {
            args: Prisma.FacilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          createMany: {
            args: Prisma.FacilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          delete: {
            args: Prisma.FacilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          update: {
            args: Prisma.FacilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          deleteMany: {
            args: Prisma.FacilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          upsert: {
            args: Prisma.FacilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          aggregate: {
            args: Prisma.FacilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacility>
          }
          groupBy: {
            args: Prisma.FacilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityCountArgs<ExtArgs>
            result: $Utils.Optional<FacilityCountAggregateOutputType> | number
          }
        }
      }
      News: {
        payload: Prisma.$NewsPayload<ExtArgs>
        fields: Prisma.NewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findFirst: {
            args: Prisma.NewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findMany: {
            args: Prisma.NewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          create: {
            args: Prisma.NewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          createMany: {
            args: Prisma.NewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          delete: {
            args: Prisma.NewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          update: {
            args: Prisma.NewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          deleteMany: {
            args: Prisma.NewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          upsert: {
            args: Prisma.NewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          aggregate: {
            args: Prisma.NewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNews>
          }
          groupBy: {
            args: Prisma.NewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsCountArgs<ExtArgs>
            result: $Utils.Optional<NewsCountAggregateOutputType> | number
          }
        }
      }
      Education: {
        payload: Prisma.$EducationPayload<ExtArgs>
        fields: Prisma.EducationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findFirst: {
            args: Prisma.EducationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findMany: {
            args: Prisma.EducationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          create: {
            args: Prisma.EducationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          createMany: {
            args: Prisma.EducationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EducationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          delete: {
            args: Prisma.EducationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          update: {
            args: Prisma.EducationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          deleteMany: {
            args: Prisma.EducationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EducationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          upsert: {
            args: Prisma.EducationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          aggregate: {
            args: Prisma.EducationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducation>
          }
          groupBy: {
            args: Prisma.EducationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EducationCountArgs<ExtArgs>
            result: $Utils.Optional<EducationCountAggregateOutputType> | number
          }
        }
      }
      LetterCounter: {
        payload: Prisma.$LetterCounterPayload<ExtArgs>
        fields: Prisma.LetterCounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LetterCounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterCounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LetterCounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterCounterPayload>
          }
          findFirst: {
            args: Prisma.LetterCounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterCounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LetterCounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterCounterPayload>
          }
          findMany: {
            args: Prisma.LetterCounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterCounterPayload>[]
          }
          create: {
            args: Prisma.LetterCounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterCounterPayload>
          }
          createMany: {
            args: Prisma.LetterCounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LetterCounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterCounterPayload>[]
          }
          delete: {
            args: Prisma.LetterCounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterCounterPayload>
          }
          update: {
            args: Prisma.LetterCounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterCounterPayload>
          }
          deleteMany: {
            args: Prisma.LetterCounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LetterCounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LetterCounterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterCounterPayload>[]
          }
          upsert: {
            args: Prisma.LetterCounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterCounterPayload>
          }
          aggregate: {
            args: Prisma.LetterCounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLetterCounter>
          }
          groupBy: {
            args: Prisma.LetterCounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<LetterCounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.LetterCounterCountArgs<ExtArgs>
            result: $Utils.Optional<LetterCounterCountAggregateOutputType> | number
          }
        }
      }
      LetterApplication: {
        payload: Prisma.$LetterApplicationPayload<ExtArgs>
        fields: Prisma.LetterApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LetterApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LetterApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterApplicationPayload>
          }
          findFirst: {
            args: Prisma.LetterApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LetterApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterApplicationPayload>
          }
          findMany: {
            args: Prisma.LetterApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterApplicationPayload>[]
          }
          create: {
            args: Prisma.LetterApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterApplicationPayload>
          }
          createMany: {
            args: Prisma.LetterApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LetterApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterApplicationPayload>[]
          }
          delete: {
            args: Prisma.LetterApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterApplicationPayload>
          }
          update: {
            args: Prisma.LetterApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterApplicationPayload>
          }
          deleteMany: {
            args: Prisma.LetterApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LetterApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LetterApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterApplicationPayload>[]
          }
          upsert: {
            args: Prisma.LetterApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LetterApplicationPayload>
          }
          aggregate: {
            args: Prisma.LetterApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLetterApplication>
          }
          groupBy: {
            args: Prisma.LetterApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LetterApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LetterApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<LetterApplicationCountAggregateOutputType> | number
          }
        }
      }
      OnlineReport: {
        payload: Prisma.$OnlineReportPayload<ExtArgs>
        fields: Prisma.OnlineReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OnlineReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OnlineReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineReportPayload>
          }
          findFirst: {
            args: Prisma.OnlineReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OnlineReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineReportPayload>
          }
          findMany: {
            args: Prisma.OnlineReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineReportPayload>[]
          }
          create: {
            args: Prisma.OnlineReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineReportPayload>
          }
          createMany: {
            args: Prisma.OnlineReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OnlineReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineReportPayload>[]
          }
          delete: {
            args: Prisma.OnlineReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineReportPayload>
          }
          update: {
            args: Prisma.OnlineReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineReportPayload>
          }
          deleteMany: {
            args: Prisma.OnlineReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OnlineReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OnlineReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineReportPayload>[]
          }
          upsert: {
            args: Prisma.OnlineReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineReportPayload>
          }
          aggregate: {
            args: Prisma.OnlineReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOnlineReport>
          }
          groupBy: {
            args: Prisma.OnlineReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<OnlineReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.OnlineReportCountArgs<ExtArgs>
            result: $Utils.Optional<OnlineReportCountAggregateOutputType> | number
          }
        }
      }
      SuratRekap: {
        payload: Prisma.$SuratRekapPayload<ExtArgs>
        fields: Prisma.SuratRekapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuratRekapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuratRekapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuratRekapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuratRekapPayload>
          }
          findFirst: {
            args: Prisma.SuratRekapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuratRekapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuratRekapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuratRekapPayload>
          }
          findMany: {
            args: Prisma.SuratRekapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuratRekapPayload>[]
          }
          create: {
            args: Prisma.SuratRekapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuratRekapPayload>
          }
          createMany: {
            args: Prisma.SuratRekapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuratRekapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuratRekapPayload>[]
          }
          delete: {
            args: Prisma.SuratRekapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuratRekapPayload>
          }
          update: {
            args: Prisma.SuratRekapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuratRekapPayload>
          }
          deleteMany: {
            args: Prisma.SuratRekapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuratRekapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuratRekapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuratRekapPayload>[]
          }
          upsert: {
            args: Prisma.SuratRekapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuratRekapPayload>
          }
          aggregate: {
            args: Prisma.SuratRekapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuratRekap>
          }
          groupBy: {
            args: Prisma.SuratRekapGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuratRekapGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuratRekapCountArgs<ExtArgs>
            result: $Utils.Optional<SuratRekapCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      PushSubscription: {
        payload: Prisma.$PushSubscriptionPayload<ExtArgs>
        fields: Prisma.PushSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PushSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.PushSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PushSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findMany: {
            args: Prisma.PushSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          create: {
            args: Prisma.PushSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          createMany: {
            args: Prisma.PushSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PushSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.PushSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          update: {
            args: Prisma.PushSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.PushSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PushSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.PushSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.PushSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePushSubscription>
          }
          groupBy: {
            args: Prisma.PushSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PushSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    leaderProfile?: LeaderProfileOmit
    unit?: UnitOmit
    anggota?: AnggotaOmit
    facility?: FacilityOmit
    news?: NewsOmit
    education?: EducationOmit
    letterCounter?: LetterCounterOmit
    letterApplication?: LetterApplicationOmit
    onlineReport?: OnlineReportOmit
    suratRekap?: SuratRekapOmit
    document?: DocumentOmit
    pushSubscription?: PushSubscriptionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdUsers: number
    createdSuratRekap: number
    sharedNews: number
    sharedEducation: number
    PushSubscription: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdUsers?: boolean | UserCountOutputTypeCountCreatedUsersArgs
    createdSuratRekap?: boolean | UserCountOutputTypeCountCreatedSuratRekapArgs
    sharedNews?: boolean | UserCountOutputTypeCountSharedNewsArgs
    sharedEducation?: boolean | UserCountOutputTypeCountSharedEducationArgs
    PushSubscription?: boolean | UserCountOutputTypeCountPushSubscriptionArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedSuratRekapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuratRekapWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedNewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedEducationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPushSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    anggota: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anggota?: boolean | UnitCountOutputTypeCountAnggotaArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountAnggotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnggotaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    nrp: string | null
    pangkat: string | null
    satuan: string | null
    avatarUrl: string | null
    ttdJabatan: string | null
    ttdNama: string | null
    ttdPangkat: string | null
    ttdNrp: string | null
    stplkLabel: string | null
    stplkJabatan: string | null
    stplkNama: string | null
    stplkPangkat: string | null
    stplkNrp: string | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    nrp: string | null
    pangkat: string | null
    satuan: string | null
    avatarUrl: string | null
    ttdJabatan: string | null
    ttdNama: string | null
    ttdPangkat: string | null
    ttdNrp: string | null
    stplkLabel: string | null
    stplkJabatan: string | null
    stplkNama: string | null
    stplkPangkat: string | null
    stplkNrp: string | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    isActive: number
    nrp: number
    pangkat: number
    satuan: number
    avatarUrl: number
    ttdJabatan: number
    ttdNama: number
    ttdPangkat: number
    ttdNrp: number
    stplkLabel: number
    stplkJabatan: number
    stplkNama: number
    stplkPangkat: number
    stplkNrp: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    nrp?: true
    pangkat?: true
    satuan?: true
    avatarUrl?: true
    ttdJabatan?: true
    ttdNama?: true
    ttdPangkat?: true
    ttdNrp?: true
    stplkLabel?: true
    stplkJabatan?: true
    stplkNama?: true
    stplkPangkat?: true
    stplkNrp?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    nrp?: true
    pangkat?: true
    satuan?: true
    avatarUrl?: true
    ttdJabatan?: true
    ttdNama?: true
    ttdPangkat?: true
    ttdNrp?: true
    stplkLabel?: true
    stplkJabatan?: true
    stplkNama?: true
    stplkPangkat?: true
    stplkNrp?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    nrp?: true
    pangkat?: true
    satuan?: true
    avatarUrl?: true
    ttdJabatan?: true
    ttdNama?: true
    ttdPangkat?: true
    ttdNrp?: true
    stplkLabel?: true
    stplkJabatan?: true
    stplkNama?: true
    stplkPangkat?: true
    stplkNrp?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    isActive: boolean
    nrp: string | null
    pangkat: string | null
    satuan: string | null
    avatarUrl: string | null
    ttdJabatan: string | null
    ttdNama: string | null
    ttdPangkat: string | null
    ttdNrp: string | null
    stplkLabel: string | null
    stplkJabatan: string | null
    stplkNama: string | null
    stplkPangkat: string | null
    stplkNrp: string | null
    createdById: number | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    nrp?: boolean
    pangkat?: boolean
    satuan?: boolean
    avatarUrl?: boolean
    ttdJabatan?: boolean
    ttdNama?: boolean
    ttdPangkat?: boolean
    ttdNrp?: boolean
    stplkLabel?: boolean
    stplkJabatan?: boolean
    stplkNama?: boolean
    stplkPangkat?: boolean
    stplkNrp?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    createdSuratRekap?: boolean | User$createdSuratRekapArgs<ExtArgs>
    sharedNews?: boolean | User$sharedNewsArgs<ExtArgs>
    sharedEducation?: boolean | User$sharedEducationArgs<ExtArgs>
    PushSubscription?: boolean | User$PushSubscriptionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    nrp?: boolean
    pangkat?: boolean
    satuan?: boolean
    avatarUrl?: boolean
    ttdJabatan?: boolean
    ttdNama?: boolean
    ttdPangkat?: boolean
    ttdNrp?: boolean
    stplkLabel?: boolean
    stplkJabatan?: boolean
    stplkNama?: boolean
    stplkPangkat?: boolean
    stplkNrp?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    nrp?: boolean
    pangkat?: boolean
    satuan?: boolean
    avatarUrl?: boolean
    ttdJabatan?: boolean
    ttdNama?: boolean
    ttdPangkat?: boolean
    ttdNrp?: boolean
    stplkLabel?: boolean
    stplkJabatan?: boolean
    stplkNama?: boolean
    stplkPangkat?: boolean
    stplkNrp?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    nrp?: boolean
    pangkat?: boolean
    satuan?: boolean
    avatarUrl?: boolean
    ttdJabatan?: boolean
    ttdNama?: boolean
    ttdPangkat?: boolean
    ttdNrp?: boolean
    stplkLabel?: boolean
    stplkJabatan?: boolean
    stplkNama?: boolean
    stplkPangkat?: boolean
    stplkNrp?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "isActive" | "nrp" | "pangkat" | "satuan" | "avatarUrl" | "ttdJabatan" | "ttdNama" | "ttdPangkat" | "ttdNrp" | "stplkLabel" | "stplkJabatan" | "stplkNama" | "stplkPangkat" | "stplkNrp" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    createdSuratRekap?: boolean | User$createdSuratRekapArgs<ExtArgs>
    sharedNews?: boolean | User$sharedNewsArgs<ExtArgs>
    sharedEducation?: boolean | User$sharedEducationArgs<ExtArgs>
    PushSubscription?: boolean | User$PushSubscriptionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      createdUsers: Prisma.$UserPayload<ExtArgs>[]
      createdSuratRekap: Prisma.$SuratRekapPayload<ExtArgs>[]
      sharedNews: Prisma.$NewsPayload<ExtArgs>[]
      sharedEducation: Prisma.$EducationPayload<ExtArgs>[]
      PushSubscription: Prisma.$PushSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      role: $Enums.UserRole
      isActive: boolean
      nrp: string | null
      pangkat: string | null
      satuan: string | null
      avatarUrl: string | null
      ttdJabatan: string | null
      ttdNama: string | null
      ttdPangkat: string | null
      ttdNrp: string | null
      stplkLabel: string | null
      stplkJabatan: string | null
      stplkNama: string | null
      stplkPangkat: string | null
      stplkNrp: string | null
      createdById: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends User$createdByArgs<ExtArgs> = {}>(args?: Subset<T, User$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdUsers<T extends User$createdUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdSuratRekap<T extends User$createdSuratRekapArgs<ExtArgs> = {}>(args?: Subset<T, User$createdSuratRekapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuratRekapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sharedNews<T extends User$sharedNewsArgs<ExtArgs> = {}>(args?: Subset<T, User$sharedNewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sharedEducation<T extends User$sharedEducationArgs<ExtArgs> = {}>(args?: Subset<T, User$sharedEducationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PushSubscription<T extends User$PushSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$PushSubscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly nrp: FieldRef<"User", 'String'>
    readonly pangkat: FieldRef<"User", 'String'>
    readonly satuan: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly ttdJabatan: FieldRef<"User", 'String'>
    readonly ttdNama: FieldRef<"User", 'String'>
    readonly ttdPangkat: FieldRef<"User", 'String'>
    readonly ttdNrp: FieldRef<"User", 'String'>
    readonly stplkLabel: FieldRef<"User", 'String'>
    readonly stplkJabatan: FieldRef<"User", 'String'>
    readonly stplkNama: FieldRef<"User", 'String'>
    readonly stplkPangkat: FieldRef<"User", 'String'>
    readonly stplkNrp: FieldRef<"User", 'String'>
    readonly createdById: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.createdBy
   */
  export type User$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.createdUsers
   */
  export type User$createdUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.createdSuratRekap
   */
  export type User$createdSuratRekapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuratRekap
     */
    select?: SuratRekapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuratRekap
     */
    omit?: SuratRekapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuratRekapInclude<ExtArgs> | null
    where?: SuratRekapWhereInput
    orderBy?: SuratRekapOrderByWithRelationInput | SuratRekapOrderByWithRelationInput[]
    cursor?: SuratRekapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuratRekapScalarFieldEnum | SuratRekapScalarFieldEnum[]
  }

  /**
   * User.sharedNews
   */
  export type User$sharedNewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    cursor?: NewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * User.sharedEducation
   */
  export type User$sharedEducationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    where?: EducationWhereInput
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    cursor?: EducationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * User.PushSubscription
   */
  export type User$PushSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    cursor?: PushSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model LeaderProfile
   */

  export type AggregateLeaderProfile = {
    _count: LeaderProfileCountAggregateOutputType | null
    _avg: LeaderProfileAvgAggregateOutputType | null
    _sum: LeaderProfileSumAggregateOutputType | null
    _min: LeaderProfileMinAggregateOutputType | null
    _max: LeaderProfileMaxAggregateOutputType | null
  }

  export type LeaderProfileAvgAggregateOutputType = {
    id: number | null
    updatedBy: number | null
  }

  export type LeaderProfileSumAggregateOutputType = {
    id: number | null
    updatedBy: number | null
  }

  export type LeaderProfileMinAggregateOutputType = {
    id: number | null
    roleKey: string | null
    nama: string | null
    jabatan: string | null
    pesan: string | null
    bio: string | null
    fotoUrl: string | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type LeaderProfileMaxAggregateOutputType = {
    id: number | null
    roleKey: string | null
    nama: string | null
    jabatan: string | null
    pesan: string | null
    bio: string | null
    fotoUrl: string | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type LeaderProfileCountAggregateOutputType = {
    id: number
    roleKey: number
    nama: number
    jabatan: number
    pesan: number
    bio: number
    fotoUrl: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type LeaderProfileAvgAggregateInputType = {
    id?: true
    updatedBy?: true
  }

  export type LeaderProfileSumAggregateInputType = {
    id?: true
    updatedBy?: true
  }

  export type LeaderProfileMinAggregateInputType = {
    id?: true
    roleKey?: true
    nama?: true
    jabatan?: true
    pesan?: true
    bio?: true
    fotoUrl?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type LeaderProfileMaxAggregateInputType = {
    id?: true
    roleKey?: true
    nama?: true
    jabatan?: true
    pesan?: true
    bio?: true
    fotoUrl?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type LeaderProfileCountAggregateInputType = {
    id?: true
    roleKey?: true
    nama?: true
    jabatan?: true
    pesan?: true
    bio?: true
    fotoUrl?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type LeaderProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderProfile to aggregate.
     */
    where?: LeaderProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderProfiles to fetch.
     */
    orderBy?: LeaderProfileOrderByWithRelationInput | LeaderProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaderProfiles
    **/
    _count?: true | LeaderProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderProfileMaxAggregateInputType
  }

  export type GetLeaderProfileAggregateType<T extends LeaderProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderProfile[P]>
      : GetScalarType<T[P], AggregateLeaderProfile[P]>
  }




  export type LeaderProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderProfileWhereInput
    orderBy?: LeaderProfileOrderByWithAggregationInput | LeaderProfileOrderByWithAggregationInput[]
    by: LeaderProfileScalarFieldEnum[] | LeaderProfileScalarFieldEnum
    having?: LeaderProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderProfileCountAggregateInputType | true
    _avg?: LeaderProfileAvgAggregateInputType
    _sum?: LeaderProfileSumAggregateInputType
    _min?: LeaderProfileMinAggregateInputType
    _max?: LeaderProfileMaxAggregateInputType
  }

  export type LeaderProfileGroupByOutputType = {
    id: number
    roleKey: string
    nama: string
    jabatan: string
    pesan: string
    bio: string
    fotoUrl: string | null
    updatedAt: Date
    updatedBy: number | null
    _count: LeaderProfileCountAggregateOutputType | null
    _avg: LeaderProfileAvgAggregateOutputType | null
    _sum: LeaderProfileSumAggregateOutputType | null
    _min: LeaderProfileMinAggregateOutputType | null
    _max: LeaderProfileMaxAggregateOutputType | null
  }

  type GetLeaderProfileGroupByPayload<T extends LeaderProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderProfileGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderProfileGroupByOutputType[P]>
        }
      >
    >


  export type LeaderProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleKey?: boolean
    nama?: boolean
    jabatan?: boolean
    pesan?: boolean
    bio?: boolean
    fotoUrl?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["leaderProfile"]>

  export type LeaderProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleKey?: boolean
    nama?: boolean
    jabatan?: boolean
    pesan?: boolean
    bio?: boolean
    fotoUrl?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["leaderProfile"]>

  export type LeaderProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleKey?: boolean
    nama?: boolean
    jabatan?: boolean
    pesan?: boolean
    bio?: boolean
    fotoUrl?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["leaderProfile"]>

  export type LeaderProfileSelectScalar = {
    id?: boolean
    roleKey?: boolean
    nama?: boolean
    jabatan?: boolean
    pesan?: boolean
    bio?: boolean
    fotoUrl?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type LeaderProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleKey" | "nama" | "jabatan" | "pesan" | "bio" | "fotoUrl" | "updatedAt" | "updatedBy", ExtArgs["result"]["leaderProfile"]>

  export type $LeaderProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaderProfile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleKey: string
      nama: string
      jabatan: string
      pesan: string
      bio: string
      fotoUrl: string | null
      updatedAt: Date
      updatedBy: number | null
    }, ExtArgs["result"]["leaderProfile"]>
    composites: {}
  }

  type LeaderProfileGetPayload<S extends boolean | null | undefined | LeaderProfileDefaultArgs> = $Result.GetResult<Prisma.$LeaderProfilePayload, S>

  type LeaderProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaderProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaderProfileCountAggregateInputType | true
    }

  export interface LeaderProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaderProfile'], meta: { name: 'LeaderProfile' } }
    /**
     * Find zero or one LeaderProfile that matches the filter.
     * @param {LeaderProfileFindUniqueArgs} args - Arguments to find a LeaderProfile
     * @example
     * // Get one LeaderProfile
     * const leaderProfile = await prisma.leaderProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaderProfileFindUniqueArgs>(args: SelectSubset<T, LeaderProfileFindUniqueArgs<ExtArgs>>): Prisma__LeaderProfileClient<$Result.GetResult<Prisma.$LeaderProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaderProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaderProfileFindUniqueOrThrowArgs} args - Arguments to find a LeaderProfile
     * @example
     * // Get one LeaderProfile
     * const leaderProfile = await prisma.leaderProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaderProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaderProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaderProfileClient<$Result.GetResult<Prisma.$LeaderProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaderProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderProfileFindFirstArgs} args - Arguments to find a LeaderProfile
     * @example
     * // Get one LeaderProfile
     * const leaderProfile = await prisma.leaderProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaderProfileFindFirstArgs>(args?: SelectSubset<T, LeaderProfileFindFirstArgs<ExtArgs>>): Prisma__LeaderProfileClient<$Result.GetResult<Prisma.$LeaderProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaderProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderProfileFindFirstOrThrowArgs} args - Arguments to find a LeaderProfile
     * @example
     * // Get one LeaderProfile
     * const leaderProfile = await prisma.leaderProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaderProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaderProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaderProfileClient<$Result.GetResult<Prisma.$LeaderProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaderProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaderProfiles
     * const leaderProfiles = await prisma.leaderProfile.findMany()
     * 
     * // Get first 10 LeaderProfiles
     * const leaderProfiles = await prisma.leaderProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderProfileWithIdOnly = await prisma.leaderProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaderProfileFindManyArgs>(args?: SelectSubset<T, LeaderProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaderProfile.
     * @param {LeaderProfileCreateArgs} args - Arguments to create a LeaderProfile.
     * @example
     * // Create one LeaderProfile
     * const LeaderProfile = await prisma.leaderProfile.create({
     *   data: {
     *     // ... data to create a LeaderProfile
     *   }
     * })
     * 
     */
    create<T extends LeaderProfileCreateArgs>(args: SelectSubset<T, LeaderProfileCreateArgs<ExtArgs>>): Prisma__LeaderProfileClient<$Result.GetResult<Prisma.$LeaderProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaderProfiles.
     * @param {LeaderProfileCreateManyArgs} args - Arguments to create many LeaderProfiles.
     * @example
     * // Create many LeaderProfiles
     * const leaderProfile = await prisma.leaderProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaderProfileCreateManyArgs>(args?: SelectSubset<T, LeaderProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaderProfiles and returns the data saved in the database.
     * @param {LeaderProfileCreateManyAndReturnArgs} args - Arguments to create many LeaderProfiles.
     * @example
     * // Create many LeaderProfiles
     * const leaderProfile = await prisma.leaderProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaderProfiles and only return the `id`
     * const leaderProfileWithIdOnly = await prisma.leaderProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaderProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaderProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaderProfile.
     * @param {LeaderProfileDeleteArgs} args - Arguments to delete one LeaderProfile.
     * @example
     * // Delete one LeaderProfile
     * const LeaderProfile = await prisma.leaderProfile.delete({
     *   where: {
     *     // ... filter to delete one LeaderProfile
     *   }
     * })
     * 
     */
    delete<T extends LeaderProfileDeleteArgs>(args: SelectSubset<T, LeaderProfileDeleteArgs<ExtArgs>>): Prisma__LeaderProfileClient<$Result.GetResult<Prisma.$LeaderProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaderProfile.
     * @param {LeaderProfileUpdateArgs} args - Arguments to update one LeaderProfile.
     * @example
     * // Update one LeaderProfile
     * const leaderProfile = await prisma.leaderProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaderProfileUpdateArgs>(args: SelectSubset<T, LeaderProfileUpdateArgs<ExtArgs>>): Prisma__LeaderProfileClient<$Result.GetResult<Prisma.$LeaderProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaderProfiles.
     * @param {LeaderProfileDeleteManyArgs} args - Arguments to filter LeaderProfiles to delete.
     * @example
     * // Delete a few LeaderProfiles
     * const { count } = await prisma.leaderProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaderProfileDeleteManyArgs>(args?: SelectSubset<T, LeaderProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaderProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaderProfiles
     * const leaderProfile = await prisma.leaderProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaderProfileUpdateManyArgs>(args: SelectSubset<T, LeaderProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaderProfiles and returns the data updated in the database.
     * @param {LeaderProfileUpdateManyAndReturnArgs} args - Arguments to update many LeaderProfiles.
     * @example
     * // Update many LeaderProfiles
     * const leaderProfile = await prisma.leaderProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaderProfiles and only return the `id`
     * const leaderProfileWithIdOnly = await prisma.leaderProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaderProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaderProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaderProfile.
     * @param {LeaderProfileUpsertArgs} args - Arguments to update or create a LeaderProfile.
     * @example
     * // Update or create a LeaderProfile
     * const leaderProfile = await prisma.leaderProfile.upsert({
     *   create: {
     *     // ... data to create a LeaderProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaderProfile we want to update
     *   }
     * })
     */
    upsert<T extends LeaderProfileUpsertArgs>(args: SelectSubset<T, LeaderProfileUpsertArgs<ExtArgs>>): Prisma__LeaderProfileClient<$Result.GetResult<Prisma.$LeaderProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaderProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderProfileCountArgs} args - Arguments to filter LeaderProfiles to count.
     * @example
     * // Count the number of LeaderProfiles
     * const count = await prisma.leaderProfile.count({
     *   where: {
     *     // ... the filter for the LeaderProfiles we want to count
     *   }
     * })
    **/
    count<T extends LeaderProfileCountArgs>(
      args?: Subset<T, LeaderProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaderProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderProfileAggregateArgs>(args: Subset<T, LeaderProfileAggregateArgs>): Prisma.PrismaPromise<GetLeaderProfileAggregateType<T>>

    /**
     * Group by LeaderProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderProfileGroupByArgs['orderBy'] }
        : { orderBy?: LeaderProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaderProfile model
   */
  readonly fields: LeaderProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaderProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaderProfile model
   */
  interface LeaderProfileFieldRefs {
    readonly id: FieldRef<"LeaderProfile", 'Int'>
    readonly roleKey: FieldRef<"LeaderProfile", 'String'>
    readonly nama: FieldRef<"LeaderProfile", 'String'>
    readonly jabatan: FieldRef<"LeaderProfile", 'String'>
    readonly pesan: FieldRef<"LeaderProfile", 'String'>
    readonly bio: FieldRef<"LeaderProfile", 'String'>
    readonly fotoUrl: FieldRef<"LeaderProfile", 'String'>
    readonly updatedAt: FieldRef<"LeaderProfile", 'DateTime'>
    readonly updatedBy: FieldRef<"LeaderProfile", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LeaderProfile findUnique
   */
  export type LeaderProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderProfile
     */
    select?: LeaderProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderProfile
     */
    omit?: LeaderProfileOmit<ExtArgs> | null
    /**
     * Filter, which LeaderProfile to fetch.
     */
    where: LeaderProfileWhereUniqueInput
  }

  /**
   * LeaderProfile findUniqueOrThrow
   */
  export type LeaderProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderProfile
     */
    select?: LeaderProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderProfile
     */
    omit?: LeaderProfileOmit<ExtArgs> | null
    /**
     * Filter, which LeaderProfile to fetch.
     */
    where: LeaderProfileWhereUniqueInput
  }

  /**
   * LeaderProfile findFirst
   */
  export type LeaderProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderProfile
     */
    select?: LeaderProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderProfile
     */
    omit?: LeaderProfileOmit<ExtArgs> | null
    /**
     * Filter, which LeaderProfile to fetch.
     */
    where?: LeaderProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderProfiles to fetch.
     */
    orderBy?: LeaderProfileOrderByWithRelationInput | LeaderProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderProfiles.
     */
    cursor?: LeaderProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderProfiles.
     */
    distinct?: LeaderProfileScalarFieldEnum | LeaderProfileScalarFieldEnum[]
  }

  /**
   * LeaderProfile findFirstOrThrow
   */
  export type LeaderProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderProfile
     */
    select?: LeaderProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderProfile
     */
    omit?: LeaderProfileOmit<ExtArgs> | null
    /**
     * Filter, which LeaderProfile to fetch.
     */
    where?: LeaderProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderProfiles to fetch.
     */
    orderBy?: LeaderProfileOrderByWithRelationInput | LeaderProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderProfiles.
     */
    cursor?: LeaderProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderProfiles.
     */
    distinct?: LeaderProfileScalarFieldEnum | LeaderProfileScalarFieldEnum[]
  }

  /**
   * LeaderProfile findMany
   */
  export type LeaderProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderProfile
     */
    select?: LeaderProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderProfile
     */
    omit?: LeaderProfileOmit<ExtArgs> | null
    /**
     * Filter, which LeaderProfiles to fetch.
     */
    where?: LeaderProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderProfiles to fetch.
     */
    orderBy?: LeaderProfileOrderByWithRelationInput | LeaderProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaderProfiles.
     */
    cursor?: LeaderProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderProfiles.
     */
    skip?: number
    distinct?: LeaderProfileScalarFieldEnum | LeaderProfileScalarFieldEnum[]
  }

  /**
   * LeaderProfile create
   */
  export type LeaderProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderProfile
     */
    select?: LeaderProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderProfile
     */
    omit?: LeaderProfileOmit<ExtArgs> | null
    /**
     * The data needed to create a LeaderProfile.
     */
    data: XOR<LeaderProfileCreateInput, LeaderProfileUncheckedCreateInput>
  }

  /**
   * LeaderProfile createMany
   */
  export type LeaderProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaderProfiles.
     */
    data: LeaderProfileCreateManyInput | LeaderProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaderProfile createManyAndReturn
   */
  export type LeaderProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderProfile
     */
    select?: LeaderProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderProfile
     */
    omit?: LeaderProfileOmit<ExtArgs> | null
    /**
     * The data used to create many LeaderProfiles.
     */
    data: LeaderProfileCreateManyInput | LeaderProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaderProfile update
   */
  export type LeaderProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderProfile
     */
    select?: LeaderProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderProfile
     */
    omit?: LeaderProfileOmit<ExtArgs> | null
    /**
     * The data needed to update a LeaderProfile.
     */
    data: XOR<LeaderProfileUpdateInput, LeaderProfileUncheckedUpdateInput>
    /**
     * Choose, which LeaderProfile to update.
     */
    where: LeaderProfileWhereUniqueInput
  }

  /**
   * LeaderProfile updateMany
   */
  export type LeaderProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaderProfiles.
     */
    data: XOR<LeaderProfileUpdateManyMutationInput, LeaderProfileUncheckedUpdateManyInput>
    /**
     * Filter which LeaderProfiles to update
     */
    where?: LeaderProfileWhereInput
    /**
     * Limit how many LeaderProfiles to update.
     */
    limit?: number
  }

  /**
   * LeaderProfile updateManyAndReturn
   */
  export type LeaderProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderProfile
     */
    select?: LeaderProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderProfile
     */
    omit?: LeaderProfileOmit<ExtArgs> | null
    /**
     * The data used to update LeaderProfiles.
     */
    data: XOR<LeaderProfileUpdateManyMutationInput, LeaderProfileUncheckedUpdateManyInput>
    /**
     * Filter which LeaderProfiles to update
     */
    where?: LeaderProfileWhereInput
    /**
     * Limit how many LeaderProfiles to update.
     */
    limit?: number
  }

  /**
   * LeaderProfile upsert
   */
  export type LeaderProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderProfile
     */
    select?: LeaderProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderProfile
     */
    omit?: LeaderProfileOmit<ExtArgs> | null
    /**
     * The filter to search for the LeaderProfile to update in case it exists.
     */
    where: LeaderProfileWhereUniqueInput
    /**
     * In case the LeaderProfile found by the `where` argument doesn't exist, create a new LeaderProfile with this data.
     */
    create: XOR<LeaderProfileCreateInput, LeaderProfileUncheckedCreateInput>
    /**
     * In case the LeaderProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderProfileUpdateInput, LeaderProfileUncheckedUpdateInput>
  }

  /**
   * LeaderProfile delete
   */
  export type LeaderProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderProfile
     */
    select?: LeaderProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderProfile
     */
    omit?: LeaderProfileOmit<ExtArgs> | null
    /**
     * Filter which LeaderProfile to delete.
     */
    where: LeaderProfileWhereUniqueInput
  }

  /**
   * LeaderProfile deleteMany
   */
  export type LeaderProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderProfiles to delete
     */
    where?: LeaderProfileWhereInput
    /**
     * Limit how many LeaderProfiles to delete.
     */
    limit?: number
  }

  /**
   * LeaderProfile without action
   */
  export type LeaderProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderProfile
     */
    select?: LeaderProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderProfile
     */
    omit?: LeaderProfileOmit<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    id: number | null
  }

  export type UnitSumAggregateOutputType = {
    id: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: number | null
    name: string | null
    logo: string | null
    description: string | null
  }

  export type UnitMaxAggregateOutputType = {
    id: number | null
    name: string | null
    logo: string | null
    description: string | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    name: number
    logo: number
    description: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    id?: true
  }

  export type UnitSumAggregateInputType = {
    id?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    description?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    description?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    description?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: number
    name: string
    logo: string | null
    description: string | null
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    description?: boolean
    anggota?: boolean | Unit$anggotaArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    description?: boolean
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    description?: boolean
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    name?: boolean
    logo?: boolean
    description?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "logo" | "description", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anggota?: boolean | Unit$anggotaArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      anggota: Prisma.$AnggotaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      logo: string | null
      description: string | null
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    anggota<T extends Unit$anggotaArgs<ExtArgs> = {}>(args?: Subset<T, Unit$anggotaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnggotaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'Int'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly logo: FieldRef<"Unit", 'String'>
    readonly description: FieldRef<"Unit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit updateManyAndReturn
   */
  export type UnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.anggota
   */
  export type Unit$anggotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anggota
     */
    select?: AnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anggota
     */
    omit?: AnggotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnggotaInclude<ExtArgs> | null
    where?: AnggotaWhereInput
    orderBy?: AnggotaOrderByWithRelationInput | AnggotaOrderByWithRelationInput[]
    cursor?: AnggotaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnggotaScalarFieldEnum | AnggotaScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model Anggota
   */

  export type AggregateAnggota = {
    _count: AnggotaCountAggregateOutputType | null
    _avg: AnggotaAvgAggregateOutputType | null
    _sum: AnggotaSumAggregateOutputType | null
    _min: AnggotaMinAggregateOutputType | null
    _max: AnggotaMaxAggregateOutputType | null
  }

  export type AnggotaAvgAggregateOutputType = {
    id: number | null
    unit_id: number | null
  }

  export type AnggotaSumAggregateOutputType = {
    id: number | null
    unit_id: number | null
  }

  export type AnggotaMinAggregateOutputType = {
    id: number | null
    nama: string | null
    jabatan: string | null
    foto_url: string | null
    unit_id: number | null
  }

  export type AnggotaMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    jabatan: string | null
    foto_url: string | null
    unit_id: number | null
  }

  export type AnggotaCountAggregateOutputType = {
    id: number
    nama: number
    jabatan: number
    foto_url: number
    unit_id: number
    _all: number
  }


  export type AnggotaAvgAggregateInputType = {
    id?: true
    unit_id?: true
  }

  export type AnggotaSumAggregateInputType = {
    id?: true
    unit_id?: true
  }

  export type AnggotaMinAggregateInputType = {
    id?: true
    nama?: true
    jabatan?: true
    foto_url?: true
    unit_id?: true
  }

  export type AnggotaMaxAggregateInputType = {
    id?: true
    nama?: true
    jabatan?: true
    foto_url?: true
    unit_id?: true
  }

  export type AnggotaCountAggregateInputType = {
    id?: true
    nama?: true
    jabatan?: true
    foto_url?: true
    unit_id?: true
    _all?: true
  }

  export type AnggotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anggota to aggregate.
     */
    where?: AnggotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anggotas to fetch.
     */
    orderBy?: AnggotaOrderByWithRelationInput | AnggotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnggotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anggotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anggotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Anggotas
    **/
    _count?: true | AnggotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnggotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnggotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnggotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnggotaMaxAggregateInputType
  }

  export type GetAnggotaAggregateType<T extends AnggotaAggregateArgs> = {
        [P in keyof T & keyof AggregateAnggota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnggota[P]>
      : GetScalarType<T[P], AggregateAnggota[P]>
  }




  export type AnggotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnggotaWhereInput
    orderBy?: AnggotaOrderByWithAggregationInput | AnggotaOrderByWithAggregationInput[]
    by: AnggotaScalarFieldEnum[] | AnggotaScalarFieldEnum
    having?: AnggotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnggotaCountAggregateInputType | true
    _avg?: AnggotaAvgAggregateInputType
    _sum?: AnggotaSumAggregateInputType
    _min?: AnggotaMinAggregateInputType
    _max?: AnggotaMaxAggregateInputType
  }

  export type AnggotaGroupByOutputType = {
    id: number
    nama: string
    jabatan: string
    foto_url: string | null
    unit_id: number
    _count: AnggotaCountAggregateOutputType | null
    _avg: AnggotaAvgAggregateOutputType | null
    _sum: AnggotaSumAggregateOutputType | null
    _min: AnggotaMinAggregateOutputType | null
    _max: AnggotaMaxAggregateOutputType | null
  }

  type GetAnggotaGroupByPayload<T extends AnggotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnggotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnggotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnggotaGroupByOutputType[P]>
            : GetScalarType<T[P], AnggotaGroupByOutputType[P]>
        }
      >
    >


  export type AnggotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    jabatan?: boolean
    foto_url?: boolean
    unit_id?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anggota"]>

  export type AnggotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    jabatan?: boolean
    foto_url?: boolean
    unit_id?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anggota"]>

  export type AnggotaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    jabatan?: boolean
    foto_url?: boolean
    unit_id?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anggota"]>

  export type AnggotaSelectScalar = {
    id?: boolean
    nama?: boolean
    jabatan?: boolean
    foto_url?: boolean
    unit_id?: boolean
  }

  export type AnggotaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nama" | "jabatan" | "foto_url" | "unit_id", ExtArgs["result"]["anggota"]>
  export type AnggotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type AnggotaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type AnggotaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $AnggotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Anggota"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      jabatan: string
      foto_url: string | null
      unit_id: number
    }, ExtArgs["result"]["anggota"]>
    composites: {}
  }

  type AnggotaGetPayload<S extends boolean | null | undefined | AnggotaDefaultArgs> = $Result.GetResult<Prisma.$AnggotaPayload, S>

  type AnggotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnggotaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnggotaCountAggregateInputType | true
    }

  export interface AnggotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Anggota'], meta: { name: 'Anggota' } }
    /**
     * Find zero or one Anggota that matches the filter.
     * @param {AnggotaFindUniqueArgs} args - Arguments to find a Anggota
     * @example
     * // Get one Anggota
     * const anggota = await prisma.anggota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnggotaFindUniqueArgs>(args: SelectSubset<T, AnggotaFindUniqueArgs<ExtArgs>>): Prisma__AnggotaClient<$Result.GetResult<Prisma.$AnggotaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Anggota that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnggotaFindUniqueOrThrowArgs} args - Arguments to find a Anggota
     * @example
     * // Get one Anggota
     * const anggota = await prisma.anggota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnggotaFindUniqueOrThrowArgs>(args: SelectSubset<T, AnggotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnggotaClient<$Result.GetResult<Prisma.$AnggotaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Anggota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnggotaFindFirstArgs} args - Arguments to find a Anggota
     * @example
     * // Get one Anggota
     * const anggota = await prisma.anggota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnggotaFindFirstArgs>(args?: SelectSubset<T, AnggotaFindFirstArgs<ExtArgs>>): Prisma__AnggotaClient<$Result.GetResult<Prisma.$AnggotaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Anggota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnggotaFindFirstOrThrowArgs} args - Arguments to find a Anggota
     * @example
     * // Get one Anggota
     * const anggota = await prisma.anggota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnggotaFindFirstOrThrowArgs>(args?: SelectSubset<T, AnggotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnggotaClient<$Result.GetResult<Prisma.$AnggotaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Anggotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnggotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Anggotas
     * const anggotas = await prisma.anggota.findMany()
     * 
     * // Get first 10 Anggotas
     * const anggotas = await prisma.anggota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anggotaWithIdOnly = await prisma.anggota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnggotaFindManyArgs>(args?: SelectSubset<T, AnggotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnggotaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Anggota.
     * @param {AnggotaCreateArgs} args - Arguments to create a Anggota.
     * @example
     * // Create one Anggota
     * const Anggota = await prisma.anggota.create({
     *   data: {
     *     // ... data to create a Anggota
     *   }
     * })
     * 
     */
    create<T extends AnggotaCreateArgs>(args: SelectSubset<T, AnggotaCreateArgs<ExtArgs>>): Prisma__AnggotaClient<$Result.GetResult<Prisma.$AnggotaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Anggotas.
     * @param {AnggotaCreateManyArgs} args - Arguments to create many Anggotas.
     * @example
     * // Create many Anggotas
     * const anggota = await prisma.anggota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnggotaCreateManyArgs>(args?: SelectSubset<T, AnggotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Anggotas and returns the data saved in the database.
     * @param {AnggotaCreateManyAndReturnArgs} args - Arguments to create many Anggotas.
     * @example
     * // Create many Anggotas
     * const anggota = await prisma.anggota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Anggotas and only return the `id`
     * const anggotaWithIdOnly = await prisma.anggota.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnggotaCreateManyAndReturnArgs>(args?: SelectSubset<T, AnggotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnggotaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Anggota.
     * @param {AnggotaDeleteArgs} args - Arguments to delete one Anggota.
     * @example
     * // Delete one Anggota
     * const Anggota = await prisma.anggota.delete({
     *   where: {
     *     // ... filter to delete one Anggota
     *   }
     * })
     * 
     */
    delete<T extends AnggotaDeleteArgs>(args: SelectSubset<T, AnggotaDeleteArgs<ExtArgs>>): Prisma__AnggotaClient<$Result.GetResult<Prisma.$AnggotaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Anggota.
     * @param {AnggotaUpdateArgs} args - Arguments to update one Anggota.
     * @example
     * // Update one Anggota
     * const anggota = await prisma.anggota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnggotaUpdateArgs>(args: SelectSubset<T, AnggotaUpdateArgs<ExtArgs>>): Prisma__AnggotaClient<$Result.GetResult<Prisma.$AnggotaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Anggotas.
     * @param {AnggotaDeleteManyArgs} args - Arguments to filter Anggotas to delete.
     * @example
     * // Delete a few Anggotas
     * const { count } = await prisma.anggota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnggotaDeleteManyArgs>(args?: SelectSubset<T, AnggotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anggotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnggotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Anggotas
     * const anggota = await prisma.anggota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnggotaUpdateManyArgs>(args: SelectSubset<T, AnggotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anggotas and returns the data updated in the database.
     * @param {AnggotaUpdateManyAndReturnArgs} args - Arguments to update many Anggotas.
     * @example
     * // Update many Anggotas
     * const anggota = await prisma.anggota.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Anggotas and only return the `id`
     * const anggotaWithIdOnly = await prisma.anggota.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnggotaUpdateManyAndReturnArgs>(args: SelectSubset<T, AnggotaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnggotaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Anggota.
     * @param {AnggotaUpsertArgs} args - Arguments to update or create a Anggota.
     * @example
     * // Update or create a Anggota
     * const anggota = await prisma.anggota.upsert({
     *   create: {
     *     // ... data to create a Anggota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Anggota we want to update
     *   }
     * })
     */
    upsert<T extends AnggotaUpsertArgs>(args: SelectSubset<T, AnggotaUpsertArgs<ExtArgs>>): Prisma__AnggotaClient<$Result.GetResult<Prisma.$AnggotaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Anggotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnggotaCountArgs} args - Arguments to filter Anggotas to count.
     * @example
     * // Count the number of Anggotas
     * const count = await prisma.anggota.count({
     *   where: {
     *     // ... the filter for the Anggotas we want to count
     *   }
     * })
    **/
    count<T extends AnggotaCountArgs>(
      args?: Subset<T, AnggotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnggotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Anggota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnggotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnggotaAggregateArgs>(args: Subset<T, AnggotaAggregateArgs>): Prisma.PrismaPromise<GetAnggotaAggregateType<T>>

    /**
     * Group by Anggota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnggotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnggotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnggotaGroupByArgs['orderBy'] }
        : { orderBy?: AnggotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnggotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnggotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Anggota model
   */
  readonly fields: AnggotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Anggota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnggotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Anggota model
   */
  interface AnggotaFieldRefs {
    readonly id: FieldRef<"Anggota", 'Int'>
    readonly nama: FieldRef<"Anggota", 'String'>
    readonly jabatan: FieldRef<"Anggota", 'String'>
    readonly foto_url: FieldRef<"Anggota", 'String'>
    readonly unit_id: FieldRef<"Anggota", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Anggota findUnique
   */
  export type AnggotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anggota
     */
    select?: AnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anggota
     */
    omit?: AnggotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnggotaInclude<ExtArgs> | null
    /**
     * Filter, which Anggota to fetch.
     */
    where: AnggotaWhereUniqueInput
  }

  /**
   * Anggota findUniqueOrThrow
   */
  export type AnggotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anggota
     */
    select?: AnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anggota
     */
    omit?: AnggotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnggotaInclude<ExtArgs> | null
    /**
     * Filter, which Anggota to fetch.
     */
    where: AnggotaWhereUniqueInput
  }

  /**
   * Anggota findFirst
   */
  export type AnggotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anggota
     */
    select?: AnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anggota
     */
    omit?: AnggotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnggotaInclude<ExtArgs> | null
    /**
     * Filter, which Anggota to fetch.
     */
    where?: AnggotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anggotas to fetch.
     */
    orderBy?: AnggotaOrderByWithRelationInput | AnggotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anggotas.
     */
    cursor?: AnggotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anggotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anggotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anggotas.
     */
    distinct?: AnggotaScalarFieldEnum | AnggotaScalarFieldEnum[]
  }

  /**
   * Anggota findFirstOrThrow
   */
  export type AnggotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anggota
     */
    select?: AnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anggota
     */
    omit?: AnggotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnggotaInclude<ExtArgs> | null
    /**
     * Filter, which Anggota to fetch.
     */
    where?: AnggotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anggotas to fetch.
     */
    orderBy?: AnggotaOrderByWithRelationInput | AnggotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anggotas.
     */
    cursor?: AnggotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anggotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anggotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anggotas.
     */
    distinct?: AnggotaScalarFieldEnum | AnggotaScalarFieldEnum[]
  }

  /**
   * Anggota findMany
   */
  export type AnggotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anggota
     */
    select?: AnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anggota
     */
    omit?: AnggotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnggotaInclude<ExtArgs> | null
    /**
     * Filter, which Anggotas to fetch.
     */
    where?: AnggotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anggotas to fetch.
     */
    orderBy?: AnggotaOrderByWithRelationInput | AnggotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Anggotas.
     */
    cursor?: AnggotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anggotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anggotas.
     */
    skip?: number
    distinct?: AnggotaScalarFieldEnum | AnggotaScalarFieldEnum[]
  }

  /**
   * Anggota create
   */
  export type AnggotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anggota
     */
    select?: AnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anggota
     */
    omit?: AnggotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnggotaInclude<ExtArgs> | null
    /**
     * The data needed to create a Anggota.
     */
    data: XOR<AnggotaCreateInput, AnggotaUncheckedCreateInput>
  }

  /**
   * Anggota createMany
   */
  export type AnggotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Anggotas.
     */
    data: AnggotaCreateManyInput | AnggotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Anggota createManyAndReturn
   */
  export type AnggotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anggota
     */
    select?: AnggotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Anggota
     */
    omit?: AnggotaOmit<ExtArgs> | null
    /**
     * The data used to create many Anggotas.
     */
    data: AnggotaCreateManyInput | AnggotaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnggotaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Anggota update
   */
  export type AnggotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anggota
     */
    select?: AnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anggota
     */
    omit?: AnggotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnggotaInclude<ExtArgs> | null
    /**
     * The data needed to update a Anggota.
     */
    data: XOR<AnggotaUpdateInput, AnggotaUncheckedUpdateInput>
    /**
     * Choose, which Anggota to update.
     */
    where: AnggotaWhereUniqueInput
  }

  /**
   * Anggota updateMany
   */
  export type AnggotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Anggotas.
     */
    data: XOR<AnggotaUpdateManyMutationInput, AnggotaUncheckedUpdateManyInput>
    /**
     * Filter which Anggotas to update
     */
    where?: AnggotaWhereInput
    /**
     * Limit how many Anggotas to update.
     */
    limit?: number
  }

  /**
   * Anggota updateManyAndReturn
   */
  export type AnggotaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anggota
     */
    select?: AnggotaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Anggota
     */
    omit?: AnggotaOmit<ExtArgs> | null
    /**
     * The data used to update Anggotas.
     */
    data: XOR<AnggotaUpdateManyMutationInput, AnggotaUncheckedUpdateManyInput>
    /**
     * Filter which Anggotas to update
     */
    where?: AnggotaWhereInput
    /**
     * Limit how many Anggotas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnggotaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Anggota upsert
   */
  export type AnggotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anggota
     */
    select?: AnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anggota
     */
    omit?: AnggotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnggotaInclude<ExtArgs> | null
    /**
     * The filter to search for the Anggota to update in case it exists.
     */
    where: AnggotaWhereUniqueInput
    /**
     * In case the Anggota found by the `where` argument doesn't exist, create a new Anggota with this data.
     */
    create: XOR<AnggotaCreateInput, AnggotaUncheckedCreateInput>
    /**
     * In case the Anggota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnggotaUpdateInput, AnggotaUncheckedUpdateInput>
  }

  /**
   * Anggota delete
   */
  export type AnggotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anggota
     */
    select?: AnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anggota
     */
    omit?: AnggotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnggotaInclude<ExtArgs> | null
    /**
     * Filter which Anggota to delete.
     */
    where: AnggotaWhereUniqueInput
  }

  /**
   * Anggota deleteMany
   */
  export type AnggotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anggotas to delete
     */
    where?: AnggotaWhereInput
    /**
     * Limit how many Anggotas to delete.
     */
    limit?: number
  }

  /**
   * Anggota without action
   */
  export type AnggotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anggota
     */
    select?: AnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anggota
     */
    omit?: AnggotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnggotaInclude<ExtArgs> | null
  }


  /**
   * Model Facility
   */

  export type AggregateFacility = {
    _count: FacilityCountAggregateOutputType | null
    _avg: FacilityAvgAggregateOutputType | null
    _sum: FacilitySumAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  export type FacilityAvgAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type FacilitySumAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type FacilityMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    image: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    image: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityCountAggregateOutputType = {
    id: number
    title: number
    description: number
    image: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacilityAvgAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type FacilitySumAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type FacilityMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facility to aggregate.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Facilities
    **/
    _count?: true | FacilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityMaxAggregateInputType
  }

  export type GetFacilityAggregateType<T extends FacilityAggregateArgs> = {
        [P in keyof T & keyof AggregateFacility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacility[P]>
      : GetScalarType<T[P], AggregateFacility[P]>
  }




  export type FacilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithAggregationInput | FacilityOrderByWithAggregationInput[]
    by: FacilityScalarFieldEnum[] | FacilityScalarFieldEnum
    having?: FacilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityCountAggregateInputType | true
    _avg?: FacilityAvgAggregateInputType
    _sum?: FacilitySumAggregateInputType
    _min?: FacilityMinAggregateInputType
    _max?: FacilityMaxAggregateInputType
  }

  export type FacilityGroupByOutputType = {
    id: number
    title: string
    description: string
    image: string | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: FacilityCountAggregateOutputType | null
    _avg: FacilityAvgAggregateOutputType | null
    _sum: FacilitySumAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  type GetFacilityGroupByPayload<T extends FacilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityGroupByOutputType[P]>
        }
      >
    >


  export type FacilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FacilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "image" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["facility"]>

  export type $FacilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Facility"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      image: string | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["facility"]>
    composites: {}
  }

  type FacilityGetPayload<S extends boolean | null | undefined | FacilityDefaultArgs> = $Result.GetResult<Prisma.$FacilityPayload, S>

  type FacilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacilityCountAggregateInputType | true
    }

  export interface FacilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Facility'], meta: { name: 'Facility' } }
    /**
     * Find zero or one Facility that matches the filter.
     * @param {FacilityFindUniqueArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityFindUniqueArgs>(args: SelectSubset<T, FacilityFindUniqueArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Facility that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacilityFindUniqueOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Facility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityFindFirstArgs>(args?: SelectSubset<T, FacilityFindFirstArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Facility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Facilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facilities
     * const facilities = await prisma.facility.findMany()
     * 
     * // Get first 10 Facilities
     * const facilities = await prisma.facility.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityWithIdOnly = await prisma.facility.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacilityFindManyArgs>(args?: SelectSubset<T, FacilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Facility.
     * @param {FacilityCreateArgs} args - Arguments to create a Facility.
     * @example
     * // Create one Facility
     * const Facility = await prisma.facility.create({
     *   data: {
     *     // ... data to create a Facility
     *   }
     * })
     * 
     */
    create<T extends FacilityCreateArgs>(args: SelectSubset<T, FacilityCreateArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Facilities.
     * @param {FacilityCreateManyArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilityCreateManyArgs>(args?: SelectSubset<T, FacilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Facilities and returns the data saved in the database.
     * @param {FacilityCreateManyAndReturnArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Facilities and only return the `id`
     * const facilityWithIdOnly = await prisma.facility.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacilityCreateManyAndReturnArgs>(args?: SelectSubset<T, FacilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Facility.
     * @param {FacilityDeleteArgs} args - Arguments to delete one Facility.
     * @example
     * // Delete one Facility
     * const Facility = await prisma.facility.delete({
     *   where: {
     *     // ... filter to delete one Facility
     *   }
     * })
     * 
     */
    delete<T extends FacilityDeleteArgs>(args: SelectSubset<T, FacilityDeleteArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Facility.
     * @param {FacilityUpdateArgs} args - Arguments to update one Facility.
     * @example
     * // Update one Facility
     * const facility = await prisma.facility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilityUpdateArgs>(args: SelectSubset<T, FacilityUpdateArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Facilities.
     * @param {FacilityDeleteManyArgs} args - Arguments to filter Facilities to delete.
     * @example
     * // Delete a few Facilities
     * const { count } = await prisma.facility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilityDeleteManyArgs>(args?: SelectSubset<T, FacilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facilities
     * const facility = await prisma.facility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilityUpdateManyArgs>(args: SelectSubset<T, FacilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilities and returns the data updated in the database.
     * @param {FacilityUpdateManyAndReturnArgs} args - Arguments to update many Facilities.
     * @example
     * // Update many Facilities
     * const facility = await prisma.facility.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Facilities and only return the `id`
     * const facilityWithIdOnly = await prisma.facility.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacilityUpdateManyAndReturnArgs>(args: SelectSubset<T, FacilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Facility.
     * @param {FacilityUpsertArgs} args - Arguments to update or create a Facility.
     * @example
     * // Update or create a Facility
     * const facility = await prisma.facility.upsert({
     *   create: {
     *     // ... data to create a Facility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facility we want to update
     *   }
     * })
     */
    upsert<T extends FacilityUpsertArgs>(args: SelectSubset<T, FacilityUpsertArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCountArgs} args - Arguments to filter Facilities to count.
     * @example
     * // Count the number of Facilities
     * const count = await prisma.facility.count({
     *   where: {
     *     // ... the filter for the Facilities we want to count
     *   }
     * })
    **/
    count<T extends FacilityCountArgs>(
      args?: Subset<T, FacilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityAggregateArgs>(args: Subset<T, FacilityAggregateArgs>): Prisma.PrismaPromise<GetFacilityAggregateType<T>>

    /**
     * Group by Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityGroupByArgs['orderBy'] }
        : { orderBy?: FacilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Facility model
   */
  readonly fields: FacilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Facility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Facility model
   */
  interface FacilityFieldRefs {
    readonly id: FieldRef<"Facility", 'Int'>
    readonly title: FieldRef<"Facility", 'String'>
    readonly description: FieldRef<"Facility", 'String'>
    readonly image: FieldRef<"Facility", 'String'>
    readonly sortOrder: FieldRef<"Facility", 'Int'>
    readonly createdAt: FieldRef<"Facility", 'DateTime'>
    readonly updatedAt: FieldRef<"Facility", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Facility findUnique
   */
  export type FacilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findUniqueOrThrow
   */
  export type FacilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findFirst
   */
  export type FacilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findFirstOrThrow
   */
  export type FacilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findMany
   */
  export type FacilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Filter, which Facilities to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility create
   */
  export type FacilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * The data needed to create a Facility.
     */
    data: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
  }

  /**
   * Facility createMany
   */
  export type FacilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facility createManyAndReturn
   */
  export type FacilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facility update
   */
  export type FacilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * The data needed to update a Facility.
     */
    data: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
    /**
     * Choose, which Facility to update.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility updateMany
   */
  export type FacilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Facilities.
     */
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyInput>
    /**
     * Filter which Facilities to update
     */
    where?: FacilityWhereInput
    /**
     * Limit how many Facilities to update.
     */
    limit?: number
  }

  /**
   * Facility updateManyAndReturn
   */
  export type FacilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * The data used to update Facilities.
     */
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyInput>
    /**
     * Filter which Facilities to update
     */
    where?: FacilityWhereInput
    /**
     * Limit how many Facilities to update.
     */
    limit?: number
  }

  /**
   * Facility upsert
   */
  export type FacilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * The filter to search for the Facility to update in case it exists.
     */
    where: FacilityWhereUniqueInput
    /**
     * In case the Facility found by the `where` argument doesn't exist, create a new Facility with this data.
     */
    create: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
    /**
     * In case the Facility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
  }

  /**
   * Facility delete
   */
  export type FacilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Filter which Facility to delete.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility deleteMany
   */
  export type FacilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facilities to delete
     */
    where?: FacilityWhereInput
    /**
     * Limit how many Facilities to delete.
     */
    limit?: number
  }

  /**
   * Facility without action
   */
  export type FacilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
  }


  /**
   * Model News
   */

  export type AggregateNews = {
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  export type NewsAvgAggregateOutputType = {
    id: number | null
    popularity: number | null
    viewCount: number | null
    shareCount: number | null
    sharedByUserId: number | null
  }

  export type NewsSumAggregateOutputType = {
    id: number | null
    popularity: number | null
    viewCount: number | null
    shareCount: number | null
    sharedByUserId: number | null
  }

  export type NewsMinAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    date: Date | null
    image: string | null
    excerpt: string | null
    content: string | null
    popularity: number | null
    viewCount: number | null
    shareCount: number | null
    sharedByUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    date: Date | null
    image: string | null
    excerpt: string | null
    content: string | null
    popularity: number | null
    viewCount: number | null
    shareCount: number | null
    sharedByUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    date: number
    image: number
    images: number
    excerpt: number
    content: number
    popularity: number
    viewCount: number
    shareCount: number
    sharedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsAvgAggregateInputType = {
    id?: true
    popularity?: true
    viewCount?: true
    shareCount?: true
    sharedByUserId?: true
  }

  export type NewsSumAggregateInputType = {
    id?: true
    popularity?: true
    viewCount?: true
    shareCount?: true
    sharedByUserId?: true
  }

  export type NewsMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    date?: true
    image?: true
    excerpt?: true
    content?: true
    popularity?: true
    viewCount?: true
    shareCount?: true
    sharedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    date?: true
    image?: true
    excerpt?: true
    content?: true
    popularity?: true
    viewCount?: true
    shareCount?: true
    sharedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    date?: true
    image?: true
    images?: true
    excerpt?: true
    content?: true
    popularity?: true
    viewCount?: true
    shareCount?: true
    sharedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to aggregate.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned News
    **/
    _count?: true | NewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsMaxAggregateInputType
  }

  export type GetNewsAggregateType<T extends NewsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews[P]>
      : GetScalarType<T[P], AggregateNews[P]>
  }




  export type NewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithAggregationInput | NewsOrderByWithAggregationInput[]
    by: NewsScalarFieldEnum[] | NewsScalarFieldEnum
    having?: NewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsCountAggregateInputType | true
    _avg?: NewsAvgAggregateInputType
    _sum?: NewsSumAggregateInputType
    _min?: NewsMinAggregateInputType
    _max?: NewsMaxAggregateInputType
  }

  export type NewsGroupByOutputType = {
    id: number
    title: string
    slug: string
    date: Date
    image: string | null
    images: JsonValue | null
    excerpt: string
    content: string
    popularity: number
    viewCount: number
    shareCount: number
    sharedByUserId: number | null
    createdAt: Date
    updatedAt: Date
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  type GetNewsGroupByPayload<T extends NewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsGroupByOutputType[P]>
            : GetScalarType<T[P], NewsGroupByOutputType[P]>
        }
      >
    >


  export type NewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    date?: boolean
    image?: boolean
    images?: boolean
    excerpt?: boolean
    content?: boolean
    popularity?: boolean
    viewCount?: boolean
    shareCount?: boolean
    sharedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sharedBy?: boolean | News$sharedByArgs<ExtArgs>
  }, ExtArgs["result"]["news"]>

  export type NewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    date?: boolean
    image?: boolean
    images?: boolean
    excerpt?: boolean
    content?: boolean
    popularity?: boolean
    viewCount?: boolean
    shareCount?: boolean
    sharedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sharedBy?: boolean | News$sharedByArgs<ExtArgs>
  }, ExtArgs["result"]["news"]>

  export type NewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    date?: boolean
    image?: boolean
    images?: boolean
    excerpt?: boolean
    content?: boolean
    popularity?: boolean
    viewCount?: boolean
    shareCount?: boolean
    sharedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sharedBy?: boolean | News$sharedByArgs<ExtArgs>
  }, ExtArgs["result"]["news"]>

  export type NewsSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    date?: boolean
    image?: boolean
    images?: boolean
    excerpt?: boolean
    content?: boolean
    popularity?: boolean
    viewCount?: boolean
    shareCount?: boolean
    sharedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "date" | "image" | "images" | "excerpt" | "content" | "popularity" | "viewCount" | "shareCount" | "sharedByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["news"]>
  export type NewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sharedBy?: boolean | News$sharedByArgs<ExtArgs>
  }
  export type NewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sharedBy?: boolean | News$sharedByArgs<ExtArgs>
  }
  export type NewsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sharedBy?: boolean | News$sharedByArgs<ExtArgs>
  }

  export type $NewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "News"
    objects: {
      sharedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      slug: string
      date: Date
      image: string | null
      images: Prisma.JsonValue | null
      excerpt: string
      content: string
      popularity: number
      viewCount: number
      shareCount: number
      sharedByUserId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["news"]>
    composites: {}
  }

  type NewsGetPayload<S extends boolean | null | undefined | NewsDefaultArgs> = $Result.GetResult<Prisma.$NewsPayload, S>

  type NewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsCountAggregateInputType | true
    }

  export interface NewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['News'], meta: { name: 'News' } }
    /**
     * Find zero or one News that matches the filter.
     * @param {NewsFindUniqueArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsFindUniqueArgs>(args: SelectSubset<T, NewsFindUniqueArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one News that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsFindUniqueOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsFindFirstArgs>(args?: SelectSubset<T, NewsFindFirstArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News
     * const news = await prisma.news.findMany()
     * 
     * // Get first 10 News
     * const news = await prisma.news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsWithIdOnly = await prisma.news.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsFindManyArgs>(args?: SelectSubset<T, NewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a News.
     * @param {NewsCreateArgs} args - Arguments to create a News.
     * @example
     * // Create one News
     * const News = await prisma.news.create({
     *   data: {
     *     // ... data to create a News
     *   }
     * })
     * 
     */
    create<T extends NewsCreateArgs>(args: SelectSubset<T, NewsCreateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many News.
     * @param {NewsCreateManyArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsCreateManyArgs>(args?: SelectSubset<T, NewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many News and returns the data saved in the database.
     * @param {NewsCreateManyAndReturnArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many News and only return the `id`
     * const newsWithIdOnly = await prisma.news.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a News.
     * @param {NewsDeleteArgs} args - Arguments to delete one News.
     * @example
     * // Delete one News
     * const News = await prisma.news.delete({
     *   where: {
     *     // ... filter to delete one News
     *   }
     * })
     * 
     */
    delete<T extends NewsDeleteArgs>(args: SelectSubset<T, NewsDeleteArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one News.
     * @param {NewsUpdateArgs} args - Arguments to update one News.
     * @example
     * // Update one News
     * const news = await prisma.news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsUpdateArgs>(args: SelectSubset<T, NewsUpdateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more News.
     * @param {NewsDeleteManyArgs} args - Arguments to filter News to delete.
     * @example
     * // Delete a few News
     * const { count } = await prisma.news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsDeleteManyArgs>(args?: SelectSubset<T, NewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News
     * const news = await prisma.news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsUpdateManyArgs>(args: SelectSubset<T, NewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News and returns the data updated in the database.
     * @param {NewsUpdateManyAndReturnArgs} args - Arguments to update many News.
     * @example
     * // Update many News
     * const news = await prisma.news.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more News and only return the `id`
     * const newsWithIdOnly = await prisma.news.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one News.
     * @param {NewsUpsertArgs} args - Arguments to update or create a News.
     * @example
     * // Update or create a News
     * const news = await prisma.news.upsert({
     *   create: {
     *     // ... data to create a News
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News we want to update
     *   }
     * })
     */
    upsert<T extends NewsUpsertArgs>(args: SelectSubset<T, NewsUpsertArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsCountArgs} args - Arguments to filter News to count.
     * @example
     * // Count the number of News
     * const count = await prisma.news.count({
     *   where: {
     *     // ... the filter for the News we want to count
     *   }
     * })
    **/
    count<T extends NewsCountArgs>(
      args?: Subset<T, NewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAggregateArgs>(args: Subset<T, NewsAggregateArgs>): Prisma.PrismaPromise<GetNewsAggregateType<T>>

    /**
     * Group by News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsGroupByArgs['orderBy'] }
        : { orderBy?: NewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the News model
   */
  readonly fields: NewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for News.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sharedBy<T extends News$sharedByArgs<ExtArgs> = {}>(args?: Subset<T, News$sharedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the News model
   */
  interface NewsFieldRefs {
    readonly id: FieldRef<"News", 'Int'>
    readonly title: FieldRef<"News", 'String'>
    readonly slug: FieldRef<"News", 'String'>
    readonly date: FieldRef<"News", 'DateTime'>
    readonly image: FieldRef<"News", 'String'>
    readonly images: FieldRef<"News", 'Json'>
    readonly excerpt: FieldRef<"News", 'String'>
    readonly content: FieldRef<"News", 'String'>
    readonly popularity: FieldRef<"News", 'Int'>
    readonly viewCount: FieldRef<"News", 'Int'>
    readonly shareCount: FieldRef<"News", 'Int'>
    readonly sharedByUserId: FieldRef<"News", 'Int'>
    readonly createdAt: FieldRef<"News", 'DateTime'>
    readonly updatedAt: FieldRef<"News", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * News findUnique
   */
  export type NewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findUniqueOrThrow
   */
  export type NewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findFirst
   */
  export type NewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findFirstOrThrow
   */
  export type NewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findMany
   */
  export type NewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News create
   */
  export type NewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The data needed to create a News.
     */
    data: XOR<NewsCreateInput, NewsUncheckedCreateInput>
  }

  /**
   * News createMany
   */
  export type NewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * News createManyAndReturn
   */
  export type NewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * News update
   */
  export type NewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The data needed to update a News.
     */
    data: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
    /**
     * Choose, which News to update.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News updateMany
   */
  export type NewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update News.
     */
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyInput>
    /**
     * Filter which News to update
     */
    where?: NewsWhereInput
    /**
     * Limit how many News to update.
     */
    limit?: number
  }

  /**
   * News updateManyAndReturn
   */
  export type NewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data used to update News.
     */
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyInput>
    /**
     * Filter which News to update
     */
    where?: NewsWhereInput
    /**
     * Limit how many News to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * News upsert
   */
  export type NewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The filter to search for the News to update in case it exists.
     */
    where: NewsWhereUniqueInput
    /**
     * In case the News found by the `where` argument doesn't exist, create a new News with this data.
     */
    create: XOR<NewsCreateInput, NewsUncheckedCreateInput>
    /**
     * In case the News was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
  }

  /**
   * News delete
   */
  export type NewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter which News to delete.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News deleteMany
   */
  export type NewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to delete
     */
    where?: NewsWhereInput
    /**
     * Limit how many News to delete.
     */
    limit?: number
  }

  /**
   * News.sharedBy
   */
  export type News$sharedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * News without action
   */
  export type NewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
  }


  /**
   * Model Education
   */

  export type AggregateEducation = {
    _count: EducationCountAggregateOutputType | null
    _avg: EducationAvgAggregateOutputType | null
    _sum: EducationSumAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  export type EducationAvgAggregateOutputType = {
    id: number | null
    popularity: number | null
    viewCount: number | null
    shareCount: number | null
    sharedByUserId: number | null
  }

  export type EducationSumAggregateOutputType = {
    id: number | null
    popularity: number | null
    viewCount: number | null
    shareCount: number | null
    sharedByUserId: number | null
  }

  export type EducationMinAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    date: Date | null
    image: string | null
    excerpt: string | null
    content: string | null
    popularity: number | null
    viewCount: number | null
    shareCount: number | null
    sharedByUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EducationMaxAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    date: Date | null
    image: string | null
    excerpt: string | null
    content: string | null
    popularity: number | null
    viewCount: number | null
    shareCount: number | null
    sharedByUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EducationCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    date: number
    image: number
    images: number
    excerpt: number
    content: number
    popularity: number
    viewCount: number
    shareCount: number
    sharedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EducationAvgAggregateInputType = {
    id?: true
    popularity?: true
    viewCount?: true
    shareCount?: true
    sharedByUserId?: true
  }

  export type EducationSumAggregateInputType = {
    id?: true
    popularity?: true
    viewCount?: true
    shareCount?: true
    sharedByUserId?: true
  }

  export type EducationMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    date?: true
    image?: true
    excerpt?: true
    content?: true
    popularity?: true
    viewCount?: true
    shareCount?: true
    sharedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EducationMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    date?: true
    image?: true
    excerpt?: true
    content?: true
    popularity?: true
    viewCount?: true
    shareCount?: true
    sharedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EducationCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    date?: true
    image?: true
    images?: true
    excerpt?: true
    content?: true
    popularity?: true
    viewCount?: true
    shareCount?: true
    sharedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EducationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Education to aggregate.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Educations
    **/
    _count?: true | EducationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EducationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EducationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationMaxAggregateInputType
  }

  export type GetEducationAggregateType<T extends EducationAggregateArgs> = {
        [P in keyof T & keyof AggregateEducation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducation[P]>
      : GetScalarType<T[P], AggregateEducation[P]>
  }




  export type EducationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationWhereInput
    orderBy?: EducationOrderByWithAggregationInput | EducationOrderByWithAggregationInput[]
    by: EducationScalarFieldEnum[] | EducationScalarFieldEnum
    having?: EducationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationCountAggregateInputType | true
    _avg?: EducationAvgAggregateInputType
    _sum?: EducationSumAggregateInputType
    _min?: EducationMinAggregateInputType
    _max?: EducationMaxAggregateInputType
  }

  export type EducationGroupByOutputType = {
    id: number
    title: string
    slug: string
    date: Date
    image: string | null
    images: JsonValue | null
    excerpt: string | null
    content: string
    popularity: number
    viewCount: number
    shareCount: number
    sharedByUserId: number | null
    createdAt: Date
    updatedAt: Date
    _count: EducationCountAggregateOutputType | null
    _avg: EducationAvgAggregateOutputType | null
    _sum: EducationSumAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  type GetEducationGroupByPayload<T extends EducationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationGroupByOutputType[P]>
            : GetScalarType<T[P], EducationGroupByOutputType[P]>
        }
      >
    >


  export type EducationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    date?: boolean
    image?: boolean
    images?: boolean
    excerpt?: boolean
    content?: boolean
    popularity?: boolean
    viewCount?: boolean
    shareCount?: boolean
    sharedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sharedBy?: boolean | Education$sharedByArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    date?: boolean
    image?: boolean
    images?: boolean
    excerpt?: boolean
    content?: boolean
    popularity?: boolean
    viewCount?: boolean
    shareCount?: boolean
    sharedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sharedBy?: boolean | Education$sharedByArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    date?: boolean
    image?: boolean
    images?: boolean
    excerpt?: boolean
    content?: boolean
    popularity?: boolean
    viewCount?: boolean
    shareCount?: boolean
    sharedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sharedBy?: boolean | Education$sharedByArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    date?: boolean
    image?: boolean
    images?: boolean
    excerpt?: boolean
    content?: boolean
    popularity?: boolean
    viewCount?: boolean
    shareCount?: boolean
    sharedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EducationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "date" | "image" | "images" | "excerpt" | "content" | "popularity" | "viewCount" | "shareCount" | "sharedByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["education"]>
  export type EducationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sharedBy?: boolean | Education$sharedByArgs<ExtArgs>
  }
  export type EducationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sharedBy?: boolean | Education$sharedByArgs<ExtArgs>
  }
  export type EducationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sharedBy?: boolean | Education$sharedByArgs<ExtArgs>
  }

  export type $EducationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Education"
    objects: {
      sharedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      slug: string
      date: Date
      image: string | null
      images: Prisma.JsonValue | null
      excerpt: string | null
      content: string
      popularity: number
      viewCount: number
      shareCount: number
      sharedByUserId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["education"]>
    composites: {}
  }

  type EducationGetPayload<S extends boolean | null | undefined | EducationDefaultArgs> = $Result.GetResult<Prisma.$EducationPayload, S>

  type EducationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EducationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EducationCountAggregateInputType | true
    }

  export interface EducationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Education'], meta: { name: 'Education' } }
    /**
     * Find zero or one Education that matches the filter.
     * @param {EducationFindUniqueArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationFindUniqueArgs>(args: SelectSubset<T, EducationFindUniqueArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Education that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EducationFindUniqueOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Education that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationFindFirstArgs>(args?: SelectSubset<T, EducationFindFirstArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Education that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Educations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Educations
     * const educations = await prisma.education.findMany()
     * 
     * // Get first 10 Educations
     * const educations = await prisma.education.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationWithIdOnly = await prisma.education.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EducationFindManyArgs>(args?: SelectSubset<T, EducationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Education.
     * @param {EducationCreateArgs} args - Arguments to create a Education.
     * @example
     * // Create one Education
     * const Education = await prisma.education.create({
     *   data: {
     *     // ... data to create a Education
     *   }
     * })
     * 
     */
    create<T extends EducationCreateArgs>(args: SelectSubset<T, EducationCreateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Educations.
     * @param {EducationCreateManyArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const education = await prisma.education.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationCreateManyArgs>(args?: SelectSubset<T, EducationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Educations and returns the data saved in the database.
     * @param {EducationCreateManyAndReturnArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const education = await prisma.education.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Educations and only return the `id`
     * const educationWithIdOnly = await prisma.education.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EducationCreateManyAndReturnArgs>(args?: SelectSubset<T, EducationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Education.
     * @param {EducationDeleteArgs} args - Arguments to delete one Education.
     * @example
     * // Delete one Education
     * const Education = await prisma.education.delete({
     *   where: {
     *     // ... filter to delete one Education
     *   }
     * })
     * 
     */
    delete<T extends EducationDeleteArgs>(args: SelectSubset<T, EducationDeleteArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Education.
     * @param {EducationUpdateArgs} args - Arguments to update one Education.
     * @example
     * // Update one Education
     * const education = await prisma.education.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationUpdateArgs>(args: SelectSubset<T, EducationUpdateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Educations.
     * @param {EducationDeleteManyArgs} args - Arguments to filter Educations to delete.
     * @example
     * // Delete a few Educations
     * const { count } = await prisma.education.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationDeleteManyArgs>(args?: SelectSubset<T, EducationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Educations
     * const education = await prisma.education.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationUpdateManyArgs>(args: SelectSubset<T, EducationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations and returns the data updated in the database.
     * @param {EducationUpdateManyAndReturnArgs} args - Arguments to update many Educations.
     * @example
     * // Update many Educations
     * const education = await prisma.education.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Educations and only return the `id`
     * const educationWithIdOnly = await prisma.education.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EducationUpdateManyAndReturnArgs>(args: SelectSubset<T, EducationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Education.
     * @param {EducationUpsertArgs} args - Arguments to update or create a Education.
     * @example
     * // Update or create a Education
     * const education = await prisma.education.upsert({
     *   create: {
     *     // ... data to create a Education
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Education we want to update
     *   }
     * })
     */
    upsert<T extends EducationUpsertArgs>(args: SelectSubset<T, EducationUpsertArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationCountArgs} args - Arguments to filter Educations to count.
     * @example
     * // Count the number of Educations
     * const count = await prisma.education.count({
     *   where: {
     *     // ... the filter for the Educations we want to count
     *   }
     * })
    **/
    count<T extends EducationCountArgs>(
      args?: Subset<T, EducationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationAggregateArgs>(args: Subset<T, EducationAggregateArgs>): Prisma.PrismaPromise<GetEducationAggregateType<T>>

    /**
     * Group by Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationGroupByArgs['orderBy'] }
        : { orderBy?: EducationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Education model
   */
  readonly fields: EducationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Education.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sharedBy<T extends Education$sharedByArgs<ExtArgs> = {}>(args?: Subset<T, Education$sharedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Education model
   */
  interface EducationFieldRefs {
    readonly id: FieldRef<"Education", 'Int'>
    readonly title: FieldRef<"Education", 'String'>
    readonly slug: FieldRef<"Education", 'String'>
    readonly date: FieldRef<"Education", 'DateTime'>
    readonly image: FieldRef<"Education", 'String'>
    readonly images: FieldRef<"Education", 'Json'>
    readonly excerpt: FieldRef<"Education", 'String'>
    readonly content: FieldRef<"Education", 'String'>
    readonly popularity: FieldRef<"Education", 'Int'>
    readonly viewCount: FieldRef<"Education", 'Int'>
    readonly shareCount: FieldRef<"Education", 'Int'>
    readonly sharedByUserId: FieldRef<"Education", 'Int'>
    readonly createdAt: FieldRef<"Education", 'DateTime'>
    readonly updatedAt: FieldRef<"Education", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Education findUnique
   */
  export type EducationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findUniqueOrThrow
   */
  export type EducationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findFirst
   */
  export type EducationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findFirstOrThrow
   */
  export type EducationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findMany
   */
  export type EducationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Educations to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education create
   */
  export type EducationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to create a Education.
     */
    data: XOR<EducationCreateInput, EducationUncheckedCreateInput>
  }

  /**
   * Education createMany
   */
  export type EducationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Educations.
     */
    data: EducationCreateManyInput | EducationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Education createManyAndReturn
   */
  export type EducationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * The data used to create many Educations.
     */
    data: EducationCreateManyInput | EducationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Education update
   */
  export type EducationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to update a Education.
     */
    data: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
    /**
     * Choose, which Education to update.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education updateMany
   */
  export type EducationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Educations.
     */
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyInput>
    /**
     * Filter which Educations to update
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to update.
     */
    limit?: number
  }

  /**
   * Education updateManyAndReturn
   */
  export type EducationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * The data used to update Educations.
     */
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyInput>
    /**
     * Filter which Educations to update
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Education upsert
   */
  export type EducationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The filter to search for the Education to update in case it exists.
     */
    where: EducationWhereUniqueInput
    /**
     * In case the Education found by the `where` argument doesn't exist, create a new Education with this data.
     */
    create: XOR<EducationCreateInput, EducationUncheckedCreateInput>
    /**
     * In case the Education was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
  }

  /**
   * Education delete
   */
  export type EducationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter which Education to delete.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education deleteMany
   */
  export type EducationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Educations to delete
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to delete.
     */
    limit?: number
  }

  /**
   * Education.sharedBy
   */
  export type Education$sharedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Education without action
   */
  export type EducationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
  }


  /**
   * Model LetterCounter
   */

  export type AggregateLetterCounter = {
    _count: LetterCounterCountAggregateOutputType | null
    _avg: LetterCounterAvgAggregateOutputType | null
    _sum: LetterCounterSumAggregateOutputType | null
    _min: LetterCounterMinAggregateOutputType | null
    _max: LetterCounterMaxAggregateOutputType | null
  }

  export type LetterCounterAvgAggregateOutputType = {
    id: number | null
    year: number | null
    nextNumber: number | null
  }

  export type LetterCounterSumAggregateOutputType = {
    id: number | null
    year: number | null
    nextNumber: number | null
  }

  export type LetterCounterMinAggregateOutputType = {
    id: number | null
    type: $Enums.LetterType | null
    year: number | null
    nextNumber: number | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type LetterCounterMaxAggregateOutputType = {
    id: number | null
    type: $Enums.LetterType | null
    year: number | null
    nextNumber: number | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type LetterCounterCountAggregateOutputType = {
    id: number
    type: number
    year: number
    nextNumber: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type LetterCounterAvgAggregateInputType = {
    id?: true
    year?: true
    nextNumber?: true
  }

  export type LetterCounterSumAggregateInputType = {
    id?: true
    year?: true
    nextNumber?: true
  }

  export type LetterCounterMinAggregateInputType = {
    id?: true
    type?: true
    year?: true
    nextNumber?: true
    updatedAt?: true
    createdAt?: true
  }

  export type LetterCounterMaxAggregateInputType = {
    id?: true
    type?: true
    year?: true
    nextNumber?: true
    updatedAt?: true
    createdAt?: true
  }

  export type LetterCounterCountAggregateInputType = {
    id?: true
    type?: true
    year?: true
    nextNumber?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type LetterCounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LetterCounter to aggregate.
     */
    where?: LetterCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LetterCounters to fetch.
     */
    orderBy?: LetterCounterOrderByWithRelationInput | LetterCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LetterCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LetterCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LetterCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LetterCounters
    **/
    _count?: true | LetterCounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LetterCounterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LetterCounterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LetterCounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LetterCounterMaxAggregateInputType
  }

  export type GetLetterCounterAggregateType<T extends LetterCounterAggregateArgs> = {
        [P in keyof T & keyof AggregateLetterCounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLetterCounter[P]>
      : GetScalarType<T[P], AggregateLetterCounter[P]>
  }




  export type LetterCounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LetterCounterWhereInput
    orderBy?: LetterCounterOrderByWithAggregationInput | LetterCounterOrderByWithAggregationInput[]
    by: LetterCounterScalarFieldEnum[] | LetterCounterScalarFieldEnum
    having?: LetterCounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LetterCounterCountAggregateInputType | true
    _avg?: LetterCounterAvgAggregateInputType
    _sum?: LetterCounterSumAggregateInputType
    _min?: LetterCounterMinAggregateInputType
    _max?: LetterCounterMaxAggregateInputType
  }

  export type LetterCounterGroupByOutputType = {
    id: number
    type: $Enums.LetterType
    year: number
    nextNumber: number
    updatedAt: Date
    createdAt: Date
    _count: LetterCounterCountAggregateOutputType | null
    _avg: LetterCounterAvgAggregateOutputType | null
    _sum: LetterCounterSumAggregateOutputType | null
    _min: LetterCounterMinAggregateOutputType | null
    _max: LetterCounterMaxAggregateOutputType | null
  }

  type GetLetterCounterGroupByPayload<T extends LetterCounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LetterCounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LetterCounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LetterCounterGroupByOutputType[P]>
            : GetScalarType<T[P], LetterCounterGroupByOutputType[P]>
        }
      >
    >


  export type LetterCounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    year?: boolean
    nextNumber?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["letterCounter"]>

  export type LetterCounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    year?: boolean
    nextNumber?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["letterCounter"]>

  export type LetterCounterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    year?: boolean
    nextNumber?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["letterCounter"]>

  export type LetterCounterSelectScalar = {
    id?: boolean
    type?: boolean
    year?: boolean
    nextNumber?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type LetterCounterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "year" | "nextNumber" | "updatedAt" | "createdAt", ExtArgs["result"]["letterCounter"]>

  export type $LetterCounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LetterCounter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.LetterType
      year: number
      nextNumber: number
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["letterCounter"]>
    composites: {}
  }

  type LetterCounterGetPayload<S extends boolean | null | undefined | LetterCounterDefaultArgs> = $Result.GetResult<Prisma.$LetterCounterPayload, S>

  type LetterCounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LetterCounterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LetterCounterCountAggregateInputType | true
    }

  export interface LetterCounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LetterCounter'], meta: { name: 'LetterCounter' } }
    /**
     * Find zero or one LetterCounter that matches the filter.
     * @param {LetterCounterFindUniqueArgs} args - Arguments to find a LetterCounter
     * @example
     * // Get one LetterCounter
     * const letterCounter = await prisma.letterCounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LetterCounterFindUniqueArgs>(args: SelectSubset<T, LetterCounterFindUniqueArgs<ExtArgs>>): Prisma__LetterCounterClient<$Result.GetResult<Prisma.$LetterCounterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LetterCounter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LetterCounterFindUniqueOrThrowArgs} args - Arguments to find a LetterCounter
     * @example
     * // Get one LetterCounter
     * const letterCounter = await prisma.letterCounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LetterCounterFindUniqueOrThrowArgs>(args: SelectSubset<T, LetterCounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LetterCounterClient<$Result.GetResult<Prisma.$LetterCounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LetterCounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterCounterFindFirstArgs} args - Arguments to find a LetterCounter
     * @example
     * // Get one LetterCounter
     * const letterCounter = await prisma.letterCounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LetterCounterFindFirstArgs>(args?: SelectSubset<T, LetterCounterFindFirstArgs<ExtArgs>>): Prisma__LetterCounterClient<$Result.GetResult<Prisma.$LetterCounterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LetterCounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterCounterFindFirstOrThrowArgs} args - Arguments to find a LetterCounter
     * @example
     * // Get one LetterCounter
     * const letterCounter = await prisma.letterCounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LetterCounterFindFirstOrThrowArgs>(args?: SelectSubset<T, LetterCounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__LetterCounterClient<$Result.GetResult<Prisma.$LetterCounterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LetterCounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterCounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LetterCounters
     * const letterCounters = await prisma.letterCounter.findMany()
     * 
     * // Get first 10 LetterCounters
     * const letterCounters = await prisma.letterCounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const letterCounterWithIdOnly = await prisma.letterCounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LetterCounterFindManyArgs>(args?: SelectSubset<T, LetterCounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LetterCounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LetterCounter.
     * @param {LetterCounterCreateArgs} args - Arguments to create a LetterCounter.
     * @example
     * // Create one LetterCounter
     * const LetterCounter = await prisma.letterCounter.create({
     *   data: {
     *     // ... data to create a LetterCounter
     *   }
     * })
     * 
     */
    create<T extends LetterCounterCreateArgs>(args: SelectSubset<T, LetterCounterCreateArgs<ExtArgs>>): Prisma__LetterCounterClient<$Result.GetResult<Prisma.$LetterCounterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LetterCounters.
     * @param {LetterCounterCreateManyArgs} args - Arguments to create many LetterCounters.
     * @example
     * // Create many LetterCounters
     * const letterCounter = await prisma.letterCounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LetterCounterCreateManyArgs>(args?: SelectSubset<T, LetterCounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LetterCounters and returns the data saved in the database.
     * @param {LetterCounterCreateManyAndReturnArgs} args - Arguments to create many LetterCounters.
     * @example
     * // Create many LetterCounters
     * const letterCounter = await prisma.letterCounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LetterCounters and only return the `id`
     * const letterCounterWithIdOnly = await prisma.letterCounter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LetterCounterCreateManyAndReturnArgs>(args?: SelectSubset<T, LetterCounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LetterCounterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LetterCounter.
     * @param {LetterCounterDeleteArgs} args - Arguments to delete one LetterCounter.
     * @example
     * // Delete one LetterCounter
     * const LetterCounter = await prisma.letterCounter.delete({
     *   where: {
     *     // ... filter to delete one LetterCounter
     *   }
     * })
     * 
     */
    delete<T extends LetterCounterDeleteArgs>(args: SelectSubset<T, LetterCounterDeleteArgs<ExtArgs>>): Prisma__LetterCounterClient<$Result.GetResult<Prisma.$LetterCounterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LetterCounter.
     * @param {LetterCounterUpdateArgs} args - Arguments to update one LetterCounter.
     * @example
     * // Update one LetterCounter
     * const letterCounter = await prisma.letterCounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LetterCounterUpdateArgs>(args: SelectSubset<T, LetterCounterUpdateArgs<ExtArgs>>): Prisma__LetterCounterClient<$Result.GetResult<Prisma.$LetterCounterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LetterCounters.
     * @param {LetterCounterDeleteManyArgs} args - Arguments to filter LetterCounters to delete.
     * @example
     * // Delete a few LetterCounters
     * const { count } = await prisma.letterCounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LetterCounterDeleteManyArgs>(args?: SelectSubset<T, LetterCounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LetterCounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterCounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LetterCounters
     * const letterCounter = await prisma.letterCounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LetterCounterUpdateManyArgs>(args: SelectSubset<T, LetterCounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LetterCounters and returns the data updated in the database.
     * @param {LetterCounterUpdateManyAndReturnArgs} args - Arguments to update many LetterCounters.
     * @example
     * // Update many LetterCounters
     * const letterCounter = await prisma.letterCounter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LetterCounters and only return the `id`
     * const letterCounterWithIdOnly = await prisma.letterCounter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LetterCounterUpdateManyAndReturnArgs>(args: SelectSubset<T, LetterCounterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LetterCounterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LetterCounter.
     * @param {LetterCounterUpsertArgs} args - Arguments to update or create a LetterCounter.
     * @example
     * // Update or create a LetterCounter
     * const letterCounter = await prisma.letterCounter.upsert({
     *   create: {
     *     // ... data to create a LetterCounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LetterCounter we want to update
     *   }
     * })
     */
    upsert<T extends LetterCounterUpsertArgs>(args: SelectSubset<T, LetterCounterUpsertArgs<ExtArgs>>): Prisma__LetterCounterClient<$Result.GetResult<Prisma.$LetterCounterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LetterCounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterCounterCountArgs} args - Arguments to filter LetterCounters to count.
     * @example
     * // Count the number of LetterCounters
     * const count = await prisma.letterCounter.count({
     *   where: {
     *     // ... the filter for the LetterCounters we want to count
     *   }
     * })
    **/
    count<T extends LetterCounterCountArgs>(
      args?: Subset<T, LetterCounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LetterCounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LetterCounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterCounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LetterCounterAggregateArgs>(args: Subset<T, LetterCounterAggregateArgs>): Prisma.PrismaPromise<GetLetterCounterAggregateType<T>>

    /**
     * Group by LetterCounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterCounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LetterCounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LetterCounterGroupByArgs['orderBy'] }
        : { orderBy?: LetterCounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LetterCounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLetterCounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LetterCounter model
   */
  readonly fields: LetterCounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LetterCounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LetterCounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LetterCounter model
   */
  interface LetterCounterFieldRefs {
    readonly id: FieldRef<"LetterCounter", 'Int'>
    readonly type: FieldRef<"LetterCounter", 'LetterType'>
    readonly year: FieldRef<"LetterCounter", 'Int'>
    readonly nextNumber: FieldRef<"LetterCounter", 'Int'>
    readonly updatedAt: FieldRef<"LetterCounter", 'DateTime'>
    readonly createdAt: FieldRef<"LetterCounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LetterCounter findUnique
   */
  export type LetterCounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterCounter
     */
    select?: LetterCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterCounter
     */
    omit?: LetterCounterOmit<ExtArgs> | null
    /**
     * Filter, which LetterCounter to fetch.
     */
    where: LetterCounterWhereUniqueInput
  }

  /**
   * LetterCounter findUniqueOrThrow
   */
  export type LetterCounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterCounter
     */
    select?: LetterCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterCounter
     */
    omit?: LetterCounterOmit<ExtArgs> | null
    /**
     * Filter, which LetterCounter to fetch.
     */
    where: LetterCounterWhereUniqueInput
  }

  /**
   * LetterCounter findFirst
   */
  export type LetterCounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterCounter
     */
    select?: LetterCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterCounter
     */
    omit?: LetterCounterOmit<ExtArgs> | null
    /**
     * Filter, which LetterCounter to fetch.
     */
    where?: LetterCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LetterCounters to fetch.
     */
    orderBy?: LetterCounterOrderByWithRelationInput | LetterCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LetterCounters.
     */
    cursor?: LetterCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LetterCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LetterCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LetterCounters.
     */
    distinct?: LetterCounterScalarFieldEnum | LetterCounterScalarFieldEnum[]
  }

  /**
   * LetterCounter findFirstOrThrow
   */
  export type LetterCounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterCounter
     */
    select?: LetterCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterCounter
     */
    omit?: LetterCounterOmit<ExtArgs> | null
    /**
     * Filter, which LetterCounter to fetch.
     */
    where?: LetterCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LetterCounters to fetch.
     */
    orderBy?: LetterCounterOrderByWithRelationInput | LetterCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LetterCounters.
     */
    cursor?: LetterCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LetterCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LetterCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LetterCounters.
     */
    distinct?: LetterCounterScalarFieldEnum | LetterCounterScalarFieldEnum[]
  }

  /**
   * LetterCounter findMany
   */
  export type LetterCounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterCounter
     */
    select?: LetterCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterCounter
     */
    omit?: LetterCounterOmit<ExtArgs> | null
    /**
     * Filter, which LetterCounters to fetch.
     */
    where?: LetterCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LetterCounters to fetch.
     */
    orderBy?: LetterCounterOrderByWithRelationInput | LetterCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LetterCounters.
     */
    cursor?: LetterCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LetterCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LetterCounters.
     */
    skip?: number
    distinct?: LetterCounterScalarFieldEnum | LetterCounterScalarFieldEnum[]
  }

  /**
   * LetterCounter create
   */
  export type LetterCounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterCounter
     */
    select?: LetterCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterCounter
     */
    omit?: LetterCounterOmit<ExtArgs> | null
    /**
     * The data needed to create a LetterCounter.
     */
    data: XOR<LetterCounterCreateInput, LetterCounterUncheckedCreateInput>
  }

  /**
   * LetterCounter createMany
   */
  export type LetterCounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LetterCounters.
     */
    data: LetterCounterCreateManyInput | LetterCounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LetterCounter createManyAndReturn
   */
  export type LetterCounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterCounter
     */
    select?: LetterCounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LetterCounter
     */
    omit?: LetterCounterOmit<ExtArgs> | null
    /**
     * The data used to create many LetterCounters.
     */
    data: LetterCounterCreateManyInput | LetterCounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LetterCounter update
   */
  export type LetterCounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterCounter
     */
    select?: LetterCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterCounter
     */
    omit?: LetterCounterOmit<ExtArgs> | null
    /**
     * The data needed to update a LetterCounter.
     */
    data: XOR<LetterCounterUpdateInput, LetterCounterUncheckedUpdateInput>
    /**
     * Choose, which LetterCounter to update.
     */
    where: LetterCounterWhereUniqueInput
  }

  /**
   * LetterCounter updateMany
   */
  export type LetterCounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LetterCounters.
     */
    data: XOR<LetterCounterUpdateManyMutationInput, LetterCounterUncheckedUpdateManyInput>
    /**
     * Filter which LetterCounters to update
     */
    where?: LetterCounterWhereInput
    /**
     * Limit how many LetterCounters to update.
     */
    limit?: number
  }

  /**
   * LetterCounter updateManyAndReturn
   */
  export type LetterCounterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterCounter
     */
    select?: LetterCounterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LetterCounter
     */
    omit?: LetterCounterOmit<ExtArgs> | null
    /**
     * The data used to update LetterCounters.
     */
    data: XOR<LetterCounterUpdateManyMutationInput, LetterCounterUncheckedUpdateManyInput>
    /**
     * Filter which LetterCounters to update
     */
    where?: LetterCounterWhereInput
    /**
     * Limit how many LetterCounters to update.
     */
    limit?: number
  }

  /**
   * LetterCounter upsert
   */
  export type LetterCounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterCounter
     */
    select?: LetterCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterCounter
     */
    omit?: LetterCounterOmit<ExtArgs> | null
    /**
     * The filter to search for the LetterCounter to update in case it exists.
     */
    where: LetterCounterWhereUniqueInput
    /**
     * In case the LetterCounter found by the `where` argument doesn't exist, create a new LetterCounter with this data.
     */
    create: XOR<LetterCounterCreateInput, LetterCounterUncheckedCreateInput>
    /**
     * In case the LetterCounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LetterCounterUpdateInput, LetterCounterUncheckedUpdateInput>
  }

  /**
   * LetterCounter delete
   */
  export type LetterCounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterCounter
     */
    select?: LetterCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterCounter
     */
    omit?: LetterCounterOmit<ExtArgs> | null
    /**
     * Filter which LetterCounter to delete.
     */
    where: LetterCounterWhereUniqueInput
  }

  /**
   * LetterCounter deleteMany
   */
  export type LetterCounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LetterCounters to delete
     */
    where?: LetterCounterWhereInput
    /**
     * Limit how many LetterCounters to delete.
     */
    limit?: number
  }

  /**
   * LetterCounter without action
   */
  export type LetterCounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterCounter
     */
    select?: LetterCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterCounter
     */
    omit?: LetterCounterOmit<ExtArgs> | null
  }


  /**
   * Model LetterApplication
   */

  export type AggregateLetterApplication = {
    _count: LetterApplicationCountAggregateOutputType | null
    _avg: LetterApplicationAvgAggregateOutputType | null
    _sum: LetterApplicationSumAggregateOutputType | null
    _min: LetterApplicationMinAggregateOutputType | null
    _max: LetterApplicationMaxAggregateOutputType | null
  }

  export type LetterApplicationAvgAggregateOutputType = {
    nomorUrut: number | null
    perkiraanPeserta: number | null
  }

  export type LetterApplicationSumAggregateOutputType = {
    nomorUrut: number | null
    perkiraanPeserta: number | null
  }

  export type LetterApplicationMinAggregateOutputType = {
    id: string | null
    code: string | null
    type: $Enums.LetterType | null
    status: $Enums.LetterStatus | null
    statusFeedback: string | null
    nomorUrut: number | null
    nomorSurat: string | null
    nik: string | null
    hp: string | null
    alamat: string | null
    namaOrganisasi: string | null
    kecamatan: string | null
    penanggungJawab: string | null
    jenisKegiatan: string | null
    namaKegiatan: string | null
    lokasi: string | null
    tanggal: Date | null
    waktuMulai: string | null
    waktuSelesai: string | null
    perkiraanPeserta: number | null
    ktpPath: string | null
    rekomendasiDesaPath: string | null
    rekomDesaNama: string | null
    rekomDesaNomor: string | null
    nama: string | null
    tempatLahir: string | null
    tanggalLahir: Date | null
    jenisKelamin: string | null
    pekerjaan: string | null
    agama: string | null
    kehilanganApa: string | null
    kronologi: string | null
    tanggalLaporan: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LetterApplicationMaxAggregateOutputType = {
    id: string | null
    code: string | null
    type: $Enums.LetterType | null
    status: $Enums.LetterStatus | null
    statusFeedback: string | null
    nomorUrut: number | null
    nomorSurat: string | null
    nik: string | null
    hp: string | null
    alamat: string | null
    namaOrganisasi: string | null
    kecamatan: string | null
    penanggungJawab: string | null
    jenisKegiatan: string | null
    namaKegiatan: string | null
    lokasi: string | null
    tanggal: Date | null
    waktuMulai: string | null
    waktuSelesai: string | null
    perkiraanPeserta: number | null
    ktpPath: string | null
    rekomendasiDesaPath: string | null
    rekomDesaNama: string | null
    rekomDesaNomor: string | null
    nama: string | null
    tempatLahir: string | null
    tanggalLahir: Date | null
    jenisKelamin: string | null
    pekerjaan: string | null
    agama: string | null
    kehilanganApa: string | null
    kronologi: string | null
    tanggalLaporan: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LetterApplicationCountAggregateOutputType = {
    id: number
    code: number
    type: number
    status: number
    statusFeedback: number
    nomorUrut: number
    nomorSurat: number
    nik: number
    hp: number
    alamat: number
    namaOrganisasi: number
    kecamatan: number
    penanggungJawab: number
    jenisKegiatan: number
    namaKegiatan: number
    lokasi: number
    tanggal: number
    waktuMulai: number
    waktuSelesai: number
    perkiraanPeserta: number
    ktpPath: number
    rekomendasiDesaPath: number
    rekomDesaNama: number
    rekomDesaNomor: number
    nama: number
    tempatLahir: number
    tanggalLahir: number
    jenisKelamin: number
    pekerjaan: number
    agama: number
    kehilanganItems: number
    kehilanganApa: number
    kronologi: number
    tanggalLaporan: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LetterApplicationAvgAggregateInputType = {
    nomorUrut?: true
    perkiraanPeserta?: true
  }

  export type LetterApplicationSumAggregateInputType = {
    nomorUrut?: true
    perkiraanPeserta?: true
  }

  export type LetterApplicationMinAggregateInputType = {
    id?: true
    code?: true
    type?: true
    status?: true
    statusFeedback?: true
    nomorUrut?: true
    nomorSurat?: true
    nik?: true
    hp?: true
    alamat?: true
    namaOrganisasi?: true
    kecamatan?: true
    penanggungJawab?: true
    jenisKegiatan?: true
    namaKegiatan?: true
    lokasi?: true
    tanggal?: true
    waktuMulai?: true
    waktuSelesai?: true
    perkiraanPeserta?: true
    ktpPath?: true
    rekomendasiDesaPath?: true
    rekomDesaNama?: true
    rekomDesaNomor?: true
    nama?: true
    tempatLahir?: true
    tanggalLahir?: true
    jenisKelamin?: true
    pekerjaan?: true
    agama?: true
    kehilanganApa?: true
    kronologi?: true
    tanggalLaporan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LetterApplicationMaxAggregateInputType = {
    id?: true
    code?: true
    type?: true
    status?: true
    statusFeedback?: true
    nomorUrut?: true
    nomorSurat?: true
    nik?: true
    hp?: true
    alamat?: true
    namaOrganisasi?: true
    kecamatan?: true
    penanggungJawab?: true
    jenisKegiatan?: true
    namaKegiatan?: true
    lokasi?: true
    tanggal?: true
    waktuMulai?: true
    waktuSelesai?: true
    perkiraanPeserta?: true
    ktpPath?: true
    rekomendasiDesaPath?: true
    rekomDesaNama?: true
    rekomDesaNomor?: true
    nama?: true
    tempatLahir?: true
    tanggalLahir?: true
    jenisKelamin?: true
    pekerjaan?: true
    agama?: true
    kehilanganApa?: true
    kronologi?: true
    tanggalLaporan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LetterApplicationCountAggregateInputType = {
    id?: true
    code?: true
    type?: true
    status?: true
    statusFeedback?: true
    nomorUrut?: true
    nomorSurat?: true
    nik?: true
    hp?: true
    alamat?: true
    namaOrganisasi?: true
    kecamatan?: true
    penanggungJawab?: true
    jenisKegiatan?: true
    namaKegiatan?: true
    lokasi?: true
    tanggal?: true
    waktuMulai?: true
    waktuSelesai?: true
    perkiraanPeserta?: true
    ktpPath?: true
    rekomendasiDesaPath?: true
    rekomDesaNama?: true
    rekomDesaNomor?: true
    nama?: true
    tempatLahir?: true
    tanggalLahir?: true
    jenisKelamin?: true
    pekerjaan?: true
    agama?: true
    kehilanganItems?: true
    kehilanganApa?: true
    kronologi?: true
    tanggalLaporan?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LetterApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LetterApplication to aggregate.
     */
    where?: LetterApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LetterApplications to fetch.
     */
    orderBy?: LetterApplicationOrderByWithRelationInput | LetterApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LetterApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LetterApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LetterApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LetterApplications
    **/
    _count?: true | LetterApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LetterApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LetterApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LetterApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LetterApplicationMaxAggregateInputType
  }

  export type GetLetterApplicationAggregateType<T extends LetterApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateLetterApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLetterApplication[P]>
      : GetScalarType<T[P], AggregateLetterApplication[P]>
  }




  export type LetterApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LetterApplicationWhereInput
    orderBy?: LetterApplicationOrderByWithAggregationInput | LetterApplicationOrderByWithAggregationInput[]
    by: LetterApplicationScalarFieldEnum[] | LetterApplicationScalarFieldEnum
    having?: LetterApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LetterApplicationCountAggregateInputType | true
    _avg?: LetterApplicationAvgAggregateInputType
    _sum?: LetterApplicationSumAggregateInputType
    _min?: LetterApplicationMinAggregateInputType
    _max?: LetterApplicationMaxAggregateInputType
  }

  export type LetterApplicationGroupByOutputType = {
    id: string
    code: string
    type: $Enums.LetterType
    status: $Enums.LetterStatus
    statusFeedback: string | null
    nomorUrut: number | null
    nomorSurat: string | null
    nik: string
    hp: string
    alamat: string
    namaOrganisasi: string | null
    kecamatan: string | null
    penanggungJawab: string | null
    jenisKegiatan: string | null
    namaKegiatan: string | null
    lokasi: string | null
    tanggal: Date | null
    waktuMulai: string | null
    waktuSelesai: string | null
    perkiraanPeserta: number | null
    ktpPath: string | null
    rekomendasiDesaPath: string | null
    rekomDesaNama: string | null
    rekomDesaNomor: string | null
    nama: string | null
    tempatLahir: string | null
    tanggalLahir: Date | null
    jenisKelamin: string | null
    pekerjaan: string | null
    agama: string | null
    kehilanganItems: JsonValue | null
    kehilanganApa: string | null
    kronologi: string | null
    tanggalLaporan: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LetterApplicationCountAggregateOutputType | null
    _avg: LetterApplicationAvgAggregateOutputType | null
    _sum: LetterApplicationSumAggregateOutputType | null
    _min: LetterApplicationMinAggregateOutputType | null
    _max: LetterApplicationMaxAggregateOutputType | null
  }

  type GetLetterApplicationGroupByPayload<T extends LetterApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LetterApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LetterApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LetterApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], LetterApplicationGroupByOutputType[P]>
        }
      >
    >


  export type LetterApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    type?: boolean
    status?: boolean
    statusFeedback?: boolean
    nomorUrut?: boolean
    nomorSurat?: boolean
    nik?: boolean
    hp?: boolean
    alamat?: boolean
    namaOrganisasi?: boolean
    kecamatan?: boolean
    penanggungJawab?: boolean
    jenisKegiatan?: boolean
    namaKegiatan?: boolean
    lokasi?: boolean
    tanggal?: boolean
    waktuMulai?: boolean
    waktuSelesai?: boolean
    perkiraanPeserta?: boolean
    ktpPath?: boolean
    rekomendasiDesaPath?: boolean
    rekomDesaNama?: boolean
    rekomDesaNomor?: boolean
    nama?: boolean
    tempatLahir?: boolean
    tanggalLahir?: boolean
    jenisKelamin?: boolean
    pekerjaan?: boolean
    agama?: boolean
    kehilanganItems?: boolean
    kehilanganApa?: boolean
    kronologi?: boolean
    tanggalLaporan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["letterApplication"]>

  export type LetterApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    type?: boolean
    status?: boolean
    statusFeedback?: boolean
    nomorUrut?: boolean
    nomorSurat?: boolean
    nik?: boolean
    hp?: boolean
    alamat?: boolean
    namaOrganisasi?: boolean
    kecamatan?: boolean
    penanggungJawab?: boolean
    jenisKegiatan?: boolean
    namaKegiatan?: boolean
    lokasi?: boolean
    tanggal?: boolean
    waktuMulai?: boolean
    waktuSelesai?: boolean
    perkiraanPeserta?: boolean
    ktpPath?: boolean
    rekomendasiDesaPath?: boolean
    rekomDesaNama?: boolean
    rekomDesaNomor?: boolean
    nama?: boolean
    tempatLahir?: boolean
    tanggalLahir?: boolean
    jenisKelamin?: boolean
    pekerjaan?: boolean
    agama?: boolean
    kehilanganItems?: boolean
    kehilanganApa?: boolean
    kronologi?: boolean
    tanggalLaporan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["letterApplication"]>

  export type LetterApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    type?: boolean
    status?: boolean
    statusFeedback?: boolean
    nomorUrut?: boolean
    nomorSurat?: boolean
    nik?: boolean
    hp?: boolean
    alamat?: boolean
    namaOrganisasi?: boolean
    kecamatan?: boolean
    penanggungJawab?: boolean
    jenisKegiatan?: boolean
    namaKegiatan?: boolean
    lokasi?: boolean
    tanggal?: boolean
    waktuMulai?: boolean
    waktuSelesai?: boolean
    perkiraanPeserta?: boolean
    ktpPath?: boolean
    rekomendasiDesaPath?: boolean
    rekomDesaNama?: boolean
    rekomDesaNomor?: boolean
    nama?: boolean
    tempatLahir?: boolean
    tanggalLahir?: boolean
    jenisKelamin?: boolean
    pekerjaan?: boolean
    agama?: boolean
    kehilanganItems?: boolean
    kehilanganApa?: boolean
    kronologi?: boolean
    tanggalLaporan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["letterApplication"]>

  export type LetterApplicationSelectScalar = {
    id?: boolean
    code?: boolean
    type?: boolean
    status?: boolean
    statusFeedback?: boolean
    nomorUrut?: boolean
    nomorSurat?: boolean
    nik?: boolean
    hp?: boolean
    alamat?: boolean
    namaOrganisasi?: boolean
    kecamatan?: boolean
    penanggungJawab?: boolean
    jenisKegiatan?: boolean
    namaKegiatan?: boolean
    lokasi?: boolean
    tanggal?: boolean
    waktuMulai?: boolean
    waktuSelesai?: boolean
    perkiraanPeserta?: boolean
    ktpPath?: boolean
    rekomendasiDesaPath?: boolean
    rekomDesaNama?: boolean
    rekomDesaNomor?: boolean
    nama?: boolean
    tempatLahir?: boolean
    tanggalLahir?: boolean
    jenisKelamin?: boolean
    pekerjaan?: boolean
    agama?: boolean
    kehilanganItems?: boolean
    kehilanganApa?: boolean
    kronologi?: boolean
    tanggalLaporan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LetterApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "type" | "status" | "statusFeedback" | "nomorUrut" | "nomorSurat" | "nik" | "hp" | "alamat" | "namaOrganisasi" | "kecamatan" | "penanggungJawab" | "jenisKegiatan" | "namaKegiatan" | "lokasi" | "tanggal" | "waktuMulai" | "waktuSelesai" | "perkiraanPeserta" | "ktpPath" | "rekomendasiDesaPath" | "rekomDesaNama" | "rekomDesaNomor" | "nama" | "tempatLahir" | "tanggalLahir" | "jenisKelamin" | "pekerjaan" | "agama" | "kehilanganItems" | "kehilanganApa" | "kronologi" | "tanggalLaporan" | "createdAt" | "updatedAt", ExtArgs["result"]["letterApplication"]>

  export type $LetterApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LetterApplication"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      type: $Enums.LetterType
      status: $Enums.LetterStatus
      statusFeedback: string | null
      /**
       * *
       *    * ✅ BARU:
       *    * nomor urut dan nomor surat final STPLK (dibuat saat status SELESAI)
       */
      nomorUrut: number | null
      nomorSurat: string | null
      nik: string
      hp: string
      alamat: string
      namaOrganisasi: string | null
      kecamatan: string | null
      penanggungJawab: string | null
      jenisKegiatan: string | null
      namaKegiatan: string | null
      lokasi: string | null
      tanggal: Date | null
      waktuMulai: string | null
      waktuSelesai: string | null
      perkiraanPeserta: number | null
      ktpPath: string | null
      rekomendasiDesaPath: string | null
      rekomDesaNama: string | null
      rekomDesaNomor: string | null
      nama: string | null
      tempatLahir: string | null
      tanggalLahir: Date | null
      jenisKelamin: string | null
      pekerjaan: string | null
      agama: string | null
      kehilanganItems: Prisma.JsonValue | null
      kehilanganApa: string | null
      kronologi: string | null
      tanggalLaporan: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["letterApplication"]>
    composites: {}
  }

  type LetterApplicationGetPayload<S extends boolean | null | undefined | LetterApplicationDefaultArgs> = $Result.GetResult<Prisma.$LetterApplicationPayload, S>

  type LetterApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LetterApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LetterApplicationCountAggregateInputType | true
    }

  export interface LetterApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LetterApplication'], meta: { name: 'LetterApplication' } }
    /**
     * Find zero or one LetterApplication that matches the filter.
     * @param {LetterApplicationFindUniqueArgs} args - Arguments to find a LetterApplication
     * @example
     * // Get one LetterApplication
     * const letterApplication = await prisma.letterApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LetterApplicationFindUniqueArgs>(args: SelectSubset<T, LetterApplicationFindUniqueArgs<ExtArgs>>): Prisma__LetterApplicationClient<$Result.GetResult<Prisma.$LetterApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LetterApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LetterApplicationFindUniqueOrThrowArgs} args - Arguments to find a LetterApplication
     * @example
     * // Get one LetterApplication
     * const letterApplication = await prisma.letterApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LetterApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, LetterApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LetterApplicationClient<$Result.GetResult<Prisma.$LetterApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LetterApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterApplicationFindFirstArgs} args - Arguments to find a LetterApplication
     * @example
     * // Get one LetterApplication
     * const letterApplication = await prisma.letterApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LetterApplicationFindFirstArgs>(args?: SelectSubset<T, LetterApplicationFindFirstArgs<ExtArgs>>): Prisma__LetterApplicationClient<$Result.GetResult<Prisma.$LetterApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LetterApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterApplicationFindFirstOrThrowArgs} args - Arguments to find a LetterApplication
     * @example
     * // Get one LetterApplication
     * const letterApplication = await prisma.letterApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LetterApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, LetterApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LetterApplicationClient<$Result.GetResult<Prisma.$LetterApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LetterApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LetterApplications
     * const letterApplications = await prisma.letterApplication.findMany()
     * 
     * // Get first 10 LetterApplications
     * const letterApplications = await prisma.letterApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const letterApplicationWithIdOnly = await prisma.letterApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LetterApplicationFindManyArgs>(args?: SelectSubset<T, LetterApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LetterApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LetterApplication.
     * @param {LetterApplicationCreateArgs} args - Arguments to create a LetterApplication.
     * @example
     * // Create one LetterApplication
     * const LetterApplication = await prisma.letterApplication.create({
     *   data: {
     *     // ... data to create a LetterApplication
     *   }
     * })
     * 
     */
    create<T extends LetterApplicationCreateArgs>(args: SelectSubset<T, LetterApplicationCreateArgs<ExtArgs>>): Prisma__LetterApplicationClient<$Result.GetResult<Prisma.$LetterApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LetterApplications.
     * @param {LetterApplicationCreateManyArgs} args - Arguments to create many LetterApplications.
     * @example
     * // Create many LetterApplications
     * const letterApplication = await prisma.letterApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LetterApplicationCreateManyArgs>(args?: SelectSubset<T, LetterApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LetterApplications and returns the data saved in the database.
     * @param {LetterApplicationCreateManyAndReturnArgs} args - Arguments to create many LetterApplications.
     * @example
     * // Create many LetterApplications
     * const letterApplication = await prisma.letterApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LetterApplications and only return the `id`
     * const letterApplicationWithIdOnly = await prisma.letterApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LetterApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, LetterApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LetterApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LetterApplication.
     * @param {LetterApplicationDeleteArgs} args - Arguments to delete one LetterApplication.
     * @example
     * // Delete one LetterApplication
     * const LetterApplication = await prisma.letterApplication.delete({
     *   where: {
     *     // ... filter to delete one LetterApplication
     *   }
     * })
     * 
     */
    delete<T extends LetterApplicationDeleteArgs>(args: SelectSubset<T, LetterApplicationDeleteArgs<ExtArgs>>): Prisma__LetterApplicationClient<$Result.GetResult<Prisma.$LetterApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LetterApplication.
     * @param {LetterApplicationUpdateArgs} args - Arguments to update one LetterApplication.
     * @example
     * // Update one LetterApplication
     * const letterApplication = await prisma.letterApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LetterApplicationUpdateArgs>(args: SelectSubset<T, LetterApplicationUpdateArgs<ExtArgs>>): Prisma__LetterApplicationClient<$Result.GetResult<Prisma.$LetterApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LetterApplications.
     * @param {LetterApplicationDeleteManyArgs} args - Arguments to filter LetterApplications to delete.
     * @example
     * // Delete a few LetterApplications
     * const { count } = await prisma.letterApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LetterApplicationDeleteManyArgs>(args?: SelectSubset<T, LetterApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LetterApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LetterApplications
     * const letterApplication = await prisma.letterApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LetterApplicationUpdateManyArgs>(args: SelectSubset<T, LetterApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LetterApplications and returns the data updated in the database.
     * @param {LetterApplicationUpdateManyAndReturnArgs} args - Arguments to update many LetterApplications.
     * @example
     * // Update many LetterApplications
     * const letterApplication = await prisma.letterApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LetterApplications and only return the `id`
     * const letterApplicationWithIdOnly = await prisma.letterApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LetterApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, LetterApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LetterApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LetterApplication.
     * @param {LetterApplicationUpsertArgs} args - Arguments to update or create a LetterApplication.
     * @example
     * // Update or create a LetterApplication
     * const letterApplication = await prisma.letterApplication.upsert({
     *   create: {
     *     // ... data to create a LetterApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LetterApplication we want to update
     *   }
     * })
     */
    upsert<T extends LetterApplicationUpsertArgs>(args: SelectSubset<T, LetterApplicationUpsertArgs<ExtArgs>>): Prisma__LetterApplicationClient<$Result.GetResult<Prisma.$LetterApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LetterApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterApplicationCountArgs} args - Arguments to filter LetterApplications to count.
     * @example
     * // Count the number of LetterApplications
     * const count = await prisma.letterApplication.count({
     *   where: {
     *     // ... the filter for the LetterApplications we want to count
     *   }
     * })
    **/
    count<T extends LetterApplicationCountArgs>(
      args?: Subset<T, LetterApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LetterApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LetterApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LetterApplicationAggregateArgs>(args: Subset<T, LetterApplicationAggregateArgs>): Prisma.PrismaPromise<GetLetterApplicationAggregateType<T>>

    /**
     * Group by LetterApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LetterApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LetterApplicationGroupByArgs['orderBy'] }
        : { orderBy?: LetterApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LetterApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLetterApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LetterApplication model
   */
  readonly fields: LetterApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LetterApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LetterApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LetterApplication model
   */
  interface LetterApplicationFieldRefs {
    readonly id: FieldRef<"LetterApplication", 'String'>
    readonly code: FieldRef<"LetterApplication", 'String'>
    readonly type: FieldRef<"LetterApplication", 'LetterType'>
    readonly status: FieldRef<"LetterApplication", 'LetterStatus'>
    readonly statusFeedback: FieldRef<"LetterApplication", 'String'>
    readonly nomorUrut: FieldRef<"LetterApplication", 'Int'>
    readonly nomorSurat: FieldRef<"LetterApplication", 'String'>
    readonly nik: FieldRef<"LetterApplication", 'String'>
    readonly hp: FieldRef<"LetterApplication", 'String'>
    readonly alamat: FieldRef<"LetterApplication", 'String'>
    readonly namaOrganisasi: FieldRef<"LetterApplication", 'String'>
    readonly kecamatan: FieldRef<"LetterApplication", 'String'>
    readonly penanggungJawab: FieldRef<"LetterApplication", 'String'>
    readonly jenisKegiatan: FieldRef<"LetterApplication", 'String'>
    readonly namaKegiatan: FieldRef<"LetterApplication", 'String'>
    readonly lokasi: FieldRef<"LetterApplication", 'String'>
    readonly tanggal: FieldRef<"LetterApplication", 'DateTime'>
    readonly waktuMulai: FieldRef<"LetterApplication", 'String'>
    readonly waktuSelesai: FieldRef<"LetterApplication", 'String'>
    readonly perkiraanPeserta: FieldRef<"LetterApplication", 'Int'>
    readonly ktpPath: FieldRef<"LetterApplication", 'String'>
    readonly rekomendasiDesaPath: FieldRef<"LetterApplication", 'String'>
    readonly rekomDesaNama: FieldRef<"LetterApplication", 'String'>
    readonly rekomDesaNomor: FieldRef<"LetterApplication", 'String'>
    readonly nama: FieldRef<"LetterApplication", 'String'>
    readonly tempatLahir: FieldRef<"LetterApplication", 'String'>
    readonly tanggalLahir: FieldRef<"LetterApplication", 'DateTime'>
    readonly jenisKelamin: FieldRef<"LetterApplication", 'String'>
    readonly pekerjaan: FieldRef<"LetterApplication", 'String'>
    readonly agama: FieldRef<"LetterApplication", 'String'>
    readonly kehilanganItems: FieldRef<"LetterApplication", 'Json'>
    readonly kehilanganApa: FieldRef<"LetterApplication", 'String'>
    readonly kronologi: FieldRef<"LetterApplication", 'String'>
    readonly tanggalLaporan: FieldRef<"LetterApplication", 'DateTime'>
    readonly createdAt: FieldRef<"LetterApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"LetterApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LetterApplication findUnique
   */
  export type LetterApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterApplication
     */
    select?: LetterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterApplication
     */
    omit?: LetterApplicationOmit<ExtArgs> | null
    /**
     * Filter, which LetterApplication to fetch.
     */
    where: LetterApplicationWhereUniqueInput
  }

  /**
   * LetterApplication findUniqueOrThrow
   */
  export type LetterApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterApplication
     */
    select?: LetterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterApplication
     */
    omit?: LetterApplicationOmit<ExtArgs> | null
    /**
     * Filter, which LetterApplication to fetch.
     */
    where: LetterApplicationWhereUniqueInput
  }

  /**
   * LetterApplication findFirst
   */
  export type LetterApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterApplication
     */
    select?: LetterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterApplication
     */
    omit?: LetterApplicationOmit<ExtArgs> | null
    /**
     * Filter, which LetterApplication to fetch.
     */
    where?: LetterApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LetterApplications to fetch.
     */
    orderBy?: LetterApplicationOrderByWithRelationInput | LetterApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LetterApplications.
     */
    cursor?: LetterApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LetterApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LetterApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LetterApplications.
     */
    distinct?: LetterApplicationScalarFieldEnum | LetterApplicationScalarFieldEnum[]
  }

  /**
   * LetterApplication findFirstOrThrow
   */
  export type LetterApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterApplication
     */
    select?: LetterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterApplication
     */
    omit?: LetterApplicationOmit<ExtArgs> | null
    /**
     * Filter, which LetterApplication to fetch.
     */
    where?: LetterApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LetterApplications to fetch.
     */
    orderBy?: LetterApplicationOrderByWithRelationInput | LetterApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LetterApplications.
     */
    cursor?: LetterApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LetterApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LetterApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LetterApplications.
     */
    distinct?: LetterApplicationScalarFieldEnum | LetterApplicationScalarFieldEnum[]
  }

  /**
   * LetterApplication findMany
   */
  export type LetterApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterApplication
     */
    select?: LetterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterApplication
     */
    omit?: LetterApplicationOmit<ExtArgs> | null
    /**
     * Filter, which LetterApplications to fetch.
     */
    where?: LetterApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LetterApplications to fetch.
     */
    orderBy?: LetterApplicationOrderByWithRelationInput | LetterApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LetterApplications.
     */
    cursor?: LetterApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LetterApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LetterApplications.
     */
    skip?: number
    distinct?: LetterApplicationScalarFieldEnum | LetterApplicationScalarFieldEnum[]
  }

  /**
   * LetterApplication create
   */
  export type LetterApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterApplication
     */
    select?: LetterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterApplication
     */
    omit?: LetterApplicationOmit<ExtArgs> | null
    /**
     * The data needed to create a LetterApplication.
     */
    data: XOR<LetterApplicationCreateInput, LetterApplicationUncheckedCreateInput>
  }

  /**
   * LetterApplication createMany
   */
  export type LetterApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LetterApplications.
     */
    data: LetterApplicationCreateManyInput | LetterApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LetterApplication createManyAndReturn
   */
  export type LetterApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterApplication
     */
    select?: LetterApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LetterApplication
     */
    omit?: LetterApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many LetterApplications.
     */
    data: LetterApplicationCreateManyInput | LetterApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LetterApplication update
   */
  export type LetterApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterApplication
     */
    select?: LetterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterApplication
     */
    omit?: LetterApplicationOmit<ExtArgs> | null
    /**
     * The data needed to update a LetterApplication.
     */
    data: XOR<LetterApplicationUpdateInput, LetterApplicationUncheckedUpdateInput>
    /**
     * Choose, which LetterApplication to update.
     */
    where: LetterApplicationWhereUniqueInput
  }

  /**
   * LetterApplication updateMany
   */
  export type LetterApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LetterApplications.
     */
    data: XOR<LetterApplicationUpdateManyMutationInput, LetterApplicationUncheckedUpdateManyInput>
    /**
     * Filter which LetterApplications to update
     */
    where?: LetterApplicationWhereInput
    /**
     * Limit how many LetterApplications to update.
     */
    limit?: number
  }

  /**
   * LetterApplication updateManyAndReturn
   */
  export type LetterApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterApplication
     */
    select?: LetterApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LetterApplication
     */
    omit?: LetterApplicationOmit<ExtArgs> | null
    /**
     * The data used to update LetterApplications.
     */
    data: XOR<LetterApplicationUpdateManyMutationInput, LetterApplicationUncheckedUpdateManyInput>
    /**
     * Filter which LetterApplications to update
     */
    where?: LetterApplicationWhereInput
    /**
     * Limit how many LetterApplications to update.
     */
    limit?: number
  }

  /**
   * LetterApplication upsert
   */
  export type LetterApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterApplication
     */
    select?: LetterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterApplication
     */
    omit?: LetterApplicationOmit<ExtArgs> | null
    /**
     * The filter to search for the LetterApplication to update in case it exists.
     */
    where: LetterApplicationWhereUniqueInput
    /**
     * In case the LetterApplication found by the `where` argument doesn't exist, create a new LetterApplication with this data.
     */
    create: XOR<LetterApplicationCreateInput, LetterApplicationUncheckedCreateInput>
    /**
     * In case the LetterApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LetterApplicationUpdateInput, LetterApplicationUncheckedUpdateInput>
  }

  /**
   * LetterApplication delete
   */
  export type LetterApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterApplication
     */
    select?: LetterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterApplication
     */
    omit?: LetterApplicationOmit<ExtArgs> | null
    /**
     * Filter which LetterApplication to delete.
     */
    where: LetterApplicationWhereUniqueInput
  }

  /**
   * LetterApplication deleteMany
   */
  export type LetterApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LetterApplications to delete
     */
    where?: LetterApplicationWhereInput
    /**
     * Limit how many LetterApplications to delete.
     */
    limit?: number
  }

  /**
   * LetterApplication without action
   */
  export type LetterApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LetterApplication
     */
    select?: LetterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LetterApplication
     */
    omit?: LetterApplicationOmit<ExtArgs> | null
  }


  /**
   * Model OnlineReport
   */

  export type AggregateOnlineReport = {
    _count: OnlineReportCountAggregateOutputType | null
    _min: OnlineReportMinAggregateOutputType | null
    _max: OnlineReportMaxAggregateOutputType | null
  }

  export type OnlineReportMinAggregateOutputType = {
    id: string | null
    code: string | null
    status: $Enums.OnlineReportStatus | null
    statusFeedback: string | null
    nama: string | null
    nik: string | null
    hp: string | null
    kecamatan: string | null
    jenis: string | null
    lokasi: string | null
    tanggal: Date | null
    jam: string | null
    kronologi: string | null
    lampiranPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OnlineReportMaxAggregateOutputType = {
    id: string | null
    code: string | null
    status: $Enums.OnlineReportStatus | null
    statusFeedback: string | null
    nama: string | null
    nik: string | null
    hp: string | null
    kecamatan: string | null
    jenis: string | null
    lokasi: string | null
    tanggal: Date | null
    jam: string | null
    kronologi: string | null
    lampiranPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OnlineReportCountAggregateOutputType = {
    id: number
    code: number
    status: number
    statusFeedback: number
    nama: number
    nik: number
    hp: number
    kecamatan: number
    jenis: number
    lokasi: number
    tanggal: number
    jam: number
    kronologi: number
    lampiranPath: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OnlineReportMinAggregateInputType = {
    id?: true
    code?: true
    status?: true
    statusFeedback?: true
    nama?: true
    nik?: true
    hp?: true
    kecamatan?: true
    jenis?: true
    lokasi?: true
    tanggal?: true
    jam?: true
    kronologi?: true
    lampiranPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OnlineReportMaxAggregateInputType = {
    id?: true
    code?: true
    status?: true
    statusFeedback?: true
    nama?: true
    nik?: true
    hp?: true
    kecamatan?: true
    jenis?: true
    lokasi?: true
    tanggal?: true
    jam?: true
    kronologi?: true
    lampiranPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OnlineReportCountAggregateInputType = {
    id?: true
    code?: true
    status?: true
    statusFeedback?: true
    nama?: true
    nik?: true
    hp?: true
    kecamatan?: true
    jenis?: true
    lokasi?: true
    tanggal?: true
    jam?: true
    kronologi?: true
    lampiranPath?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OnlineReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnlineReport to aggregate.
     */
    where?: OnlineReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnlineReports to fetch.
     */
    orderBy?: OnlineReportOrderByWithRelationInput | OnlineReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OnlineReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnlineReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnlineReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OnlineReports
    **/
    _count?: true | OnlineReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OnlineReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OnlineReportMaxAggregateInputType
  }

  export type GetOnlineReportAggregateType<T extends OnlineReportAggregateArgs> = {
        [P in keyof T & keyof AggregateOnlineReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnlineReport[P]>
      : GetScalarType<T[P], AggregateOnlineReport[P]>
  }




  export type OnlineReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnlineReportWhereInput
    orderBy?: OnlineReportOrderByWithAggregationInput | OnlineReportOrderByWithAggregationInput[]
    by: OnlineReportScalarFieldEnum[] | OnlineReportScalarFieldEnum
    having?: OnlineReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OnlineReportCountAggregateInputType | true
    _min?: OnlineReportMinAggregateInputType
    _max?: OnlineReportMaxAggregateInputType
  }

  export type OnlineReportGroupByOutputType = {
    id: string
    code: string
    status: $Enums.OnlineReportStatus
    statusFeedback: string | null
    nama: string
    nik: string
    hp: string
    kecamatan: string | null
    jenis: string
    lokasi: string
    tanggal: Date
    jam: string
    kronologi: string
    lampiranPath: string | null
    createdAt: Date
    updatedAt: Date
    _count: OnlineReportCountAggregateOutputType | null
    _min: OnlineReportMinAggregateOutputType | null
    _max: OnlineReportMaxAggregateOutputType | null
  }

  type GetOnlineReportGroupByPayload<T extends OnlineReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OnlineReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OnlineReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnlineReportGroupByOutputType[P]>
            : GetScalarType<T[P], OnlineReportGroupByOutputType[P]>
        }
      >
    >


  export type OnlineReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    status?: boolean
    statusFeedback?: boolean
    nama?: boolean
    nik?: boolean
    hp?: boolean
    kecamatan?: boolean
    jenis?: boolean
    lokasi?: boolean
    tanggal?: boolean
    jam?: boolean
    kronologi?: boolean
    lampiranPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["onlineReport"]>

  export type OnlineReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    status?: boolean
    statusFeedback?: boolean
    nama?: boolean
    nik?: boolean
    hp?: boolean
    kecamatan?: boolean
    jenis?: boolean
    lokasi?: boolean
    tanggal?: boolean
    jam?: boolean
    kronologi?: boolean
    lampiranPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["onlineReport"]>

  export type OnlineReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    status?: boolean
    statusFeedback?: boolean
    nama?: boolean
    nik?: boolean
    hp?: boolean
    kecamatan?: boolean
    jenis?: boolean
    lokasi?: boolean
    tanggal?: boolean
    jam?: boolean
    kronologi?: boolean
    lampiranPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["onlineReport"]>

  export type OnlineReportSelectScalar = {
    id?: boolean
    code?: boolean
    status?: boolean
    statusFeedback?: boolean
    nama?: boolean
    nik?: boolean
    hp?: boolean
    kecamatan?: boolean
    jenis?: boolean
    lokasi?: boolean
    tanggal?: boolean
    jam?: boolean
    kronologi?: boolean
    lampiranPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OnlineReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "status" | "statusFeedback" | "nama" | "nik" | "hp" | "kecamatan" | "jenis" | "lokasi" | "tanggal" | "jam" | "kronologi" | "lampiranPath" | "createdAt" | "updatedAt", ExtArgs["result"]["onlineReport"]>

  export type $OnlineReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OnlineReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      status: $Enums.OnlineReportStatus
      statusFeedback: string | null
      nama: string
      nik: string
      hp: string
      kecamatan: string | null
      jenis: string
      lokasi: string
      tanggal: Date
      jam: string
      kronologi: string
      lampiranPath: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["onlineReport"]>
    composites: {}
  }

  type OnlineReportGetPayload<S extends boolean | null | undefined | OnlineReportDefaultArgs> = $Result.GetResult<Prisma.$OnlineReportPayload, S>

  type OnlineReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OnlineReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OnlineReportCountAggregateInputType | true
    }

  export interface OnlineReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OnlineReport'], meta: { name: 'OnlineReport' } }
    /**
     * Find zero or one OnlineReport that matches the filter.
     * @param {OnlineReportFindUniqueArgs} args - Arguments to find a OnlineReport
     * @example
     * // Get one OnlineReport
     * const onlineReport = await prisma.onlineReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OnlineReportFindUniqueArgs>(args: SelectSubset<T, OnlineReportFindUniqueArgs<ExtArgs>>): Prisma__OnlineReportClient<$Result.GetResult<Prisma.$OnlineReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OnlineReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OnlineReportFindUniqueOrThrowArgs} args - Arguments to find a OnlineReport
     * @example
     * // Get one OnlineReport
     * const onlineReport = await prisma.onlineReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OnlineReportFindUniqueOrThrowArgs>(args: SelectSubset<T, OnlineReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OnlineReportClient<$Result.GetResult<Prisma.$OnlineReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnlineReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineReportFindFirstArgs} args - Arguments to find a OnlineReport
     * @example
     * // Get one OnlineReport
     * const onlineReport = await prisma.onlineReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OnlineReportFindFirstArgs>(args?: SelectSubset<T, OnlineReportFindFirstArgs<ExtArgs>>): Prisma__OnlineReportClient<$Result.GetResult<Prisma.$OnlineReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnlineReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineReportFindFirstOrThrowArgs} args - Arguments to find a OnlineReport
     * @example
     * // Get one OnlineReport
     * const onlineReport = await prisma.onlineReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OnlineReportFindFirstOrThrowArgs>(args?: SelectSubset<T, OnlineReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__OnlineReportClient<$Result.GetResult<Prisma.$OnlineReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OnlineReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OnlineReports
     * const onlineReports = await prisma.onlineReport.findMany()
     * 
     * // Get first 10 OnlineReports
     * const onlineReports = await prisma.onlineReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const onlineReportWithIdOnly = await prisma.onlineReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OnlineReportFindManyArgs>(args?: SelectSubset<T, OnlineReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnlineReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OnlineReport.
     * @param {OnlineReportCreateArgs} args - Arguments to create a OnlineReport.
     * @example
     * // Create one OnlineReport
     * const OnlineReport = await prisma.onlineReport.create({
     *   data: {
     *     // ... data to create a OnlineReport
     *   }
     * })
     * 
     */
    create<T extends OnlineReportCreateArgs>(args: SelectSubset<T, OnlineReportCreateArgs<ExtArgs>>): Prisma__OnlineReportClient<$Result.GetResult<Prisma.$OnlineReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OnlineReports.
     * @param {OnlineReportCreateManyArgs} args - Arguments to create many OnlineReports.
     * @example
     * // Create many OnlineReports
     * const onlineReport = await prisma.onlineReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OnlineReportCreateManyArgs>(args?: SelectSubset<T, OnlineReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OnlineReports and returns the data saved in the database.
     * @param {OnlineReportCreateManyAndReturnArgs} args - Arguments to create many OnlineReports.
     * @example
     * // Create many OnlineReports
     * const onlineReport = await prisma.onlineReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OnlineReports and only return the `id`
     * const onlineReportWithIdOnly = await prisma.onlineReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OnlineReportCreateManyAndReturnArgs>(args?: SelectSubset<T, OnlineReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnlineReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OnlineReport.
     * @param {OnlineReportDeleteArgs} args - Arguments to delete one OnlineReport.
     * @example
     * // Delete one OnlineReport
     * const OnlineReport = await prisma.onlineReport.delete({
     *   where: {
     *     // ... filter to delete one OnlineReport
     *   }
     * })
     * 
     */
    delete<T extends OnlineReportDeleteArgs>(args: SelectSubset<T, OnlineReportDeleteArgs<ExtArgs>>): Prisma__OnlineReportClient<$Result.GetResult<Prisma.$OnlineReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OnlineReport.
     * @param {OnlineReportUpdateArgs} args - Arguments to update one OnlineReport.
     * @example
     * // Update one OnlineReport
     * const onlineReport = await prisma.onlineReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OnlineReportUpdateArgs>(args: SelectSubset<T, OnlineReportUpdateArgs<ExtArgs>>): Prisma__OnlineReportClient<$Result.GetResult<Prisma.$OnlineReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OnlineReports.
     * @param {OnlineReportDeleteManyArgs} args - Arguments to filter OnlineReports to delete.
     * @example
     * // Delete a few OnlineReports
     * const { count } = await prisma.onlineReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OnlineReportDeleteManyArgs>(args?: SelectSubset<T, OnlineReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnlineReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OnlineReports
     * const onlineReport = await prisma.onlineReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OnlineReportUpdateManyArgs>(args: SelectSubset<T, OnlineReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnlineReports and returns the data updated in the database.
     * @param {OnlineReportUpdateManyAndReturnArgs} args - Arguments to update many OnlineReports.
     * @example
     * // Update many OnlineReports
     * const onlineReport = await prisma.onlineReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OnlineReports and only return the `id`
     * const onlineReportWithIdOnly = await prisma.onlineReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OnlineReportUpdateManyAndReturnArgs>(args: SelectSubset<T, OnlineReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnlineReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OnlineReport.
     * @param {OnlineReportUpsertArgs} args - Arguments to update or create a OnlineReport.
     * @example
     * // Update or create a OnlineReport
     * const onlineReport = await prisma.onlineReport.upsert({
     *   create: {
     *     // ... data to create a OnlineReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OnlineReport we want to update
     *   }
     * })
     */
    upsert<T extends OnlineReportUpsertArgs>(args: SelectSubset<T, OnlineReportUpsertArgs<ExtArgs>>): Prisma__OnlineReportClient<$Result.GetResult<Prisma.$OnlineReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OnlineReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineReportCountArgs} args - Arguments to filter OnlineReports to count.
     * @example
     * // Count the number of OnlineReports
     * const count = await prisma.onlineReport.count({
     *   where: {
     *     // ... the filter for the OnlineReports we want to count
     *   }
     * })
    **/
    count<T extends OnlineReportCountArgs>(
      args?: Subset<T, OnlineReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OnlineReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OnlineReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OnlineReportAggregateArgs>(args: Subset<T, OnlineReportAggregateArgs>): Prisma.PrismaPromise<GetOnlineReportAggregateType<T>>

    /**
     * Group by OnlineReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OnlineReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnlineReportGroupByArgs['orderBy'] }
        : { orderBy?: OnlineReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OnlineReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOnlineReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OnlineReport model
   */
  readonly fields: OnlineReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OnlineReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OnlineReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OnlineReport model
   */
  interface OnlineReportFieldRefs {
    readonly id: FieldRef<"OnlineReport", 'String'>
    readonly code: FieldRef<"OnlineReport", 'String'>
    readonly status: FieldRef<"OnlineReport", 'OnlineReportStatus'>
    readonly statusFeedback: FieldRef<"OnlineReport", 'String'>
    readonly nama: FieldRef<"OnlineReport", 'String'>
    readonly nik: FieldRef<"OnlineReport", 'String'>
    readonly hp: FieldRef<"OnlineReport", 'String'>
    readonly kecamatan: FieldRef<"OnlineReport", 'String'>
    readonly jenis: FieldRef<"OnlineReport", 'String'>
    readonly lokasi: FieldRef<"OnlineReport", 'String'>
    readonly tanggal: FieldRef<"OnlineReport", 'DateTime'>
    readonly jam: FieldRef<"OnlineReport", 'String'>
    readonly kronologi: FieldRef<"OnlineReport", 'String'>
    readonly lampiranPath: FieldRef<"OnlineReport", 'String'>
    readonly createdAt: FieldRef<"OnlineReport", 'DateTime'>
    readonly updatedAt: FieldRef<"OnlineReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OnlineReport findUnique
   */
  export type OnlineReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineReport
     */
    select?: OnlineReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineReport
     */
    omit?: OnlineReportOmit<ExtArgs> | null
    /**
     * Filter, which OnlineReport to fetch.
     */
    where: OnlineReportWhereUniqueInput
  }

  /**
   * OnlineReport findUniqueOrThrow
   */
  export type OnlineReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineReport
     */
    select?: OnlineReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineReport
     */
    omit?: OnlineReportOmit<ExtArgs> | null
    /**
     * Filter, which OnlineReport to fetch.
     */
    where: OnlineReportWhereUniqueInput
  }

  /**
   * OnlineReport findFirst
   */
  export type OnlineReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineReport
     */
    select?: OnlineReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineReport
     */
    omit?: OnlineReportOmit<ExtArgs> | null
    /**
     * Filter, which OnlineReport to fetch.
     */
    where?: OnlineReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnlineReports to fetch.
     */
    orderBy?: OnlineReportOrderByWithRelationInput | OnlineReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnlineReports.
     */
    cursor?: OnlineReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnlineReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnlineReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnlineReports.
     */
    distinct?: OnlineReportScalarFieldEnum | OnlineReportScalarFieldEnum[]
  }

  /**
   * OnlineReport findFirstOrThrow
   */
  export type OnlineReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineReport
     */
    select?: OnlineReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineReport
     */
    omit?: OnlineReportOmit<ExtArgs> | null
    /**
     * Filter, which OnlineReport to fetch.
     */
    where?: OnlineReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnlineReports to fetch.
     */
    orderBy?: OnlineReportOrderByWithRelationInput | OnlineReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnlineReports.
     */
    cursor?: OnlineReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnlineReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnlineReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnlineReports.
     */
    distinct?: OnlineReportScalarFieldEnum | OnlineReportScalarFieldEnum[]
  }

  /**
   * OnlineReport findMany
   */
  export type OnlineReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineReport
     */
    select?: OnlineReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineReport
     */
    omit?: OnlineReportOmit<ExtArgs> | null
    /**
     * Filter, which OnlineReports to fetch.
     */
    where?: OnlineReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnlineReports to fetch.
     */
    orderBy?: OnlineReportOrderByWithRelationInput | OnlineReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OnlineReports.
     */
    cursor?: OnlineReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnlineReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnlineReports.
     */
    skip?: number
    distinct?: OnlineReportScalarFieldEnum | OnlineReportScalarFieldEnum[]
  }

  /**
   * OnlineReport create
   */
  export type OnlineReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineReport
     */
    select?: OnlineReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineReport
     */
    omit?: OnlineReportOmit<ExtArgs> | null
    /**
     * The data needed to create a OnlineReport.
     */
    data: XOR<OnlineReportCreateInput, OnlineReportUncheckedCreateInput>
  }

  /**
   * OnlineReport createMany
   */
  export type OnlineReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OnlineReports.
     */
    data: OnlineReportCreateManyInput | OnlineReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnlineReport createManyAndReturn
   */
  export type OnlineReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineReport
     */
    select?: OnlineReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineReport
     */
    omit?: OnlineReportOmit<ExtArgs> | null
    /**
     * The data used to create many OnlineReports.
     */
    data: OnlineReportCreateManyInput | OnlineReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnlineReport update
   */
  export type OnlineReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineReport
     */
    select?: OnlineReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineReport
     */
    omit?: OnlineReportOmit<ExtArgs> | null
    /**
     * The data needed to update a OnlineReport.
     */
    data: XOR<OnlineReportUpdateInput, OnlineReportUncheckedUpdateInput>
    /**
     * Choose, which OnlineReport to update.
     */
    where: OnlineReportWhereUniqueInput
  }

  /**
   * OnlineReport updateMany
   */
  export type OnlineReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OnlineReports.
     */
    data: XOR<OnlineReportUpdateManyMutationInput, OnlineReportUncheckedUpdateManyInput>
    /**
     * Filter which OnlineReports to update
     */
    where?: OnlineReportWhereInput
    /**
     * Limit how many OnlineReports to update.
     */
    limit?: number
  }

  /**
   * OnlineReport updateManyAndReturn
   */
  export type OnlineReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineReport
     */
    select?: OnlineReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineReport
     */
    omit?: OnlineReportOmit<ExtArgs> | null
    /**
     * The data used to update OnlineReports.
     */
    data: XOR<OnlineReportUpdateManyMutationInput, OnlineReportUncheckedUpdateManyInput>
    /**
     * Filter which OnlineReports to update
     */
    where?: OnlineReportWhereInput
    /**
     * Limit how many OnlineReports to update.
     */
    limit?: number
  }

  /**
   * OnlineReport upsert
   */
  export type OnlineReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineReport
     */
    select?: OnlineReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineReport
     */
    omit?: OnlineReportOmit<ExtArgs> | null
    /**
     * The filter to search for the OnlineReport to update in case it exists.
     */
    where: OnlineReportWhereUniqueInput
    /**
     * In case the OnlineReport found by the `where` argument doesn't exist, create a new OnlineReport with this data.
     */
    create: XOR<OnlineReportCreateInput, OnlineReportUncheckedCreateInput>
    /**
     * In case the OnlineReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnlineReportUpdateInput, OnlineReportUncheckedUpdateInput>
  }

  /**
   * OnlineReport delete
   */
  export type OnlineReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineReport
     */
    select?: OnlineReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineReport
     */
    omit?: OnlineReportOmit<ExtArgs> | null
    /**
     * Filter which OnlineReport to delete.
     */
    where: OnlineReportWhereUniqueInput
  }

  /**
   * OnlineReport deleteMany
   */
  export type OnlineReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnlineReports to delete
     */
    where?: OnlineReportWhereInput
    /**
     * Limit how many OnlineReports to delete.
     */
    limit?: number
  }

  /**
   * OnlineReport without action
   */
  export type OnlineReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineReport
     */
    select?: OnlineReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineReport
     */
    omit?: OnlineReportOmit<ExtArgs> | null
  }


  /**
   * Model SuratRekap
   */

  export type AggregateSuratRekap = {
    _count: SuratRekapCountAggregateOutputType | null
    _avg: SuratRekapAvgAggregateOutputType | null
    _sum: SuratRekapSumAggregateOutputType | null
    _min: SuratRekapMinAggregateOutputType | null
    _max: SuratRekapMaxAggregateOutputType | null
  }

  export type SuratRekapAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type SuratRekapSumAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type SuratRekapMinAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    noSurat: string | null
    kepada: string | null
    perihal: string | null
    disposisiKa: string | null
    paraf: string | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuratRekapMaxAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    noSurat: string | null
    kepada: string | null
    perihal: string | null
    disposisiKa: string | null
    paraf: string | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuratRekapCountAggregateOutputType = {
    id: number
    tanggal: number
    noSurat: number
    kepada: number
    perihal: number
    disposisiKa: number
    paraf: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SuratRekapAvgAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type SuratRekapSumAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type SuratRekapMinAggregateInputType = {
    id?: true
    tanggal?: true
    noSurat?: true
    kepada?: true
    perihal?: true
    disposisiKa?: true
    paraf?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuratRekapMaxAggregateInputType = {
    id?: true
    tanggal?: true
    noSurat?: true
    kepada?: true
    perihal?: true
    disposisiKa?: true
    paraf?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuratRekapCountAggregateInputType = {
    id?: true
    tanggal?: true
    noSurat?: true
    kepada?: true
    perihal?: true
    disposisiKa?: true
    paraf?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SuratRekapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuratRekap to aggregate.
     */
    where?: SuratRekapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuratRekaps to fetch.
     */
    orderBy?: SuratRekapOrderByWithRelationInput | SuratRekapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuratRekapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuratRekaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuratRekaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuratRekaps
    **/
    _count?: true | SuratRekapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuratRekapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuratRekapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuratRekapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuratRekapMaxAggregateInputType
  }

  export type GetSuratRekapAggregateType<T extends SuratRekapAggregateArgs> = {
        [P in keyof T & keyof AggregateSuratRekap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuratRekap[P]>
      : GetScalarType<T[P], AggregateSuratRekap[P]>
  }




  export type SuratRekapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuratRekapWhereInput
    orderBy?: SuratRekapOrderByWithAggregationInput | SuratRekapOrderByWithAggregationInput[]
    by: SuratRekapScalarFieldEnum[] | SuratRekapScalarFieldEnum
    having?: SuratRekapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuratRekapCountAggregateInputType | true
    _avg?: SuratRekapAvgAggregateInputType
    _sum?: SuratRekapSumAggregateInputType
    _min?: SuratRekapMinAggregateInputType
    _max?: SuratRekapMaxAggregateInputType
  }

  export type SuratRekapGroupByOutputType = {
    id: number
    tanggal: Date
    noSurat: string
    kepada: string
    perihal: string
    disposisiKa: string | null
    paraf: string | null
    createdById: number | null
    createdAt: Date
    updatedAt: Date
    _count: SuratRekapCountAggregateOutputType | null
    _avg: SuratRekapAvgAggregateOutputType | null
    _sum: SuratRekapSumAggregateOutputType | null
    _min: SuratRekapMinAggregateOutputType | null
    _max: SuratRekapMaxAggregateOutputType | null
  }

  type GetSuratRekapGroupByPayload<T extends SuratRekapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuratRekapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuratRekapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuratRekapGroupByOutputType[P]>
            : GetScalarType<T[P], SuratRekapGroupByOutputType[P]>
        }
      >
    >


  export type SuratRekapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal?: boolean
    noSurat?: boolean
    kepada?: boolean
    perihal?: boolean
    disposisiKa?: boolean
    paraf?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | SuratRekap$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["suratRekap"]>

  export type SuratRekapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal?: boolean
    noSurat?: boolean
    kepada?: boolean
    perihal?: boolean
    disposisiKa?: boolean
    paraf?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | SuratRekap$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["suratRekap"]>

  export type SuratRekapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal?: boolean
    noSurat?: boolean
    kepada?: boolean
    perihal?: boolean
    disposisiKa?: boolean
    paraf?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | SuratRekap$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["suratRekap"]>

  export type SuratRekapSelectScalar = {
    id?: boolean
    tanggal?: boolean
    noSurat?: boolean
    kepada?: boolean
    perihal?: boolean
    disposisiKa?: boolean
    paraf?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SuratRekapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tanggal" | "noSurat" | "kepada" | "perihal" | "disposisiKa" | "paraf" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["suratRekap"]>
  export type SuratRekapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | SuratRekap$createdByArgs<ExtArgs>
  }
  export type SuratRekapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | SuratRekap$createdByArgs<ExtArgs>
  }
  export type SuratRekapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | SuratRekap$createdByArgs<ExtArgs>
  }

  export type $SuratRekapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuratRekap"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tanggal: Date
      noSurat: string
      kepada: string
      perihal: string
      disposisiKa: string | null
      paraf: string | null
      createdById: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["suratRekap"]>
    composites: {}
  }

  type SuratRekapGetPayload<S extends boolean | null | undefined | SuratRekapDefaultArgs> = $Result.GetResult<Prisma.$SuratRekapPayload, S>

  type SuratRekapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuratRekapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuratRekapCountAggregateInputType | true
    }

  export interface SuratRekapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuratRekap'], meta: { name: 'SuratRekap' } }
    /**
     * Find zero or one SuratRekap that matches the filter.
     * @param {SuratRekapFindUniqueArgs} args - Arguments to find a SuratRekap
     * @example
     * // Get one SuratRekap
     * const suratRekap = await prisma.suratRekap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuratRekapFindUniqueArgs>(args: SelectSubset<T, SuratRekapFindUniqueArgs<ExtArgs>>): Prisma__SuratRekapClient<$Result.GetResult<Prisma.$SuratRekapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SuratRekap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuratRekapFindUniqueOrThrowArgs} args - Arguments to find a SuratRekap
     * @example
     * // Get one SuratRekap
     * const suratRekap = await prisma.suratRekap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuratRekapFindUniqueOrThrowArgs>(args: SelectSubset<T, SuratRekapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuratRekapClient<$Result.GetResult<Prisma.$SuratRekapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuratRekap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuratRekapFindFirstArgs} args - Arguments to find a SuratRekap
     * @example
     * // Get one SuratRekap
     * const suratRekap = await prisma.suratRekap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuratRekapFindFirstArgs>(args?: SelectSubset<T, SuratRekapFindFirstArgs<ExtArgs>>): Prisma__SuratRekapClient<$Result.GetResult<Prisma.$SuratRekapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuratRekap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuratRekapFindFirstOrThrowArgs} args - Arguments to find a SuratRekap
     * @example
     * // Get one SuratRekap
     * const suratRekap = await prisma.suratRekap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuratRekapFindFirstOrThrowArgs>(args?: SelectSubset<T, SuratRekapFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuratRekapClient<$Result.GetResult<Prisma.$SuratRekapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SuratRekaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuratRekapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuratRekaps
     * const suratRekaps = await prisma.suratRekap.findMany()
     * 
     * // Get first 10 SuratRekaps
     * const suratRekaps = await prisma.suratRekap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suratRekapWithIdOnly = await prisma.suratRekap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuratRekapFindManyArgs>(args?: SelectSubset<T, SuratRekapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuratRekapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SuratRekap.
     * @param {SuratRekapCreateArgs} args - Arguments to create a SuratRekap.
     * @example
     * // Create one SuratRekap
     * const SuratRekap = await prisma.suratRekap.create({
     *   data: {
     *     // ... data to create a SuratRekap
     *   }
     * })
     * 
     */
    create<T extends SuratRekapCreateArgs>(args: SelectSubset<T, SuratRekapCreateArgs<ExtArgs>>): Prisma__SuratRekapClient<$Result.GetResult<Prisma.$SuratRekapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SuratRekaps.
     * @param {SuratRekapCreateManyArgs} args - Arguments to create many SuratRekaps.
     * @example
     * // Create many SuratRekaps
     * const suratRekap = await prisma.suratRekap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuratRekapCreateManyArgs>(args?: SelectSubset<T, SuratRekapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuratRekaps and returns the data saved in the database.
     * @param {SuratRekapCreateManyAndReturnArgs} args - Arguments to create many SuratRekaps.
     * @example
     * // Create many SuratRekaps
     * const suratRekap = await prisma.suratRekap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuratRekaps and only return the `id`
     * const suratRekapWithIdOnly = await prisma.suratRekap.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuratRekapCreateManyAndReturnArgs>(args?: SelectSubset<T, SuratRekapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuratRekapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SuratRekap.
     * @param {SuratRekapDeleteArgs} args - Arguments to delete one SuratRekap.
     * @example
     * // Delete one SuratRekap
     * const SuratRekap = await prisma.suratRekap.delete({
     *   where: {
     *     // ... filter to delete one SuratRekap
     *   }
     * })
     * 
     */
    delete<T extends SuratRekapDeleteArgs>(args: SelectSubset<T, SuratRekapDeleteArgs<ExtArgs>>): Prisma__SuratRekapClient<$Result.GetResult<Prisma.$SuratRekapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SuratRekap.
     * @param {SuratRekapUpdateArgs} args - Arguments to update one SuratRekap.
     * @example
     * // Update one SuratRekap
     * const suratRekap = await prisma.suratRekap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuratRekapUpdateArgs>(args: SelectSubset<T, SuratRekapUpdateArgs<ExtArgs>>): Prisma__SuratRekapClient<$Result.GetResult<Prisma.$SuratRekapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SuratRekaps.
     * @param {SuratRekapDeleteManyArgs} args - Arguments to filter SuratRekaps to delete.
     * @example
     * // Delete a few SuratRekaps
     * const { count } = await prisma.suratRekap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuratRekapDeleteManyArgs>(args?: SelectSubset<T, SuratRekapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuratRekaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuratRekapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuratRekaps
     * const suratRekap = await prisma.suratRekap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuratRekapUpdateManyArgs>(args: SelectSubset<T, SuratRekapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuratRekaps and returns the data updated in the database.
     * @param {SuratRekapUpdateManyAndReturnArgs} args - Arguments to update many SuratRekaps.
     * @example
     * // Update many SuratRekaps
     * const suratRekap = await prisma.suratRekap.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SuratRekaps and only return the `id`
     * const suratRekapWithIdOnly = await prisma.suratRekap.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuratRekapUpdateManyAndReturnArgs>(args: SelectSubset<T, SuratRekapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuratRekapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SuratRekap.
     * @param {SuratRekapUpsertArgs} args - Arguments to update or create a SuratRekap.
     * @example
     * // Update or create a SuratRekap
     * const suratRekap = await prisma.suratRekap.upsert({
     *   create: {
     *     // ... data to create a SuratRekap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuratRekap we want to update
     *   }
     * })
     */
    upsert<T extends SuratRekapUpsertArgs>(args: SelectSubset<T, SuratRekapUpsertArgs<ExtArgs>>): Prisma__SuratRekapClient<$Result.GetResult<Prisma.$SuratRekapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SuratRekaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuratRekapCountArgs} args - Arguments to filter SuratRekaps to count.
     * @example
     * // Count the number of SuratRekaps
     * const count = await prisma.suratRekap.count({
     *   where: {
     *     // ... the filter for the SuratRekaps we want to count
     *   }
     * })
    **/
    count<T extends SuratRekapCountArgs>(
      args?: Subset<T, SuratRekapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuratRekapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuratRekap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuratRekapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuratRekapAggregateArgs>(args: Subset<T, SuratRekapAggregateArgs>): Prisma.PrismaPromise<GetSuratRekapAggregateType<T>>

    /**
     * Group by SuratRekap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuratRekapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuratRekapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuratRekapGroupByArgs['orderBy'] }
        : { orderBy?: SuratRekapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuratRekapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuratRekapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuratRekap model
   */
  readonly fields: SuratRekapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuratRekap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuratRekapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends SuratRekap$createdByArgs<ExtArgs> = {}>(args?: Subset<T, SuratRekap$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuratRekap model
   */
  interface SuratRekapFieldRefs {
    readonly id: FieldRef<"SuratRekap", 'Int'>
    readonly tanggal: FieldRef<"SuratRekap", 'DateTime'>
    readonly noSurat: FieldRef<"SuratRekap", 'String'>
    readonly kepada: FieldRef<"SuratRekap", 'String'>
    readonly perihal: FieldRef<"SuratRekap", 'String'>
    readonly disposisiKa: FieldRef<"SuratRekap", 'String'>
    readonly paraf: FieldRef<"SuratRekap", 'String'>
    readonly createdById: FieldRef<"SuratRekap", 'Int'>
    readonly createdAt: FieldRef<"SuratRekap", 'DateTime'>
    readonly updatedAt: FieldRef<"SuratRekap", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SuratRekap findUnique
   */
  export type SuratRekapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuratRekap
     */
    select?: SuratRekapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuratRekap
     */
    omit?: SuratRekapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuratRekapInclude<ExtArgs> | null
    /**
     * Filter, which SuratRekap to fetch.
     */
    where: SuratRekapWhereUniqueInput
  }

  /**
   * SuratRekap findUniqueOrThrow
   */
  export type SuratRekapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuratRekap
     */
    select?: SuratRekapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuratRekap
     */
    omit?: SuratRekapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuratRekapInclude<ExtArgs> | null
    /**
     * Filter, which SuratRekap to fetch.
     */
    where: SuratRekapWhereUniqueInput
  }

  /**
   * SuratRekap findFirst
   */
  export type SuratRekapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuratRekap
     */
    select?: SuratRekapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuratRekap
     */
    omit?: SuratRekapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuratRekapInclude<ExtArgs> | null
    /**
     * Filter, which SuratRekap to fetch.
     */
    where?: SuratRekapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuratRekaps to fetch.
     */
    orderBy?: SuratRekapOrderByWithRelationInput | SuratRekapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuratRekaps.
     */
    cursor?: SuratRekapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuratRekaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuratRekaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuratRekaps.
     */
    distinct?: SuratRekapScalarFieldEnum | SuratRekapScalarFieldEnum[]
  }

  /**
   * SuratRekap findFirstOrThrow
   */
  export type SuratRekapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuratRekap
     */
    select?: SuratRekapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuratRekap
     */
    omit?: SuratRekapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuratRekapInclude<ExtArgs> | null
    /**
     * Filter, which SuratRekap to fetch.
     */
    where?: SuratRekapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuratRekaps to fetch.
     */
    orderBy?: SuratRekapOrderByWithRelationInput | SuratRekapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuratRekaps.
     */
    cursor?: SuratRekapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuratRekaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuratRekaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuratRekaps.
     */
    distinct?: SuratRekapScalarFieldEnum | SuratRekapScalarFieldEnum[]
  }

  /**
   * SuratRekap findMany
   */
  export type SuratRekapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuratRekap
     */
    select?: SuratRekapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuratRekap
     */
    omit?: SuratRekapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuratRekapInclude<ExtArgs> | null
    /**
     * Filter, which SuratRekaps to fetch.
     */
    where?: SuratRekapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuratRekaps to fetch.
     */
    orderBy?: SuratRekapOrderByWithRelationInput | SuratRekapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuratRekaps.
     */
    cursor?: SuratRekapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuratRekaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuratRekaps.
     */
    skip?: number
    distinct?: SuratRekapScalarFieldEnum | SuratRekapScalarFieldEnum[]
  }

  /**
   * SuratRekap create
   */
  export type SuratRekapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuratRekap
     */
    select?: SuratRekapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuratRekap
     */
    omit?: SuratRekapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuratRekapInclude<ExtArgs> | null
    /**
     * The data needed to create a SuratRekap.
     */
    data: XOR<SuratRekapCreateInput, SuratRekapUncheckedCreateInput>
  }

  /**
   * SuratRekap createMany
   */
  export type SuratRekapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuratRekaps.
     */
    data: SuratRekapCreateManyInput | SuratRekapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuratRekap createManyAndReturn
   */
  export type SuratRekapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuratRekap
     */
    select?: SuratRekapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuratRekap
     */
    omit?: SuratRekapOmit<ExtArgs> | null
    /**
     * The data used to create many SuratRekaps.
     */
    data: SuratRekapCreateManyInput | SuratRekapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuratRekapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuratRekap update
   */
  export type SuratRekapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuratRekap
     */
    select?: SuratRekapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuratRekap
     */
    omit?: SuratRekapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuratRekapInclude<ExtArgs> | null
    /**
     * The data needed to update a SuratRekap.
     */
    data: XOR<SuratRekapUpdateInput, SuratRekapUncheckedUpdateInput>
    /**
     * Choose, which SuratRekap to update.
     */
    where: SuratRekapWhereUniqueInput
  }

  /**
   * SuratRekap updateMany
   */
  export type SuratRekapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuratRekaps.
     */
    data: XOR<SuratRekapUpdateManyMutationInput, SuratRekapUncheckedUpdateManyInput>
    /**
     * Filter which SuratRekaps to update
     */
    where?: SuratRekapWhereInput
    /**
     * Limit how many SuratRekaps to update.
     */
    limit?: number
  }

  /**
   * SuratRekap updateManyAndReturn
   */
  export type SuratRekapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuratRekap
     */
    select?: SuratRekapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuratRekap
     */
    omit?: SuratRekapOmit<ExtArgs> | null
    /**
     * The data used to update SuratRekaps.
     */
    data: XOR<SuratRekapUpdateManyMutationInput, SuratRekapUncheckedUpdateManyInput>
    /**
     * Filter which SuratRekaps to update
     */
    where?: SuratRekapWhereInput
    /**
     * Limit how many SuratRekaps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuratRekapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuratRekap upsert
   */
  export type SuratRekapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuratRekap
     */
    select?: SuratRekapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuratRekap
     */
    omit?: SuratRekapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuratRekapInclude<ExtArgs> | null
    /**
     * The filter to search for the SuratRekap to update in case it exists.
     */
    where: SuratRekapWhereUniqueInput
    /**
     * In case the SuratRekap found by the `where` argument doesn't exist, create a new SuratRekap with this data.
     */
    create: XOR<SuratRekapCreateInput, SuratRekapUncheckedCreateInput>
    /**
     * In case the SuratRekap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuratRekapUpdateInput, SuratRekapUncheckedUpdateInput>
  }

  /**
   * SuratRekap delete
   */
  export type SuratRekapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuratRekap
     */
    select?: SuratRekapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuratRekap
     */
    omit?: SuratRekapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuratRekapInclude<ExtArgs> | null
    /**
     * Filter which SuratRekap to delete.
     */
    where: SuratRekapWhereUniqueInput
  }

  /**
   * SuratRekap deleteMany
   */
  export type SuratRekapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuratRekaps to delete
     */
    where?: SuratRekapWhereInput
    /**
     * Limit how many SuratRekaps to delete.
     */
    limit?: number
  }

  /**
   * SuratRekap.createdBy
   */
  export type SuratRekap$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SuratRekap without action
   */
  export type SuratRekapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuratRekap
     */
    select?: SuratRekapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuratRekap
     */
    omit?: SuratRekapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuratRekapInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type DocumentSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    title: string | null
    category: string | null
    description: string | null
    fileUrl: string | null
    fileName: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    category: string | null
    description: string | null
    fileUrl: string | null
    fileName: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    title: number
    category: number
    description: number
    fileUrl: number
    fileName: number
    sortOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    sortOrder?: true
  }

  export type DocumentSumAggregateInputType = {
    sortOrder?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    title?: true
    category?: true
    description?: true
    fileUrl?: true
    fileName?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    title?: true
    category?: true
    description?: true
    fileUrl?: true
    fileName?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    title?: true
    category?: true
    description?: true
    fileUrl?: true
    fileName?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    title: string
    category: string | null
    description: string | null
    fileUrl: string
    fileName: string | null
    sortOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    category?: boolean
    description?: boolean
    fileUrl?: boolean
    fileName?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    category?: boolean
    description?: boolean
    fileUrl?: boolean
    fileName?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    category?: boolean
    description?: boolean
    fileUrl?: boolean
    fileName?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    title?: boolean
    category?: boolean
    description?: boolean
    fileUrl?: boolean
    fileName?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "category" | "description" | "fileUrl" | "fileName" | "sortOrder" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["document"]>

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      category: string | null
      description: string | null
      fileUrl: string
      fileName: string | null
      sortOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly title: FieldRef<"Document", 'String'>
    readonly category: FieldRef<"Document", 'String'>
    readonly description: FieldRef<"Document", 'String'>
    readonly fileUrl: FieldRef<"Document", 'String'>
    readonly fileName: FieldRef<"Document", 'String'>
    readonly sortOrder: FieldRef<"Document", 'Int'>
    readonly isActive: FieldRef<"Document", 'Boolean'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
  }


  /**
   * Model PushSubscription
   */

  export type AggregatePushSubscription = {
    _count: PushSubscriptionCountAggregateOutputType | null
    _avg: PushSubscriptionAvgAggregateOutputType | null
    _sum: PushSubscriptionSumAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  export type PushSubscriptionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PushSubscriptionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PushSubscriptionMinAggregateOutputType = {
    id: number | null
    endpoint: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PushSubscriptionMaxAggregateOutputType = {
    id: number | null
    endpoint: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PushSubscriptionCountAggregateOutputType = {
    id: number
    endpoint: number
    subscription: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PushSubscriptionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PushSubscriptionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PushSubscriptionMinAggregateInputType = {
    id?: true
    endpoint?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PushSubscriptionMaxAggregateInputType = {
    id?: true
    endpoint?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PushSubscriptionCountAggregateInputType = {
    id?: true
    endpoint?: true
    subscription?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PushSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscription to aggregate.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PushSubscriptions
    **/
    _count?: true | PushSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PushSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PushSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PushSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type GetPushSubscriptionAggregateType<T extends PushSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePushSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushSubscription[P]>
      : GetScalarType<T[P], AggregatePushSubscription[P]>
  }




  export type PushSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithAggregationInput | PushSubscriptionOrderByWithAggregationInput[]
    by: PushSubscriptionScalarFieldEnum[] | PushSubscriptionScalarFieldEnum
    having?: PushSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PushSubscriptionCountAggregateInputType | true
    _avg?: PushSubscriptionAvgAggregateInputType
    _sum?: PushSubscriptionSumAggregateInputType
    _min?: PushSubscriptionMinAggregateInputType
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type PushSubscriptionGroupByOutputType = {
    id: number
    endpoint: string
    subscription: JsonValue
    userId: number | null
    createdAt: Date
    updatedAt: Date
    _count: PushSubscriptionCountAggregateOutputType | null
    _avg: PushSubscriptionAvgAggregateOutputType | null
    _sum: PushSubscriptionSumAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  type GetPushSubscriptionGroupByPayload<T extends PushSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PushSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PushSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type PushSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    subscription?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | PushSubscription$userArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    subscription?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | PushSubscription$userArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    subscription?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | PushSubscription$userArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectScalar = {
    id?: boolean
    endpoint?: boolean
    subscription?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PushSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "endpoint" | "subscription" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["pushSubscription"]>
  export type PushSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PushSubscription$userArgs<ExtArgs>
  }
  export type PushSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PushSubscription$userArgs<ExtArgs>
  }
  export type PushSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PushSubscription$userArgs<ExtArgs>
  }

  export type $PushSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PushSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      endpoint: string
      subscription: Prisma.JsonValue
      userId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pushSubscription"]>
    composites: {}
  }

  type PushSubscriptionGetPayload<S extends boolean | null | undefined | PushSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$PushSubscriptionPayload, S>

  type PushSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PushSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PushSubscriptionCountAggregateInputType | true
    }

  export interface PushSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PushSubscription'], meta: { name: 'PushSubscription' } }
    /**
     * Find zero or one PushSubscription that matches the filter.
     * @param {PushSubscriptionFindUniqueArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PushSubscriptionFindUniqueArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PushSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PushSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PushSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PushSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PushSubscriptionFindFirstArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PushSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PushSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PushSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany()
     * 
     * // Get first 10 PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PushSubscriptionFindManyArgs>(args?: SelectSubset<T, PushSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PushSubscription.
     * @param {PushSubscriptionCreateArgs} args - Arguments to create a PushSubscription.
     * @example
     * // Create one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.create({
     *   data: {
     *     // ... data to create a PushSubscription
     *   }
     * })
     * 
     */
    create<T extends PushSubscriptionCreateArgs>(args: SelectSubset<T, PushSubscriptionCreateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PushSubscriptions.
     * @param {PushSubscriptionCreateManyArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PushSubscriptionCreateManyArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PushSubscriptions and returns the data saved in the database.
     * @param {PushSubscriptionCreateManyAndReturnArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PushSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PushSubscription.
     * @param {PushSubscriptionDeleteArgs} args - Arguments to delete one PushSubscription.
     * @example
     * // Delete one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.delete({
     *   where: {
     *     // ... filter to delete one PushSubscription
     *   }
     * })
     * 
     */
    delete<T extends PushSubscriptionDeleteArgs>(args: SelectSubset<T, PushSubscriptionDeleteArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PushSubscription.
     * @param {PushSubscriptionUpdateArgs} args - Arguments to update one PushSubscription.
     * @example
     * // Update one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PushSubscriptionUpdateArgs>(args: SelectSubset<T, PushSubscriptionUpdateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PushSubscriptions.
     * @param {PushSubscriptionDeleteManyArgs} args - Arguments to filter PushSubscriptions to delete.
     * @example
     * // Delete a few PushSubscriptions
     * const { count } = await prisma.pushSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PushSubscriptionDeleteManyArgs>(args?: SelectSubset<T, PushSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PushSubscriptionUpdateManyArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions and returns the data updated in the database.
     * @param {PushSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many PushSubscriptions.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PushSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PushSubscription.
     * @param {PushSubscriptionUpsertArgs} args - Arguments to update or create a PushSubscription.
     * @example
     * // Update or create a PushSubscription
     * const pushSubscription = await prisma.pushSubscription.upsert({
     *   create: {
     *     // ... data to create a PushSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushSubscription we want to update
     *   }
     * })
     */
    upsert<T extends PushSubscriptionUpsertArgs>(args: SelectSubset<T, PushSubscriptionUpsertArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionCountArgs} args - Arguments to filter PushSubscriptions to count.
     * @example
     * // Count the number of PushSubscriptions
     * const count = await prisma.pushSubscription.count({
     *   where: {
     *     // ... the filter for the PushSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends PushSubscriptionCountArgs>(
      args?: Subset<T, PushSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushSubscriptionAggregateArgs>(args: Subset<T, PushSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetPushSubscriptionAggregateType<T>>

    /**
     * Group by PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PushSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: PushSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PushSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPushSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PushSubscription model
   */
  readonly fields: PushSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PushSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PushSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends PushSubscription$userArgs<ExtArgs> = {}>(args?: Subset<T, PushSubscription$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PushSubscription model
   */
  interface PushSubscriptionFieldRefs {
    readonly id: FieldRef<"PushSubscription", 'Int'>
    readonly endpoint: FieldRef<"PushSubscription", 'String'>
    readonly subscription: FieldRef<"PushSubscription", 'Json'>
    readonly userId: FieldRef<"PushSubscription", 'Int'>
    readonly createdAt: FieldRef<"PushSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"PushSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PushSubscription findUnique
   */
  export type PushSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findUniqueOrThrow
   */
  export type PushSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findFirst
   */
  export type PushSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findFirstOrThrow
   */
  export type PushSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findMany
   */
  export type PushSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscriptions to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription create
   */
  export type PushSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PushSubscription.
     */
    data: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
  }

  /**
   * PushSubscription createMany
   */
  export type PushSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PushSubscription createManyAndReturn
   */
  export type PushSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushSubscription update
   */
  export type PushSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PushSubscription.
     */
    data: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which PushSubscription to update.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription updateMany
   */
  export type PushSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number
  }

  /**
   * PushSubscription updateManyAndReturn
   */
  export type PushSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushSubscription upsert
   */
  export type PushSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PushSubscription to update in case it exists.
     */
    where: PushSubscriptionWhereUniqueInput
    /**
     * In case the PushSubscription found by the `where` argument doesn't exist, create a new PushSubscription with this data.
     */
    create: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
    /**
     * In case the PushSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
  }

  /**
   * PushSubscription delete
   */
  export type PushSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which PushSubscription to delete.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription deleteMany
   */
  export type PushSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscriptions to delete
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * PushSubscription.user
   */
  export type PushSubscription$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PushSubscription without action
   */
  export type PushSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    isActive: 'isActive',
    nrp: 'nrp',
    pangkat: 'pangkat',
    satuan: 'satuan',
    avatarUrl: 'avatarUrl',
    ttdJabatan: 'ttdJabatan',
    ttdNama: 'ttdNama',
    ttdPangkat: 'ttdPangkat',
    ttdNrp: 'ttdNrp',
    stplkLabel: 'stplkLabel',
    stplkJabatan: 'stplkJabatan',
    stplkNama: 'stplkNama',
    stplkPangkat: 'stplkPangkat',
    stplkNrp: 'stplkNrp',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LeaderProfileScalarFieldEnum: {
    id: 'id',
    roleKey: 'roleKey',
    nama: 'nama',
    jabatan: 'jabatan',
    pesan: 'pesan',
    bio: 'bio',
    fotoUrl: 'fotoUrl',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type LeaderProfileScalarFieldEnum = (typeof LeaderProfileScalarFieldEnum)[keyof typeof LeaderProfileScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo',
    description: 'description'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const AnggotaScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    jabatan: 'jabatan',
    foto_url: 'foto_url',
    unit_id: 'unit_id'
  };

  export type AnggotaScalarFieldEnum = (typeof AnggotaScalarFieldEnum)[keyof typeof AnggotaScalarFieldEnum]


  export const FacilityScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    image: 'image',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacilityScalarFieldEnum = (typeof FacilityScalarFieldEnum)[keyof typeof FacilityScalarFieldEnum]


  export const NewsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    date: 'date',
    image: 'image',
    images: 'images',
    excerpt: 'excerpt',
    content: 'content',
    popularity: 'popularity',
    viewCount: 'viewCount',
    shareCount: 'shareCount',
    sharedByUserId: 'sharedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsScalarFieldEnum = (typeof NewsScalarFieldEnum)[keyof typeof NewsScalarFieldEnum]


  export const EducationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    date: 'date',
    image: 'image',
    images: 'images',
    excerpt: 'excerpt',
    content: 'content',
    popularity: 'popularity',
    viewCount: 'viewCount',
    shareCount: 'shareCount',
    sharedByUserId: 'sharedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EducationScalarFieldEnum = (typeof EducationScalarFieldEnum)[keyof typeof EducationScalarFieldEnum]


  export const LetterCounterScalarFieldEnum: {
    id: 'id',
    type: 'type',
    year: 'year',
    nextNumber: 'nextNumber',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type LetterCounterScalarFieldEnum = (typeof LetterCounterScalarFieldEnum)[keyof typeof LetterCounterScalarFieldEnum]


  export const LetterApplicationScalarFieldEnum: {
    id: 'id',
    code: 'code',
    type: 'type',
    status: 'status',
    statusFeedback: 'statusFeedback',
    nomorUrut: 'nomorUrut',
    nomorSurat: 'nomorSurat',
    nik: 'nik',
    hp: 'hp',
    alamat: 'alamat',
    namaOrganisasi: 'namaOrganisasi',
    kecamatan: 'kecamatan',
    penanggungJawab: 'penanggungJawab',
    jenisKegiatan: 'jenisKegiatan',
    namaKegiatan: 'namaKegiatan',
    lokasi: 'lokasi',
    tanggal: 'tanggal',
    waktuMulai: 'waktuMulai',
    waktuSelesai: 'waktuSelesai',
    perkiraanPeserta: 'perkiraanPeserta',
    ktpPath: 'ktpPath',
    rekomendasiDesaPath: 'rekomendasiDesaPath',
    rekomDesaNama: 'rekomDesaNama',
    rekomDesaNomor: 'rekomDesaNomor',
    nama: 'nama',
    tempatLahir: 'tempatLahir',
    tanggalLahir: 'tanggalLahir',
    jenisKelamin: 'jenisKelamin',
    pekerjaan: 'pekerjaan',
    agama: 'agama',
    kehilanganItems: 'kehilanganItems',
    kehilanganApa: 'kehilanganApa',
    kronologi: 'kronologi',
    tanggalLaporan: 'tanggalLaporan',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LetterApplicationScalarFieldEnum = (typeof LetterApplicationScalarFieldEnum)[keyof typeof LetterApplicationScalarFieldEnum]


  export const OnlineReportScalarFieldEnum: {
    id: 'id',
    code: 'code',
    status: 'status',
    statusFeedback: 'statusFeedback',
    nama: 'nama',
    nik: 'nik',
    hp: 'hp',
    kecamatan: 'kecamatan',
    jenis: 'jenis',
    lokasi: 'lokasi',
    tanggal: 'tanggal',
    jam: 'jam',
    kronologi: 'kronologi',
    lampiranPath: 'lampiranPath',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OnlineReportScalarFieldEnum = (typeof OnlineReportScalarFieldEnum)[keyof typeof OnlineReportScalarFieldEnum]


  export const SuratRekapScalarFieldEnum: {
    id: 'id',
    tanggal: 'tanggal',
    noSurat: 'noSurat',
    kepada: 'kepada',
    perihal: 'perihal',
    disposisiKa: 'disposisiKa',
    paraf: 'paraf',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SuratRekapScalarFieldEnum = (typeof SuratRekapScalarFieldEnum)[keyof typeof SuratRekapScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    category: 'category',
    description: 'description',
    fileUrl: 'fileUrl',
    fileName: 'fileName',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const PushSubscriptionScalarFieldEnum: {
    id: 'id',
    endpoint: 'endpoint',
    subscription: 'subscription',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PushSubscriptionScalarFieldEnum = (typeof PushSubscriptionScalarFieldEnum)[keyof typeof PushSubscriptionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'LetterType'
   */
  export type EnumLetterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LetterType'>
    


  /**
   * Reference to a field of type 'LetterType[]'
   */
  export type ListEnumLetterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LetterType[]'>
    


  /**
   * Reference to a field of type 'LetterStatus'
   */
  export type EnumLetterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LetterStatus'>
    


  /**
   * Reference to a field of type 'LetterStatus[]'
   */
  export type ListEnumLetterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LetterStatus[]'>
    


  /**
   * Reference to a field of type 'OnlineReportStatus'
   */
  export type EnumOnlineReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnlineReportStatus'>
    


  /**
   * Reference to a field of type 'OnlineReportStatus[]'
   */
  export type ListEnumOnlineReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnlineReportStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    nrp?: StringNullableFilter<"User"> | string | null
    pangkat?: StringNullableFilter<"User"> | string | null
    satuan?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    ttdJabatan?: StringNullableFilter<"User"> | string | null
    ttdNama?: StringNullableFilter<"User"> | string | null
    ttdPangkat?: StringNullableFilter<"User"> | string | null
    ttdNrp?: StringNullableFilter<"User"> | string | null
    stplkLabel?: StringNullableFilter<"User"> | string | null
    stplkJabatan?: StringNullableFilter<"User"> | string | null
    stplkNama?: StringNullableFilter<"User"> | string | null
    stplkPangkat?: StringNullableFilter<"User"> | string | null
    stplkNrp?: StringNullableFilter<"User"> | string | null
    createdById?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    createdSuratRekap?: SuratRekapListRelationFilter
    sharedNews?: NewsListRelationFilter
    sharedEducation?: EducationListRelationFilter
    PushSubscription?: PushSubscriptionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    nrp?: SortOrderInput | SortOrder
    pangkat?: SortOrderInput | SortOrder
    satuan?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    ttdJabatan?: SortOrderInput | SortOrder
    ttdNama?: SortOrderInput | SortOrder
    ttdPangkat?: SortOrderInput | SortOrder
    ttdNrp?: SortOrderInput | SortOrder
    stplkLabel?: SortOrderInput | SortOrder
    stplkJabatan?: SortOrderInput | SortOrder
    stplkNama?: SortOrderInput | SortOrder
    stplkPangkat?: SortOrderInput | SortOrder
    stplkNrp?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    createdUsers?: UserOrderByRelationAggregateInput
    createdSuratRekap?: SuratRekapOrderByRelationAggregateInput
    sharedNews?: NewsOrderByRelationAggregateInput
    sharedEducation?: EducationOrderByRelationAggregateInput
    PushSubscription?: PushSubscriptionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    nrp?: StringNullableFilter<"User"> | string | null
    pangkat?: StringNullableFilter<"User"> | string | null
    satuan?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    ttdJabatan?: StringNullableFilter<"User"> | string | null
    ttdNama?: StringNullableFilter<"User"> | string | null
    ttdPangkat?: StringNullableFilter<"User"> | string | null
    ttdNrp?: StringNullableFilter<"User"> | string | null
    stplkLabel?: StringNullableFilter<"User"> | string | null
    stplkJabatan?: StringNullableFilter<"User"> | string | null
    stplkNama?: StringNullableFilter<"User"> | string | null
    stplkPangkat?: StringNullableFilter<"User"> | string | null
    stplkNrp?: StringNullableFilter<"User"> | string | null
    createdById?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    createdSuratRekap?: SuratRekapListRelationFilter
    sharedNews?: NewsListRelationFilter
    sharedEducation?: EducationListRelationFilter
    PushSubscription?: PushSubscriptionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    nrp?: SortOrderInput | SortOrder
    pangkat?: SortOrderInput | SortOrder
    satuan?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    ttdJabatan?: SortOrderInput | SortOrder
    ttdNama?: SortOrderInput | SortOrder
    ttdPangkat?: SortOrderInput | SortOrder
    ttdNrp?: SortOrderInput | SortOrder
    stplkLabel?: SortOrderInput | SortOrder
    stplkJabatan?: SortOrderInput | SortOrder
    stplkNama?: SortOrderInput | SortOrder
    stplkPangkat?: SortOrderInput | SortOrder
    stplkNrp?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    nrp?: StringNullableWithAggregatesFilter<"User"> | string | null
    pangkat?: StringNullableWithAggregatesFilter<"User"> | string | null
    satuan?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    ttdJabatan?: StringNullableWithAggregatesFilter<"User"> | string | null
    ttdNama?: StringNullableWithAggregatesFilter<"User"> | string | null
    ttdPangkat?: StringNullableWithAggregatesFilter<"User"> | string | null
    ttdNrp?: StringNullableWithAggregatesFilter<"User"> | string | null
    stplkLabel?: StringNullableWithAggregatesFilter<"User"> | string | null
    stplkJabatan?: StringNullableWithAggregatesFilter<"User"> | string | null
    stplkNama?: StringNullableWithAggregatesFilter<"User"> | string | null
    stplkPangkat?: StringNullableWithAggregatesFilter<"User"> | string | null
    stplkNrp?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdById?: IntNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type LeaderProfileWhereInput = {
    AND?: LeaderProfileWhereInput | LeaderProfileWhereInput[]
    OR?: LeaderProfileWhereInput[]
    NOT?: LeaderProfileWhereInput | LeaderProfileWhereInput[]
    id?: IntFilter<"LeaderProfile"> | number
    roleKey?: StringFilter<"LeaderProfile"> | string
    nama?: StringFilter<"LeaderProfile"> | string
    jabatan?: StringFilter<"LeaderProfile"> | string
    pesan?: StringFilter<"LeaderProfile"> | string
    bio?: StringFilter<"LeaderProfile"> | string
    fotoUrl?: StringNullableFilter<"LeaderProfile"> | string | null
    updatedAt?: DateTimeFilter<"LeaderProfile"> | Date | string
    updatedBy?: IntNullableFilter<"LeaderProfile"> | number | null
  }

  export type LeaderProfileOrderByWithRelationInput = {
    id?: SortOrder
    roleKey?: SortOrder
    nama?: SortOrder
    jabatan?: SortOrder
    pesan?: SortOrder
    bio?: SortOrder
    fotoUrl?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
  }

  export type LeaderProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roleKey?: string
    AND?: LeaderProfileWhereInput | LeaderProfileWhereInput[]
    OR?: LeaderProfileWhereInput[]
    NOT?: LeaderProfileWhereInput | LeaderProfileWhereInput[]
    nama?: StringFilter<"LeaderProfile"> | string
    jabatan?: StringFilter<"LeaderProfile"> | string
    pesan?: StringFilter<"LeaderProfile"> | string
    bio?: StringFilter<"LeaderProfile"> | string
    fotoUrl?: StringNullableFilter<"LeaderProfile"> | string | null
    updatedAt?: DateTimeFilter<"LeaderProfile"> | Date | string
    updatedBy?: IntNullableFilter<"LeaderProfile"> | number | null
  }, "id" | "roleKey">

  export type LeaderProfileOrderByWithAggregationInput = {
    id?: SortOrder
    roleKey?: SortOrder
    nama?: SortOrder
    jabatan?: SortOrder
    pesan?: SortOrder
    bio?: SortOrder
    fotoUrl?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: LeaderProfileCountOrderByAggregateInput
    _avg?: LeaderProfileAvgOrderByAggregateInput
    _max?: LeaderProfileMaxOrderByAggregateInput
    _min?: LeaderProfileMinOrderByAggregateInput
    _sum?: LeaderProfileSumOrderByAggregateInput
  }

  export type LeaderProfileScalarWhereWithAggregatesInput = {
    AND?: LeaderProfileScalarWhereWithAggregatesInput | LeaderProfileScalarWhereWithAggregatesInput[]
    OR?: LeaderProfileScalarWhereWithAggregatesInput[]
    NOT?: LeaderProfileScalarWhereWithAggregatesInput | LeaderProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeaderProfile"> | number
    roleKey?: StringWithAggregatesFilter<"LeaderProfile"> | string
    nama?: StringWithAggregatesFilter<"LeaderProfile"> | string
    jabatan?: StringWithAggregatesFilter<"LeaderProfile"> | string
    pesan?: StringWithAggregatesFilter<"LeaderProfile"> | string
    bio?: StringWithAggregatesFilter<"LeaderProfile"> | string
    fotoUrl?: StringNullableWithAggregatesFilter<"LeaderProfile"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"LeaderProfile"> | Date | string
    updatedBy?: IntNullableWithAggregatesFilter<"LeaderProfile"> | number | null
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: IntFilter<"Unit"> | number
    name?: StringFilter<"Unit"> | string
    logo?: StringNullableFilter<"Unit"> | string | null
    description?: StringNullableFilter<"Unit"> | string | null
    anggota?: AnggotaListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    anggota?: AnggotaOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    logo?: StringNullableFilter<"Unit"> | string | null
    description?: StringNullableFilter<"Unit"> | string | null
    anggota?: AnggotaListRelationFilter
  }, "id" | "name">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Unit"> | number
    name?: StringWithAggregatesFilter<"Unit"> | string
    logo?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    description?: StringNullableWithAggregatesFilter<"Unit"> | string | null
  }

  export type AnggotaWhereInput = {
    AND?: AnggotaWhereInput | AnggotaWhereInput[]
    OR?: AnggotaWhereInput[]
    NOT?: AnggotaWhereInput | AnggotaWhereInput[]
    id?: IntFilter<"Anggota"> | number
    nama?: StringFilter<"Anggota"> | string
    jabatan?: StringFilter<"Anggota"> | string
    foto_url?: StringNullableFilter<"Anggota"> | string | null
    unit_id?: IntFilter<"Anggota"> | number
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type AnggotaOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    jabatan?: SortOrder
    foto_url?: SortOrderInput | SortOrder
    unit_id?: SortOrder
    unit?: UnitOrderByWithRelationInput
  }

  export type AnggotaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnggotaWhereInput | AnggotaWhereInput[]
    OR?: AnggotaWhereInput[]
    NOT?: AnggotaWhereInput | AnggotaWhereInput[]
    nama?: StringFilter<"Anggota"> | string
    jabatan?: StringFilter<"Anggota"> | string
    foto_url?: StringNullableFilter<"Anggota"> | string | null
    unit_id?: IntFilter<"Anggota"> | number
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type AnggotaOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    jabatan?: SortOrder
    foto_url?: SortOrderInput | SortOrder
    unit_id?: SortOrder
    _count?: AnggotaCountOrderByAggregateInput
    _avg?: AnggotaAvgOrderByAggregateInput
    _max?: AnggotaMaxOrderByAggregateInput
    _min?: AnggotaMinOrderByAggregateInput
    _sum?: AnggotaSumOrderByAggregateInput
  }

  export type AnggotaScalarWhereWithAggregatesInput = {
    AND?: AnggotaScalarWhereWithAggregatesInput | AnggotaScalarWhereWithAggregatesInput[]
    OR?: AnggotaScalarWhereWithAggregatesInput[]
    NOT?: AnggotaScalarWhereWithAggregatesInput | AnggotaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Anggota"> | number
    nama?: StringWithAggregatesFilter<"Anggota"> | string
    jabatan?: StringWithAggregatesFilter<"Anggota"> | string
    foto_url?: StringNullableWithAggregatesFilter<"Anggota"> | string | null
    unit_id?: IntWithAggregatesFilter<"Anggota"> | number
  }

  export type FacilityWhereInput = {
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    id?: IntFilter<"Facility"> | number
    title?: StringFilter<"Facility"> | string
    description?: StringFilter<"Facility"> | string
    image?: StringNullableFilter<"Facility"> | string | null
    sortOrder?: IntFilter<"Facility"> | number
    createdAt?: DateTimeFilter<"Facility"> | Date | string
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
  }

  export type FacilityOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    title?: StringFilter<"Facility"> | string
    description?: StringFilter<"Facility"> | string
    image?: StringNullableFilter<"Facility"> | string | null
    sortOrder?: IntFilter<"Facility"> | number
    createdAt?: DateTimeFilter<"Facility"> | Date | string
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
  }, "id">

  export type FacilityOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacilityCountOrderByAggregateInput
    _avg?: FacilityAvgOrderByAggregateInput
    _max?: FacilityMaxOrderByAggregateInput
    _min?: FacilityMinOrderByAggregateInput
    _sum?: FacilitySumOrderByAggregateInput
  }

  export type FacilityScalarWhereWithAggregatesInput = {
    AND?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    OR?: FacilityScalarWhereWithAggregatesInput[]
    NOT?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Facility"> | number
    title?: StringWithAggregatesFilter<"Facility"> | string
    description?: StringWithAggregatesFilter<"Facility"> | string
    image?: StringNullableWithAggregatesFilter<"Facility"> | string | null
    sortOrder?: IntWithAggregatesFilter<"Facility"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Facility"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Facility"> | Date | string
  }

  export type NewsWhereInput = {
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    id?: IntFilter<"News"> | number
    title?: StringFilter<"News"> | string
    slug?: StringFilter<"News"> | string
    date?: DateTimeFilter<"News"> | Date | string
    image?: StringNullableFilter<"News"> | string | null
    images?: JsonNullableFilter<"News">
    excerpt?: StringFilter<"News"> | string
    content?: StringFilter<"News"> | string
    popularity?: IntFilter<"News"> | number
    viewCount?: IntFilter<"News"> | number
    shareCount?: IntFilter<"News"> | number
    sharedByUserId?: IntNullableFilter<"News"> | number | null
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
    sharedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NewsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    date?: SortOrder
    image?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sharedBy?: UserOrderByWithRelationInput
  }

  export type NewsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    title?: StringFilter<"News"> | string
    date?: DateTimeFilter<"News"> | Date | string
    image?: StringNullableFilter<"News"> | string | null
    images?: JsonNullableFilter<"News">
    excerpt?: StringFilter<"News"> | string
    content?: StringFilter<"News"> | string
    popularity?: IntFilter<"News"> | number
    viewCount?: IntFilter<"News"> | number
    shareCount?: IntFilter<"News"> | number
    sharedByUserId?: IntNullableFilter<"News"> | number | null
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
    sharedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "slug">

  export type NewsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    date?: SortOrder
    image?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NewsCountOrderByAggregateInput
    _avg?: NewsAvgOrderByAggregateInput
    _max?: NewsMaxOrderByAggregateInput
    _min?: NewsMinOrderByAggregateInput
    _sum?: NewsSumOrderByAggregateInput
  }

  export type NewsScalarWhereWithAggregatesInput = {
    AND?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    OR?: NewsScalarWhereWithAggregatesInput[]
    NOT?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"News"> | number
    title?: StringWithAggregatesFilter<"News"> | string
    slug?: StringWithAggregatesFilter<"News"> | string
    date?: DateTimeWithAggregatesFilter<"News"> | Date | string
    image?: StringNullableWithAggregatesFilter<"News"> | string | null
    images?: JsonNullableWithAggregatesFilter<"News">
    excerpt?: StringWithAggregatesFilter<"News"> | string
    content?: StringWithAggregatesFilter<"News"> | string
    popularity?: IntWithAggregatesFilter<"News"> | number
    viewCount?: IntWithAggregatesFilter<"News"> | number
    shareCount?: IntWithAggregatesFilter<"News"> | number
    sharedByUserId?: IntNullableWithAggregatesFilter<"News"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
  }

  export type EducationWhereInput = {
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    id?: IntFilter<"Education"> | number
    title?: StringFilter<"Education"> | string
    slug?: StringFilter<"Education"> | string
    date?: DateTimeFilter<"Education"> | Date | string
    image?: StringNullableFilter<"Education"> | string | null
    images?: JsonNullableFilter<"Education">
    excerpt?: StringNullableFilter<"Education"> | string | null
    content?: StringFilter<"Education"> | string
    popularity?: IntFilter<"Education"> | number
    viewCount?: IntFilter<"Education"> | number
    shareCount?: IntFilter<"Education"> | number
    sharedByUserId?: IntNullableFilter<"Education"> | number | null
    createdAt?: DateTimeFilter<"Education"> | Date | string
    updatedAt?: DateTimeFilter<"Education"> | Date | string
    sharedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type EducationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    date?: SortOrder
    image?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    content?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sharedBy?: UserOrderByWithRelationInput
  }

  export type EducationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    title?: StringFilter<"Education"> | string
    date?: DateTimeFilter<"Education"> | Date | string
    image?: StringNullableFilter<"Education"> | string | null
    images?: JsonNullableFilter<"Education">
    excerpt?: StringNullableFilter<"Education"> | string | null
    content?: StringFilter<"Education"> | string
    popularity?: IntFilter<"Education"> | number
    viewCount?: IntFilter<"Education"> | number
    shareCount?: IntFilter<"Education"> | number
    sharedByUserId?: IntNullableFilter<"Education"> | number | null
    createdAt?: DateTimeFilter<"Education"> | Date | string
    updatedAt?: DateTimeFilter<"Education"> | Date | string
    sharedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "slug">

  export type EducationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    date?: SortOrder
    image?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    content?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EducationCountOrderByAggregateInput
    _avg?: EducationAvgOrderByAggregateInput
    _max?: EducationMaxOrderByAggregateInput
    _min?: EducationMinOrderByAggregateInput
    _sum?: EducationSumOrderByAggregateInput
  }

  export type EducationScalarWhereWithAggregatesInput = {
    AND?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    OR?: EducationScalarWhereWithAggregatesInput[]
    NOT?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Education"> | number
    title?: StringWithAggregatesFilter<"Education"> | string
    slug?: StringWithAggregatesFilter<"Education"> | string
    date?: DateTimeWithAggregatesFilter<"Education"> | Date | string
    image?: StringNullableWithAggregatesFilter<"Education"> | string | null
    images?: JsonNullableWithAggregatesFilter<"Education">
    excerpt?: StringNullableWithAggregatesFilter<"Education"> | string | null
    content?: StringWithAggregatesFilter<"Education"> | string
    popularity?: IntWithAggregatesFilter<"Education"> | number
    viewCount?: IntWithAggregatesFilter<"Education"> | number
    shareCount?: IntWithAggregatesFilter<"Education"> | number
    sharedByUserId?: IntNullableWithAggregatesFilter<"Education"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Education"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Education"> | Date | string
  }

  export type LetterCounterWhereInput = {
    AND?: LetterCounterWhereInput | LetterCounterWhereInput[]
    OR?: LetterCounterWhereInput[]
    NOT?: LetterCounterWhereInput | LetterCounterWhereInput[]
    id?: IntFilter<"LetterCounter"> | number
    type?: EnumLetterTypeFilter<"LetterCounter"> | $Enums.LetterType
    year?: IntFilter<"LetterCounter"> | number
    nextNumber?: IntFilter<"LetterCounter"> | number
    updatedAt?: DateTimeFilter<"LetterCounter"> | Date | string
    createdAt?: DateTimeFilter<"LetterCounter"> | Date | string
  }

  export type LetterCounterOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    year?: SortOrder
    nextNumber?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LetterCounterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    type_year?: LetterCounterTypeYearCompoundUniqueInput
    AND?: LetterCounterWhereInput | LetterCounterWhereInput[]
    OR?: LetterCounterWhereInput[]
    NOT?: LetterCounterWhereInput | LetterCounterWhereInput[]
    type?: EnumLetterTypeFilter<"LetterCounter"> | $Enums.LetterType
    year?: IntFilter<"LetterCounter"> | number
    nextNumber?: IntFilter<"LetterCounter"> | number
    updatedAt?: DateTimeFilter<"LetterCounter"> | Date | string
    createdAt?: DateTimeFilter<"LetterCounter"> | Date | string
  }, "id" | "type_year">

  export type LetterCounterOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    year?: SortOrder
    nextNumber?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: LetterCounterCountOrderByAggregateInput
    _avg?: LetterCounterAvgOrderByAggregateInput
    _max?: LetterCounterMaxOrderByAggregateInput
    _min?: LetterCounterMinOrderByAggregateInput
    _sum?: LetterCounterSumOrderByAggregateInput
  }

  export type LetterCounterScalarWhereWithAggregatesInput = {
    AND?: LetterCounterScalarWhereWithAggregatesInput | LetterCounterScalarWhereWithAggregatesInput[]
    OR?: LetterCounterScalarWhereWithAggregatesInput[]
    NOT?: LetterCounterScalarWhereWithAggregatesInput | LetterCounterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LetterCounter"> | number
    type?: EnumLetterTypeWithAggregatesFilter<"LetterCounter"> | $Enums.LetterType
    year?: IntWithAggregatesFilter<"LetterCounter"> | number
    nextNumber?: IntWithAggregatesFilter<"LetterCounter"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"LetterCounter"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"LetterCounter"> | Date | string
  }

  export type LetterApplicationWhereInput = {
    AND?: LetterApplicationWhereInput | LetterApplicationWhereInput[]
    OR?: LetterApplicationWhereInput[]
    NOT?: LetterApplicationWhereInput | LetterApplicationWhereInput[]
    id?: StringFilter<"LetterApplication"> | string
    code?: StringFilter<"LetterApplication"> | string
    type?: EnumLetterTypeFilter<"LetterApplication"> | $Enums.LetterType
    status?: EnumLetterStatusFilter<"LetterApplication"> | $Enums.LetterStatus
    statusFeedback?: StringNullableFilter<"LetterApplication"> | string | null
    nomorUrut?: IntNullableFilter<"LetterApplication"> | number | null
    nomorSurat?: StringNullableFilter<"LetterApplication"> | string | null
    nik?: StringFilter<"LetterApplication"> | string
    hp?: StringFilter<"LetterApplication"> | string
    alamat?: StringFilter<"LetterApplication"> | string
    namaOrganisasi?: StringNullableFilter<"LetterApplication"> | string | null
    kecamatan?: StringNullableFilter<"LetterApplication"> | string | null
    penanggungJawab?: StringNullableFilter<"LetterApplication"> | string | null
    jenisKegiatan?: StringNullableFilter<"LetterApplication"> | string | null
    namaKegiatan?: StringNullableFilter<"LetterApplication"> | string | null
    lokasi?: StringNullableFilter<"LetterApplication"> | string | null
    tanggal?: DateTimeNullableFilter<"LetterApplication"> | Date | string | null
    waktuMulai?: StringNullableFilter<"LetterApplication"> | string | null
    waktuSelesai?: StringNullableFilter<"LetterApplication"> | string | null
    perkiraanPeserta?: IntNullableFilter<"LetterApplication"> | number | null
    ktpPath?: StringNullableFilter<"LetterApplication"> | string | null
    rekomendasiDesaPath?: StringNullableFilter<"LetterApplication"> | string | null
    rekomDesaNama?: StringNullableFilter<"LetterApplication"> | string | null
    rekomDesaNomor?: StringNullableFilter<"LetterApplication"> | string | null
    nama?: StringNullableFilter<"LetterApplication"> | string | null
    tempatLahir?: StringNullableFilter<"LetterApplication"> | string | null
    tanggalLahir?: DateTimeNullableFilter<"LetterApplication"> | Date | string | null
    jenisKelamin?: StringNullableFilter<"LetterApplication"> | string | null
    pekerjaan?: StringNullableFilter<"LetterApplication"> | string | null
    agama?: StringNullableFilter<"LetterApplication"> | string | null
    kehilanganItems?: JsonNullableFilter<"LetterApplication">
    kehilanganApa?: StringNullableFilter<"LetterApplication"> | string | null
    kronologi?: StringNullableFilter<"LetterApplication"> | string | null
    tanggalLaporan?: DateTimeNullableFilter<"LetterApplication"> | Date | string | null
    createdAt?: DateTimeFilter<"LetterApplication"> | Date | string
    updatedAt?: DateTimeFilter<"LetterApplication"> | Date | string
  }

  export type LetterApplicationOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    status?: SortOrder
    statusFeedback?: SortOrderInput | SortOrder
    nomorUrut?: SortOrderInput | SortOrder
    nomorSurat?: SortOrderInput | SortOrder
    nik?: SortOrder
    hp?: SortOrder
    alamat?: SortOrder
    namaOrganisasi?: SortOrderInput | SortOrder
    kecamatan?: SortOrderInput | SortOrder
    penanggungJawab?: SortOrderInput | SortOrder
    jenisKegiatan?: SortOrderInput | SortOrder
    namaKegiatan?: SortOrderInput | SortOrder
    lokasi?: SortOrderInput | SortOrder
    tanggal?: SortOrderInput | SortOrder
    waktuMulai?: SortOrderInput | SortOrder
    waktuSelesai?: SortOrderInput | SortOrder
    perkiraanPeserta?: SortOrderInput | SortOrder
    ktpPath?: SortOrderInput | SortOrder
    rekomendasiDesaPath?: SortOrderInput | SortOrder
    rekomDesaNama?: SortOrderInput | SortOrder
    rekomDesaNomor?: SortOrderInput | SortOrder
    nama?: SortOrderInput | SortOrder
    tempatLahir?: SortOrderInput | SortOrder
    tanggalLahir?: SortOrderInput | SortOrder
    jenisKelamin?: SortOrderInput | SortOrder
    pekerjaan?: SortOrderInput | SortOrder
    agama?: SortOrderInput | SortOrder
    kehilanganItems?: SortOrderInput | SortOrder
    kehilanganApa?: SortOrderInput | SortOrder
    kronologi?: SortOrderInput | SortOrder
    tanggalLaporan?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LetterApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: LetterApplicationWhereInput | LetterApplicationWhereInput[]
    OR?: LetterApplicationWhereInput[]
    NOT?: LetterApplicationWhereInput | LetterApplicationWhereInput[]
    type?: EnumLetterTypeFilter<"LetterApplication"> | $Enums.LetterType
    status?: EnumLetterStatusFilter<"LetterApplication"> | $Enums.LetterStatus
    statusFeedback?: StringNullableFilter<"LetterApplication"> | string | null
    nomorUrut?: IntNullableFilter<"LetterApplication"> | number | null
    nomorSurat?: StringNullableFilter<"LetterApplication"> | string | null
    nik?: StringFilter<"LetterApplication"> | string
    hp?: StringFilter<"LetterApplication"> | string
    alamat?: StringFilter<"LetterApplication"> | string
    namaOrganisasi?: StringNullableFilter<"LetterApplication"> | string | null
    kecamatan?: StringNullableFilter<"LetterApplication"> | string | null
    penanggungJawab?: StringNullableFilter<"LetterApplication"> | string | null
    jenisKegiatan?: StringNullableFilter<"LetterApplication"> | string | null
    namaKegiatan?: StringNullableFilter<"LetterApplication"> | string | null
    lokasi?: StringNullableFilter<"LetterApplication"> | string | null
    tanggal?: DateTimeNullableFilter<"LetterApplication"> | Date | string | null
    waktuMulai?: StringNullableFilter<"LetterApplication"> | string | null
    waktuSelesai?: StringNullableFilter<"LetterApplication"> | string | null
    perkiraanPeserta?: IntNullableFilter<"LetterApplication"> | number | null
    ktpPath?: StringNullableFilter<"LetterApplication"> | string | null
    rekomendasiDesaPath?: StringNullableFilter<"LetterApplication"> | string | null
    rekomDesaNama?: StringNullableFilter<"LetterApplication"> | string | null
    rekomDesaNomor?: StringNullableFilter<"LetterApplication"> | string | null
    nama?: StringNullableFilter<"LetterApplication"> | string | null
    tempatLahir?: StringNullableFilter<"LetterApplication"> | string | null
    tanggalLahir?: DateTimeNullableFilter<"LetterApplication"> | Date | string | null
    jenisKelamin?: StringNullableFilter<"LetterApplication"> | string | null
    pekerjaan?: StringNullableFilter<"LetterApplication"> | string | null
    agama?: StringNullableFilter<"LetterApplication"> | string | null
    kehilanganItems?: JsonNullableFilter<"LetterApplication">
    kehilanganApa?: StringNullableFilter<"LetterApplication"> | string | null
    kronologi?: StringNullableFilter<"LetterApplication"> | string | null
    tanggalLaporan?: DateTimeNullableFilter<"LetterApplication"> | Date | string | null
    createdAt?: DateTimeFilter<"LetterApplication"> | Date | string
    updatedAt?: DateTimeFilter<"LetterApplication"> | Date | string
  }, "id" | "code">

  export type LetterApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    status?: SortOrder
    statusFeedback?: SortOrderInput | SortOrder
    nomorUrut?: SortOrderInput | SortOrder
    nomorSurat?: SortOrderInput | SortOrder
    nik?: SortOrder
    hp?: SortOrder
    alamat?: SortOrder
    namaOrganisasi?: SortOrderInput | SortOrder
    kecamatan?: SortOrderInput | SortOrder
    penanggungJawab?: SortOrderInput | SortOrder
    jenisKegiatan?: SortOrderInput | SortOrder
    namaKegiatan?: SortOrderInput | SortOrder
    lokasi?: SortOrderInput | SortOrder
    tanggal?: SortOrderInput | SortOrder
    waktuMulai?: SortOrderInput | SortOrder
    waktuSelesai?: SortOrderInput | SortOrder
    perkiraanPeserta?: SortOrderInput | SortOrder
    ktpPath?: SortOrderInput | SortOrder
    rekomendasiDesaPath?: SortOrderInput | SortOrder
    rekomDesaNama?: SortOrderInput | SortOrder
    rekomDesaNomor?: SortOrderInput | SortOrder
    nama?: SortOrderInput | SortOrder
    tempatLahir?: SortOrderInput | SortOrder
    tanggalLahir?: SortOrderInput | SortOrder
    jenisKelamin?: SortOrderInput | SortOrder
    pekerjaan?: SortOrderInput | SortOrder
    agama?: SortOrderInput | SortOrder
    kehilanganItems?: SortOrderInput | SortOrder
    kehilanganApa?: SortOrderInput | SortOrder
    kronologi?: SortOrderInput | SortOrder
    tanggalLaporan?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LetterApplicationCountOrderByAggregateInput
    _avg?: LetterApplicationAvgOrderByAggregateInput
    _max?: LetterApplicationMaxOrderByAggregateInput
    _min?: LetterApplicationMinOrderByAggregateInput
    _sum?: LetterApplicationSumOrderByAggregateInput
  }

  export type LetterApplicationScalarWhereWithAggregatesInput = {
    AND?: LetterApplicationScalarWhereWithAggregatesInput | LetterApplicationScalarWhereWithAggregatesInput[]
    OR?: LetterApplicationScalarWhereWithAggregatesInput[]
    NOT?: LetterApplicationScalarWhereWithAggregatesInput | LetterApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LetterApplication"> | string
    code?: StringWithAggregatesFilter<"LetterApplication"> | string
    type?: EnumLetterTypeWithAggregatesFilter<"LetterApplication"> | $Enums.LetterType
    status?: EnumLetterStatusWithAggregatesFilter<"LetterApplication"> | $Enums.LetterStatus
    statusFeedback?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    nomorUrut?: IntNullableWithAggregatesFilter<"LetterApplication"> | number | null
    nomorSurat?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    nik?: StringWithAggregatesFilter<"LetterApplication"> | string
    hp?: StringWithAggregatesFilter<"LetterApplication"> | string
    alamat?: StringWithAggregatesFilter<"LetterApplication"> | string
    namaOrganisasi?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    kecamatan?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    penanggungJawab?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    jenisKegiatan?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    namaKegiatan?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    lokasi?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    tanggal?: DateTimeNullableWithAggregatesFilter<"LetterApplication"> | Date | string | null
    waktuMulai?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    waktuSelesai?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    perkiraanPeserta?: IntNullableWithAggregatesFilter<"LetterApplication"> | number | null
    ktpPath?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    rekomendasiDesaPath?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    rekomDesaNama?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    rekomDesaNomor?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    nama?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    tempatLahir?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    tanggalLahir?: DateTimeNullableWithAggregatesFilter<"LetterApplication"> | Date | string | null
    jenisKelamin?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    pekerjaan?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    agama?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    kehilanganItems?: JsonNullableWithAggregatesFilter<"LetterApplication">
    kehilanganApa?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    kronologi?: StringNullableWithAggregatesFilter<"LetterApplication"> | string | null
    tanggalLaporan?: DateTimeNullableWithAggregatesFilter<"LetterApplication"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LetterApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LetterApplication"> | Date | string
  }

  export type OnlineReportWhereInput = {
    AND?: OnlineReportWhereInput | OnlineReportWhereInput[]
    OR?: OnlineReportWhereInput[]
    NOT?: OnlineReportWhereInput | OnlineReportWhereInput[]
    id?: StringFilter<"OnlineReport"> | string
    code?: StringFilter<"OnlineReport"> | string
    status?: EnumOnlineReportStatusFilter<"OnlineReport"> | $Enums.OnlineReportStatus
    statusFeedback?: StringNullableFilter<"OnlineReport"> | string | null
    nama?: StringFilter<"OnlineReport"> | string
    nik?: StringFilter<"OnlineReport"> | string
    hp?: StringFilter<"OnlineReport"> | string
    kecamatan?: StringNullableFilter<"OnlineReport"> | string | null
    jenis?: StringFilter<"OnlineReport"> | string
    lokasi?: StringFilter<"OnlineReport"> | string
    tanggal?: DateTimeFilter<"OnlineReport"> | Date | string
    jam?: StringFilter<"OnlineReport"> | string
    kronologi?: StringFilter<"OnlineReport"> | string
    lampiranPath?: StringNullableFilter<"OnlineReport"> | string | null
    createdAt?: DateTimeFilter<"OnlineReport"> | Date | string
    updatedAt?: DateTimeFilter<"OnlineReport"> | Date | string
  }

  export type OnlineReportOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    statusFeedback?: SortOrderInput | SortOrder
    nama?: SortOrder
    nik?: SortOrder
    hp?: SortOrder
    kecamatan?: SortOrderInput | SortOrder
    jenis?: SortOrder
    lokasi?: SortOrder
    tanggal?: SortOrder
    jam?: SortOrder
    kronologi?: SortOrder
    lampiranPath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnlineReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: OnlineReportWhereInput | OnlineReportWhereInput[]
    OR?: OnlineReportWhereInput[]
    NOT?: OnlineReportWhereInput | OnlineReportWhereInput[]
    status?: EnumOnlineReportStatusFilter<"OnlineReport"> | $Enums.OnlineReportStatus
    statusFeedback?: StringNullableFilter<"OnlineReport"> | string | null
    nama?: StringFilter<"OnlineReport"> | string
    nik?: StringFilter<"OnlineReport"> | string
    hp?: StringFilter<"OnlineReport"> | string
    kecamatan?: StringNullableFilter<"OnlineReport"> | string | null
    jenis?: StringFilter<"OnlineReport"> | string
    lokasi?: StringFilter<"OnlineReport"> | string
    tanggal?: DateTimeFilter<"OnlineReport"> | Date | string
    jam?: StringFilter<"OnlineReport"> | string
    kronologi?: StringFilter<"OnlineReport"> | string
    lampiranPath?: StringNullableFilter<"OnlineReport"> | string | null
    createdAt?: DateTimeFilter<"OnlineReport"> | Date | string
    updatedAt?: DateTimeFilter<"OnlineReport"> | Date | string
  }, "id" | "code">

  export type OnlineReportOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    statusFeedback?: SortOrderInput | SortOrder
    nama?: SortOrder
    nik?: SortOrder
    hp?: SortOrder
    kecamatan?: SortOrderInput | SortOrder
    jenis?: SortOrder
    lokasi?: SortOrder
    tanggal?: SortOrder
    jam?: SortOrder
    kronologi?: SortOrder
    lampiranPath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OnlineReportCountOrderByAggregateInput
    _max?: OnlineReportMaxOrderByAggregateInput
    _min?: OnlineReportMinOrderByAggregateInput
  }

  export type OnlineReportScalarWhereWithAggregatesInput = {
    AND?: OnlineReportScalarWhereWithAggregatesInput | OnlineReportScalarWhereWithAggregatesInput[]
    OR?: OnlineReportScalarWhereWithAggregatesInput[]
    NOT?: OnlineReportScalarWhereWithAggregatesInput | OnlineReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OnlineReport"> | string
    code?: StringWithAggregatesFilter<"OnlineReport"> | string
    status?: EnumOnlineReportStatusWithAggregatesFilter<"OnlineReport"> | $Enums.OnlineReportStatus
    statusFeedback?: StringNullableWithAggregatesFilter<"OnlineReport"> | string | null
    nama?: StringWithAggregatesFilter<"OnlineReport"> | string
    nik?: StringWithAggregatesFilter<"OnlineReport"> | string
    hp?: StringWithAggregatesFilter<"OnlineReport"> | string
    kecamatan?: StringNullableWithAggregatesFilter<"OnlineReport"> | string | null
    jenis?: StringWithAggregatesFilter<"OnlineReport"> | string
    lokasi?: StringWithAggregatesFilter<"OnlineReport"> | string
    tanggal?: DateTimeWithAggregatesFilter<"OnlineReport"> | Date | string
    jam?: StringWithAggregatesFilter<"OnlineReport"> | string
    kronologi?: StringWithAggregatesFilter<"OnlineReport"> | string
    lampiranPath?: StringNullableWithAggregatesFilter<"OnlineReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OnlineReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OnlineReport"> | Date | string
  }

  export type SuratRekapWhereInput = {
    AND?: SuratRekapWhereInput | SuratRekapWhereInput[]
    OR?: SuratRekapWhereInput[]
    NOT?: SuratRekapWhereInput | SuratRekapWhereInput[]
    id?: IntFilter<"SuratRekap"> | number
    tanggal?: DateTimeFilter<"SuratRekap"> | Date | string
    noSurat?: StringFilter<"SuratRekap"> | string
    kepada?: StringFilter<"SuratRekap"> | string
    perihal?: StringFilter<"SuratRekap"> | string
    disposisiKa?: StringNullableFilter<"SuratRekap"> | string | null
    paraf?: StringNullableFilter<"SuratRekap"> | string | null
    createdById?: IntNullableFilter<"SuratRekap"> | number | null
    createdAt?: DateTimeFilter<"SuratRekap"> | Date | string
    updatedAt?: DateTimeFilter<"SuratRekap"> | Date | string
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SuratRekapOrderByWithRelationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    noSurat?: SortOrder
    kepada?: SortOrder
    perihal?: SortOrder
    disposisiKa?: SortOrderInput | SortOrder
    paraf?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
  }

  export type SuratRekapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SuratRekapWhereInput | SuratRekapWhereInput[]
    OR?: SuratRekapWhereInput[]
    NOT?: SuratRekapWhereInput | SuratRekapWhereInput[]
    tanggal?: DateTimeFilter<"SuratRekap"> | Date | string
    noSurat?: StringFilter<"SuratRekap"> | string
    kepada?: StringFilter<"SuratRekap"> | string
    perihal?: StringFilter<"SuratRekap"> | string
    disposisiKa?: StringNullableFilter<"SuratRekap"> | string | null
    paraf?: StringNullableFilter<"SuratRekap"> | string | null
    createdById?: IntNullableFilter<"SuratRekap"> | number | null
    createdAt?: DateTimeFilter<"SuratRekap"> | Date | string
    updatedAt?: DateTimeFilter<"SuratRekap"> | Date | string
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SuratRekapOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    noSurat?: SortOrder
    kepada?: SortOrder
    perihal?: SortOrder
    disposisiKa?: SortOrderInput | SortOrder
    paraf?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SuratRekapCountOrderByAggregateInput
    _avg?: SuratRekapAvgOrderByAggregateInput
    _max?: SuratRekapMaxOrderByAggregateInput
    _min?: SuratRekapMinOrderByAggregateInput
    _sum?: SuratRekapSumOrderByAggregateInput
  }

  export type SuratRekapScalarWhereWithAggregatesInput = {
    AND?: SuratRekapScalarWhereWithAggregatesInput | SuratRekapScalarWhereWithAggregatesInput[]
    OR?: SuratRekapScalarWhereWithAggregatesInput[]
    NOT?: SuratRekapScalarWhereWithAggregatesInput | SuratRekapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SuratRekap"> | number
    tanggal?: DateTimeWithAggregatesFilter<"SuratRekap"> | Date | string
    noSurat?: StringWithAggregatesFilter<"SuratRekap"> | string
    kepada?: StringWithAggregatesFilter<"SuratRekap"> | string
    perihal?: StringWithAggregatesFilter<"SuratRekap"> | string
    disposisiKa?: StringNullableWithAggregatesFilter<"SuratRekap"> | string | null
    paraf?: StringNullableWithAggregatesFilter<"SuratRekap"> | string | null
    createdById?: IntNullableWithAggregatesFilter<"SuratRekap"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SuratRekap"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SuratRekap"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    category?: StringNullableFilter<"Document"> | string | null
    description?: StringNullableFilter<"Document"> | string | null
    fileUrl?: StringFilter<"Document"> | string
    fileName?: StringNullableFilter<"Document"> | string | null
    sortOrder?: IntFilter<"Document"> | number
    isActive?: BoolFilter<"Document"> | boolean
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    title?: StringFilter<"Document"> | string
    category?: StringNullableFilter<"Document"> | string | null
    description?: StringNullableFilter<"Document"> | string | null
    fileUrl?: StringFilter<"Document"> | string
    fileName?: StringNullableFilter<"Document"> | string | null
    sortOrder?: IntFilter<"Document"> | number
    isActive?: BoolFilter<"Document"> | boolean
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    title?: StringWithAggregatesFilter<"Document"> | string
    category?: StringNullableWithAggregatesFilter<"Document"> | string | null
    description?: StringNullableWithAggregatesFilter<"Document"> | string | null
    fileUrl?: StringWithAggregatesFilter<"Document"> | string
    fileName?: StringNullableWithAggregatesFilter<"Document"> | string | null
    sortOrder?: IntWithAggregatesFilter<"Document"> | number
    isActive?: BoolWithAggregatesFilter<"Document"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type PushSubscriptionWhereInput = {
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    id?: IntFilter<"PushSubscription"> | number
    endpoint?: StringFilter<"PushSubscription"> | string
    subscription?: JsonFilter<"PushSubscription">
    userId?: IntNullableFilter<"PushSubscription"> | number | null
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PushSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    endpoint?: SortOrder
    subscription?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PushSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    endpoint?: string
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    subscription?: JsonFilter<"PushSubscription">
    userId?: IntNullableFilter<"PushSubscription"> | number | null
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "endpoint">

  export type PushSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    endpoint?: SortOrder
    subscription?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PushSubscriptionCountOrderByAggregateInput
    _avg?: PushSubscriptionAvgOrderByAggregateInput
    _max?: PushSubscriptionMaxOrderByAggregateInput
    _min?: PushSubscriptionMinOrderByAggregateInput
    _sum?: PushSubscriptionSumOrderByAggregateInput
  }

  export type PushSubscriptionScalarWhereWithAggregatesInput = {
    AND?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    OR?: PushSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PushSubscription"> | number
    endpoint?: StringWithAggregatesFilter<"PushSubscription"> | string
    subscription?: JsonWithAggregatesFilter<"PushSubscription">
    userId?: IntNullableWithAggregatesFilter<"PushSubscription"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdSuratRekap?: SuratRekapCreateNestedManyWithoutCreatedByInput
    sharedNews?: NewsCreateNestedManyWithoutSharedByInput
    sharedEducation?: EducationCreateNestedManyWithoutSharedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdSuratRekap?: SuratRekapUncheckedCreateNestedManyWithoutCreatedByInput
    sharedNews?: NewsUncheckedCreateNestedManyWithoutSharedByInput
    sharedEducation?: EducationUncheckedCreateNestedManyWithoutSharedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdSuratRekap?: SuratRekapUpdateManyWithoutCreatedByNestedInput
    sharedNews?: NewsUpdateManyWithoutSharedByNestedInput
    sharedEducation?: EducationUpdateManyWithoutSharedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdSuratRekap?: SuratRekapUncheckedUpdateManyWithoutCreatedByNestedInput
    sharedNews?: NewsUncheckedUpdateManyWithoutSharedByNestedInput
    sharedEducation?: EducationUncheckedUpdateManyWithoutSharedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderProfileCreateInput = {
    roleKey: string
    nama: string
    jabatan: string
    pesan: string
    bio: string
    fotoUrl?: string | null
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type LeaderProfileUncheckedCreateInput = {
    id?: number
    roleKey: string
    nama: string
    jabatan: string
    pesan: string
    bio: string
    fotoUrl?: string | null
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type LeaderProfileUpdateInput = {
    roleKey?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    pesan?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleKey?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    pesan?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderProfileCreateManyInput = {
    id?: number
    roleKey: string
    nama: string
    jabatan: string
    pesan: string
    bio: string
    fotoUrl?: string | null
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type LeaderProfileUpdateManyMutationInput = {
    roleKey?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    pesan?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleKey?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    pesan?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnitCreateInput = {
    name: string
    logo?: string | null
    description?: string | null
    anggota?: AnggotaCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: number
    name: string
    logo?: string | null
    description?: string | null
    anggota?: AnggotaUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    anggota?: AnggotaUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    anggota?: AnggotaUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: number
    name: string
    logo?: string | null
    description?: string | null
  }

  export type UnitUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnggotaCreateInput = {
    nama: string
    jabatan: string
    foto_url?: string | null
    unit: UnitCreateNestedOneWithoutAnggotaInput
  }

  export type AnggotaUncheckedCreateInput = {
    id?: number
    nama: string
    jabatan: string
    foto_url?: string | null
    unit_id: number
  }

  export type AnggotaUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    foto_url?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: UnitUpdateOneRequiredWithoutAnggotaNestedInput
  }

  export type AnggotaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    foto_url?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: IntFieldUpdateOperationsInput | number
  }

  export type AnggotaCreateManyInput = {
    id?: number
    nama: string
    jabatan: string
    foto_url?: string | null
    unit_id: number
  }

  export type AnggotaUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    foto_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnggotaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    foto_url?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: IntFieldUpdateOperationsInput | number
  }

  export type FacilityCreateInput = {
    title: string
    description: string
    image?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    image?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityCreateManyInput = {
    id?: number
    title: string
    description: string
    image?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsCreateInput = {
    title: string
    slug: string
    date: Date | string
    image?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt: string
    content: string
    popularity?: number
    viewCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedBy?: UserCreateNestedOneWithoutSharedNewsInput
  }

  export type NewsUncheckedCreateInput = {
    id?: number
    title: string
    slug: string
    date: Date | string
    image?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt: string
    content: string
    popularity?: number
    viewCount?: number
    shareCount?: number
    sharedByUserId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedBy?: UserUpdateOneWithoutSharedNewsNestedInput
  }

  export type NewsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    sharedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsCreateManyInput = {
    id?: number
    title: string
    slug: string
    date: Date | string
    image?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt: string
    content: string
    popularity?: number
    viewCount?: number
    shareCount?: number
    sharedByUserId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    sharedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationCreateInput = {
    title: string
    slug: string
    date: Date | string
    image?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: string | null
    content: string
    popularity?: number
    viewCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedBy?: UserCreateNestedOneWithoutSharedEducationInput
  }

  export type EducationUncheckedCreateInput = {
    id?: number
    title: string
    slug: string
    date: Date | string
    image?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: string | null
    content: string
    popularity?: number
    viewCount?: number
    shareCount?: number
    sharedByUserId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedBy?: UserUpdateOneWithoutSharedEducationNestedInput
  }

  export type EducationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    sharedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationCreateManyInput = {
    id?: number
    title: string
    slug: string
    date: Date | string
    image?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: string | null
    content: string
    popularity?: number
    viewCount?: number
    shareCount?: number
    sharedByUserId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    sharedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LetterCounterCreateInput = {
    type: $Enums.LetterType
    year: number
    nextNumber?: number
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LetterCounterUncheckedCreateInput = {
    id?: number
    type: $Enums.LetterType
    year: number
    nextNumber?: number
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LetterCounterUpdateInput = {
    type?: EnumLetterTypeFieldUpdateOperationsInput | $Enums.LetterType
    year?: IntFieldUpdateOperationsInput | number
    nextNumber?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LetterCounterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumLetterTypeFieldUpdateOperationsInput | $Enums.LetterType
    year?: IntFieldUpdateOperationsInput | number
    nextNumber?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LetterCounterCreateManyInput = {
    id?: number
    type: $Enums.LetterType
    year: number
    nextNumber?: number
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LetterCounterUpdateManyMutationInput = {
    type?: EnumLetterTypeFieldUpdateOperationsInput | $Enums.LetterType
    year?: IntFieldUpdateOperationsInput | number
    nextNumber?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LetterCounterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumLetterTypeFieldUpdateOperationsInput | $Enums.LetterType
    year?: IntFieldUpdateOperationsInput | number
    nextNumber?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LetterApplicationCreateInput = {
    id?: string
    code: string
    type: $Enums.LetterType
    status?: $Enums.LetterStatus
    statusFeedback?: string | null
    nomorUrut?: number | null
    nomorSurat?: string | null
    nik: string
    hp: string
    alamat: string
    namaOrganisasi?: string | null
    kecamatan?: string | null
    penanggungJawab?: string | null
    jenisKegiatan?: string | null
    namaKegiatan?: string | null
    lokasi?: string | null
    tanggal?: Date | string | null
    waktuMulai?: string | null
    waktuSelesai?: string | null
    perkiraanPeserta?: number | null
    ktpPath?: string | null
    rekomendasiDesaPath?: string | null
    rekomDesaNama?: string | null
    rekomDesaNomor?: string | null
    nama?: string | null
    tempatLahir?: string | null
    tanggalLahir?: Date | string | null
    jenisKelamin?: string | null
    pekerjaan?: string | null
    agama?: string | null
    kehilanganItems?: NullableJsonNullValueInput | InputJsonValue
    kehilanganApa?: string | null
    kronologi?: string | null
    tanggalLaporan?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LetterApplicationUncheckedCreateInput = {
    id?: string
    code: string
    type: $Enums.LetterType
    status?: $Enums.LetterStatus
    statusFeedback?: string | null
    nomorUrut?: number | null
    nomorSurat?: string | null
    nik: string
    hp: string
    alamat: string
    namaOrganisasi?: string | null
    kecamatan?: string | null
    penanggungJawab?: string | null
    jenisKegiatan?: string | null
    namaKegiatan?: string | null
    lokasi?: string | null
    tanggal?: Date | string | null
    waktuMulai?: string | null
    waktuSelesai?: string | null
    perkiraanPeserta?: number | null
    ktpPath?: string | null
    rekomendasiDesaPath?: string | null
    rekomDesaNama?: string | null
    rekomDesaNomor?: string | null
    nama?: string | null
    tempatLahir?: string | null
    tanggalLahir?: Date | string | null
    jenisKelamin?: string | null
    pekerjaan?: string | null
    agama?: string | null
    kehilanganItems?: NullableJsonNullValueInput | InputJsonValue
    kehilanganApa?: string | null
    kronologi?: string | null
    tanggalLaporan?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LetterApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumLetterTypeFieldUpdateOperationsInput | $Enums.LetterType
    status?: EnumLetterStatusFieldUpdateOperationsInput | $Enums.LetterStatus
    statusFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    nomorUrut?: NullableIntFieldUpdateOperationsInput | number | null
    nomorSurat?: NullableStringFieldUpdateOperationsInput | string | null
    nik?: StringFieldUpdateOperationsInput | string
    hp?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    namaOrganisasi?: NullableStringFieldUpdateOperationsInput | string | null
    kecamatan?: NullableStringFieldUpdateOperationsInput | string | null
    penanggungJawab?: NullableStringFieldUpdateOperationsInput | string | null
    jenisKegiatan?: NullableStringFieldUpdateOperationsInput | string | null
    namaKegiatan?: NullableStringFieldUpdateOperationsInput | string | null
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waktuMulai?: NullableStringFieldUpdateOperationsInput | string | null
    waktuSelesai?: NullableStringFieldUpdateOperationsInput | string | null
    perkiraanPeserta?: NullableIntFieldUpdateOperationsInput | number | null
    ktpPath?: NullableStringFieldUpdateOperationsInput | string | null
    rekomendasiDesaPath?: NullableStringFieldUpdateOperationsInput | string | null
    rekomDesaNama?: NullableStringFieldUpdateOperationsInput | string | null
    rekomDesaNomor?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    tempatLahir?: NullableStringFieldUpdateOperationsInput | string | null
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jenisKelamin?: NullableStringFieldUpdateOperationsInput | string | null
    pekerjaan?: NullableStringFieldUpdateOperationsInput | string | null
    agama?: NullableStringFieldUpdateOperationsInput | string | null
    kehilanganItems?: NullableJsonNullValueInput | InputJsonValue
    kehilanganApa?: NullableStringFieldUpdateOperationsInput | string | null
    kronologi?: NullableStringFieldUpdateOperationsInput | string | null
    tanggalLaporan?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LetterApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumLetterTypeFieldUpdateOperationsInput | $Enums.LetterType
    status?: EnumLetterStatusFieldUpdateOperationsInput | $Enums.LetterStatus
    statusFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    nomorUrut?: NullableIntFieldUpdateOperationsInput | number | null
    nomorSurat?: NullableStringFieldUpdateOperationsInput | string | null
    nik?: StringFieldUpdateOperationsInput | string
    hp?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    namaOrganisasi?: NullableStringFieldUpdateOperationsInput | string | null
    kecamatan?: NullableStringFieldUpdateOperationsInput | string | null
    penanggungJawab?: NullableStringFieldUpdateOperationsInput | string | null
    jenisKegiatan?: NullableStringFieldUpdateOperationsInput | string | null
    namaKegiatan?: NullableStringFieldUpdateOperationsInput | string | null
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waktuMulai?: NullableStringFieldUpdateOperationsInput | string | null
    waktuSelesai?: NullableStringFieldUpdateOperationsInput | string | null
    perkiraanPeserta?: NullableIntFieldUpdateOperationsInput | number | null
    ktpPath?: NullableStringFieldUpdateOperationsInput | string | null
    rekomendasiDesaPath?: NullableStringFieldUpdateOperationsInput | string | null
    rekomDesaNama?: NullableStringFieldUpdateOperationsInput | string | null
    rekomDesaNomor?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    tempatLahir?: NullableStringFieldUpdateOperationsInput | string | null
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jenisKelamin?: NullableStringFieldUpdateOperationsInput | string | null
    pekerjaan?: NullableStringFieldUpdateOperationsInput | string | null
    agama?: NullableStringFieldUpdateOperationsInput | string | null
    kehilanganItems?: NullableJsonNullValueInput | InputJsonValue
    kehilanganApa?: NullableStringFieldUpdateOperationsInput | string | null
    kronologi?: NullableStringFieldUpdateOperationsInput | string | null
    tanggalLaporan?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LetterApplicationCreateManyInput = {
    id?: string
    code: string
    type: $Enums.LetterType
    status?: $Enums.LetterStatus
    statusFeedback?: string | null
    nomorUrut?: number | null
    nomorSurat?: string | null
    nik: string
    hp: string
    alamat: string
    namaOrganisasi?: string | null
    kecamatan?: string | null
    penanggungJawab?: string | null
    jenisKegiatan?: string | null
    namaKegiatan?: string | null
    lokasi?: string | null
    tanggal?: Date | string | null
    waktuMulai?: string | null
    waktuSelesai?: string | null
    perkiraanPeserta?: number | null
    ktpPath?: string | null
    rekomendasiDesaPath?: string | null
    rekomDesaNama?: string | null
    rekomDesaNomor?: string | null
    nama?: string | null
    tempatLahir?: string | null
    tanggalLahir?: Date | string | null
    jenisKelamin?: string | null
    pekerjaan?: string | null
    agama?: string | null
    kehilanganItems?: NullableJsonNullValueInput | InputJsonValue
    kehilanganApa?: string | null
    kronologi?: string | null
    tanggalLaporan?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LetterApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumLetterTypeFieldUpdateOperationsInput | $Enums.LetterType
    status?: EnumLetterStatusFieldUpdateOperationsInput | $Enums.LetterStatus
    statusFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    nomorUrut?: NullableIntFieldUpdateOperationsInput | number | null
    nomorSurat?: NullableStringFieldUpdateOperationsInput | string | null
    nik?: StringFieldUpdateOperationsInput | string
    hp?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    namaOrganisasi?: NullableStringFieldUpdateOperationsInput | string | null
    kecamatan?: NullableStringFieldUpdateOperationsInput | string | null
    penanggungJawab?: NullableStringFieldUpdateOperationsInput | string | null
    jenisKegiatan?: NullableStringFieldUpdateOperationsInput | string | null
    namaKegiatan?: NullableStringFieldUpdateOperationsInput | string | null
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waktuMulai?: NullableStringFieldUpdateOperationsInput | string | null
    waktuSelesai?: NullableStringFieldUpdateOperationsInput | string | null
    perkiraanPeserta?: NullableIntFieldUpdateOperationsInput | number | null
    ktpPath?: NullableStringFieldUpdateOperationsInput | string | null
    rekomendasiDesaPath?: NullableStringFieldUpdateOperationsInput | string | null
    rekomDesaNama?: NullableStringFieldUpdateOperationsInput | string | null
    rekomDesaNomor?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    tempatLahir?: NullableStringFieldUpdateOperationsInput | string | null
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jenisKelamin?: NullableStringFieldUpdateOperationsInput | string | null
    pekerjaan?: NullableStringFieldUpdateOperationsInput | string | null
    agama?: NullableStringFieldUpdateOperationsInput | string | null
    kehilanganItems?: NullableJsonNullValueInput | InputJsonValue
    kehilanganApa?: NullableStringFieldUpdateOperationsInput | string | null
    kronologi?: NullableStringFieldUpdateOperationsInput | string | null
    tanggalLaporan?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LetterApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumLetterTypeFieldUpdateOperationsInput | $Enums.LetterType
    status?: EnumLetterStatusFieldUpdateOperationsInput | $Enums.LetterStatus
    statusFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    nomorUrut?: NullableIntFieldUpdateOperationsInput | number | null
    nomorSurat?: NullableStringFieldUpdateOperationsInput | string | null
    nik?: StringFieldUpdateOperationsInput | string
    hp?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    namaOrganisasi?: NullableStringFieldUpdateOperationsInput | string | null
    kecamatan?: NullableStringFieldUpdateOperationsInput | string | null
    penanggungJawab?: NullableStringFieldUpdateOperationsInput | string | null
    jenisKegiatan?: NullableStringFieldUpdateOperationsInput | string | null
    namaKegiatan?: NullableStringFieldUpdateOperationsInput | string | null
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waktuMulai?: NullableStringFieldUpdateOperationsInput | string | null
    waktuSelesai?: NullableStringFieldUpdateOperationsInput | string | null
    perkiraanPeserta?: NullableIntFieldUpdateOperationsInput | number | null
    ktpPath?: NullableStringFieldUpdateOperationsInput | string | null
    rekomendasiDesaPath?: NullableStringFieldUpdateOperationsInput | string | null
    rekomDesaNama?: NullableStringFieldUpdateOperationsInput | string | null
    rekomDesaNomor?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    tempatLahir?: NullableStringFieldUpdateOperationsInput | string | null
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jenisKelamin?: NullableStringFieldUpdateOperationsInput | string | null
    pekerjaan?: NullableStringFieldUpdateOperationsInput | string | null
    agama?: NullableStringFieldUpdateOperationsInput | string | null
    kehilanganItems?: NullableJsonNullValueInput | InputJsonValue
    kehilanganApa?: NullableStringFieldUpdateOperationsInput | string | null
    kronologi?: NullableStringFieldUpdateOperationsInput | string | null
    tanggalLaporan?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnlineReportCreateInput = {
    id?: string
    code: string
    status?: $Enums.OnlineReportStatus
    statusFeedback?: string | null
    nama: string
    nik: string
    hp: string
    kecamatan?: string | null
    jenis: string
    lokasi: string
    tanggal: Date | string
    jam: string
    kronologi: string
    lampiranPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnlineReportUncheckedCreateInput = {
    id?: string
    code: string
    status?: $Enums.OnlineReportStatus
    statusFeedback?: string | null
    nama: string
    nik: string
    hp: string
    kecamatan?: string | null
    jenis: string
    lokasi: string
    tanggal: Date | string
    jam: string
    kronologi: string
    lampiranPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnlineReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumOnlineReportStatusFieldUpdateOperationsInput | $Enums.OnlineReportStatus
    statusFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    hp?: StringFieldUpdateOperationsInput | string
    kecamatan?: NullableStringFieldUpdateOperationsInput | string | null
    jenis?: StringFieldUpdateOperationsInput | string
    lokasi?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: StringFieldUpdateOperationsInput | string
    kronologi?: StringFieldUpdateOperationsInput | string
    lampiranPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnlineReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumOnlineReportStatusFieldUpdateOperationsInput | $Enums.OnlineReportStatus
    statusFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    hp?: StringFieldUpdateOperationsInput | string
    kecamatan?: NullableStringFieldUpdateOperationsInput | string | null
    jenis?: StringFieldUpdateOperationsInput | string
    lokasi?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: StringFieldUpdateOperationsInput | string
    kronologi?: StringFieldUpdateOperationsInput | string
    lampiranPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnlineReportCreateManyInput = {
    id?: string
    code: string
    status?: $Enums.OnlineReportStatus
    statusFeedback?: string | null
    nama: string
    nik: string
    hp: string
    kecamatan?: string | null
    jenis: string
    lokasi: string
    tanggal: Date | string
    jam: string
    kronologi: string
    lampiranPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnlineReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumOnlineReportStatusFieldUpdateOperationsInput | $Enums.OnlineReportStatus
    statusFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    hp?: StringFieldUpdateOperationsInput | string
    kecamatan?: NullableStringFieldUpdateOperationsInput | string | null
    jenis?: StringFieldUpdateOperationsInput | string
    lokasi?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: StringFieldUpdateOperationsInput | string
    kronologi?: StringFieldUpdateOperationsInput | string
    lampiranPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnlineReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumOnlineReportStatusFieldUpdateOperationsInput | $Enums.OnlineReportStatus
    statusFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    hp?: StringFieldUpdateOperationsInput | string
    kecamatan?: NullableStringFieldUpdateOperationsInput | string | null
    jenis?: StringFieldUpdateOperationsInput | string
    lokasi?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: StringFieldUpdateOperationsInput | string
    kronologi?: StringFieldUpdateOperationsInput | string
    lampiranPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuratRekapCreateInput = {
    tanggal: Date | string
    noSurat: string
    kepada: string
    perihal: string
    disposisiKa?: string | null
    paraf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedSuratRekapInput
  }

  export type SuratRekapUncheckedCreateInput = {
    id?: number
    tanggal: Date | string
    noSurat: string
    kepada: string
    perihal: string
    disposisiKa?: string | null
    paraf?: string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuratRekapUpdateInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    noSurat?: StringFieldUpdateOperationsInput | string
    kepada?: StringFieldUpdateOperationsInput | string
    perihal?: StringFieldUpdateOperationsInput | string
    disposisiKa?: NullableStringFieldUpdateOperationsInput | string | null
    paraf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedSuratRekapNestedInput
  }

  export type SuratRekapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    noSurat?: StringFieldUpdateOperationsInput | string
    kepada?: StringFieldUpdateOperationsInput | string
    perihal?: StringFieldUpdateOperationsInput | string
    disposisiKa?: NullableStringFieldUpdateOperationsInput | string | null
    paraf?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuratRekapCreateManyInput = {
    id?: number
    tanggal: Date | string
    noSurat: string
    kepada: string
    perihal: string
    disposisiKa?: string | null
    paraf?: string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuratRekapUpdateManyMutationInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    noSurat?: StringFieldUpdateOperationsInput | string
    kepada?: StringFieldUpdateOperationsInput | string
    perihal?: StringFieldUpdateOperationsInput | string
    disposisiKa?: NullableStringFieldUpdateOperationsInput | string | null
    paraf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuratRekapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    noSurat?: StringFieldUpdateOperationsInput | string
    kepada?: StringFieldUpdateOperationsInput | string
    perihal?: StringFieldUpdateOperationsInput | string
    disposisiKa?: NullableStringFieldUpdateOperationsInput | string | null
    paraf?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    title: string
    category?: string | null
    description?: string | null
    fileUrl: string
    fileName?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    title: string
    category?: string | null
    description?: string | null
    fileUrl: string
    fileName?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    title: string
    category?: string | null
    description?: string | null
    fileUrl: string
    fileName?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateInput = {
    endpoint: string
    subscription: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutPushSubscriptionInput
  }

  export type PushSubscriptionUncheckedCreateInput = {
    id?: number
    endpoint: string
    subscription: JsonNullValueInput | InputJsonValue
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUpdateInput = {
    endpoint?: StringFieldUpdateOperationsInput | string
    subscription?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPushSubscriptionNestedInput
  }

  export type PushSubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    subscription?: JsonNullValueInput | InputJsonValue
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateManyInput = {
    id?: number
    endpoint: string
    subscription: JsonNullValueInput | InputJsonValue
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUpdateManyMutationInput = {
    endpoint?: StringFieldUpdateOperationsInput | string
    subscription?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    subscription?: JsonNullValueInput | InputJsonValue
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SuratRekapListRelationFilter = {
    every?: SuratRekapWhereInput
    some?: SuratRekapWhereInput
    none?: SuratRekapWhereInput
  }

  export type NewsListRelationFilter = {
    every?: NewsWhereInput
    some?: NewsWhereInput
    none?: NewsWhereInput
  }

  export type EducationListRelationFilter = {
    every?: EducationWhereInput
    some?: EducationWhereInput
    none?: EducationWhereInput
  }

  export type PushSubscriptionListRelationFilter = {
    every?: PushSubscriptionWhereInput
    some?: PushSubscriptionWhereInput
    none?: PushSubscriptionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuratRekapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PushSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    nrp?: SortOrder
    pangkat?: SortOrder
    satuan?: SortOrder
    avatarUrl?: SortOrder
    ttdJabatan?: SortOrder
    ttdNama?: SortOrder
    ttdPangkat?: SortOrder
    ttdNrp?: SortOrder
    stplkLabel?: SortOrder
    stplkJabatan?: SortOrder
    stplkNama?: SortOrder
    stplkPangkat?: SortOrder
    stplkNrp?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    nrp?: SortOrder
    pangkat?: SortOrder
    satuan?: SortOrder
    avatarUrl?: SortOrder
    ttdJabatan?: SortOrder
    ttdNama?: SortOrder
    ttdPangkat?: SortOrder
    ttdNrp?: SortOrder
    stplkLabel?: SortOrder
    stplkJabatan?: SortOrder
    stplkNama?: SortOrder
    stplkPangkat?: SortOrder
    stplkNrp?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    nrp?: SortOrder
    pangkat?: SortOrder
    satuan?: SortOrder
    avatarUrl?: SortOrder
    ttdJabatan?: SortOrder
    ttdNama?: SortOrder
    ttdPangkat?: SortOrder
    ttdNrp?: SortOrder
    stplkLabel?: SortOrder
    stplkJabatan?: SortOrder
    stplkNama?: SortOrder
    stplkPangkat?: SortOrder
    stplkNrp?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type LeaderProfileCountOrderByAggregateInput = {
    id?: SortOrder
    roleKey?: SortOrder
    nama?: SortOrder
    jabatan?: SortOrder
    pesan?: SortOrder
    bio?: SortOrder
    fotoUrl?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type LeaderProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    updatedBy?: SortOrder
  }

  export type LeaderProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    roleKey?: SortOrder
    nama?: SortOrder
    jabatan?: SortOrder
    pesan?: SortOrder
    bio?: SortOrder
    fotoUrl?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type LeaderProfileMinOrderByAggregateInput = {
    id?: SortOrder
    roleKey?: SortOrder
    nama?: SortOrder
    jabatan?: SortOrder
    pesan?: SortOrder
    bio?: SortOrder
    fotoUrl?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type LeaderProfileSumOrderByAggregateInput = {
    id?: SortOrder
    updatedBy?: SortOrder
  }

  export type AnggotaListRelationFilter = {
    every?: AnggotaWhereInput
    some?: AnggotaWhereInput
    none?: AnggotaWhereInput
  }

  export type AnggotaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    description?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    description?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    description?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UnitScalarRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type AnggotaCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    jabatan?: SortOrder
    foto_url?: SortOrder
    unit_id?: SortOrder
  }

  export type AnggotaAvgOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
  }

  export type AnggotaMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    jabatan?: SortOrder
    foto_url?: SortOrder
    unit_id?: SortOrder
  }

  export type AnggotaMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    jabatan?: SortOrder
    foto_url?: SortOrder
    unit_id?: SortOrder
  }

  export type AnggotaSumOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
  }

  export type FacilityCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type FacilityMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilitySumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NewsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    date?: SortOrder
    image?: SortOrder
    images?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsAvgOrderByAggregateInput = {
    id?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrder
  }

  export type NewsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    date?: SortOrder
    image?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    date?: SortOrder
    image?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsSumOrderByAggregateInput = {
    id?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EducationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    date?: SortOrder
    image?: SortOrder
    images?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationAvgOrderByAggregateInput = {
    id?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrder
  }

  export type EducationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    date?: SortOrder
    image?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    date?: SortOrder
    image?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationSumOrderByAggregateInput = {
    id?: SortOrder
    popularity?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    sharedByUserId?: SortOrder
  }

  export type EnumLetterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LetterType | EnumLetterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LetterType[] | ListEnumLetterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LetterType[] | ListEnumLetterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLetterTypeFilter<$PrismaModel> | $Enums.LetterType
  }

  export type LetterCounterTypeYearCompoundUniqueInput = {
    type: $Enums.LetterType
    year: number
  }

  export type LetterCounterCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    year?: SortOrder
    nextNumber?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LetterCounterAvgOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    nextNumber?: SortOrder
  }

  export type LetterCounterMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    year?: SortOrder
    nextNumber?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LetterCounterMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    year?: SortOrder
    nextNumber?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LetterCounterSumOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    nextNumber?: SortOrder
  }

  export type EnumLetterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LetterType | EnumLetterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LetterType[] | ListEnumLetterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LetterType[] | ListEnumLetterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLetterTypeWithAggregatesFilter<$PrismaModel> | $Enums.LetterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLetterTypeFilter<$PrismaModel>
    _max?: NestedEnumLetterTypeFilter<$PrismaModel>
  }

  export type EnumLetterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LetterStatus | EnumLetterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LetterStatus[] | ListEnumLetterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LetterStatus[] | ListEnumLetterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLetterStatusFilter<$PrismaModel> | $Enums.LetterStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type LetterApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    status?: SortOrder
    statusFeedback?: SortOrder
    nomorUrut?: SortOrder
    nomorSurat?: SortOrder
    nik?: SortOrder
    hp?: SortOrder
    alamat?: SortOrder
    namaOrganisasi?: SortOrder
    kecamatan?: SortOrder
    penanggungJawab?: SortOrder
    jenisKegiatan?: SortOrder
    namaKegiatan?: SortOrder
    lokasi?: SortOrder
    tanggal?: SortOrder
    waktuMulai?: SortOrder
    waktuSelesai?: SortOrder
    perkiraanPeserta?: SortOrder
    ktpPath?: SortOrder
    rekomendasiDesaPath?: SortOrder
    rekomDesaNama?: SortOrder
    rekomDesaNomor?: SortOrder
    nama?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    jenisKelamin?: SortOrder
    pekerjaan?: SortOrder
    agama?: SortOrder
    kehilanganItems?: SortOrder
    kehilanganApa?: SortOrder
    kronologi?: SortOrder
    tanggalLaporan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LetterApplicationAvgOrderByAggregateInput = {
    nomorUrut?: SortOrder
    perkiraanPeserta?: SortOrder
  }

  export type LetterApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    status?: SortOrder
    statusFeedback?: SortOrder
    nomorUrut?: SortOrder
    nomorSurat?: SortOrder
    nik?: SortOrder
    hp?: SortOrder
    alamat?: SortOrder
    namaOrganisasi?: SortOrder
    kecamatan?: SortOrder
    penanggungJawab?: SortOrder
    jenisKegiatan?: SortOrder
    namaKegiatan?: SortOrder
    lokasi?: SortOrder
    tanggal?: SortOrder
    waktuMulai?: SortOrder
    waktuSelesai?: SortOrder
    perkiraanPeserta?: SortOrder
    ktpPath?: SortOrder
    rekomendasiDesaPath?: SortOrder
    rekomDesaNama?: SortOrder
    rekomDesaNomor?: SortOrder
    nama?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    jenisKelamin?: SortOrder
    pekerjaan?: SortOrder
    agama?: SortOrder
    kehilanganApa?: SortOrder
    kronologi?: SortOrder
    tanggalLaporan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LetterApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    status?: SortOrder
    statusFeedback?: SortOrder
    nomorUrut?: SortOrder
    nomorSurat?: SortOrder
    nik?: SortOrder
    hp?: SortOrder
    alamat?: SortOrder
    namaOrganisasi?: SortOrder
    kecamatan?: SortOrder
    penanggungJawab?: SortOrder
    jenisKegiatan?: SortOrder
    namaKegiatan?: SortOrder
    lokasi?: SortOrder
    tanggal?: SortOrder
    waktuMulai?: SortOrder
    waktuSelesai?: SortOrder
    perkiraanPeserta?: SortOrder
    ktpPath?: SortOrder
    rekomendasiDesaPath?: SortOrder
    rekomDesaNama?: SortOrder
    rekomDesaNomor?: SortOrder
    nama?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    jenisKelamin?: SortOrder
    pekerjaan?: SortOrder
    agama?: SortOrder
    kehilanganApa?: SortOrder
    kronologi?: SortOrder
    tanggalLaporan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LetterApplicationSumOrderByAggregateInput = {
    nomorUrut?: SortOrder
    perkiraanPeserta?: SortOrder
  }

  export type EnumLetterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LetterStatus | EnumLetterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LetterStatus[] | ListEnumLetterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LetterStatus[] | ListEnumLetterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLetterStatusWithAggregatesFilter<$PrismaModel> | $Enums.LetterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLetterStatusFilter<$PrismaModel>
    _max?: NestedEnumLetterStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumOnlineReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OnlineReportStatus | EnumOnlineReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnlineReportStatus[] | ListEnumOnlineReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnlineReportStatus[] | ListEnumOnlineReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnlineReportStatusFilter<$PrismaModel> | $Enums.OnlineReportStatus
  }

  export type OnlineReportCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    statusFeedback?: SortOrder
    nama?: SortOrder
    nik?: SortOrder
    hp?: SortOrder
    kecamatan?: SortOrder
    jenis?: SortOrder
    lokasi?: SortOrder
    tanggal?: SortOrder
    jam?: SortOrder
    kronologi?: SortOrder
    lampiranPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnlineReportMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    statusFeedback?: SortOrder
    nama?: SortOrder
    nik?: SortOrder
    hp?: SortOrder
    kecamatan?: SortOrder
    jenis?: SortOrder
    lokasi?: SortOrder
    tanggal?: SortOrder
    jam?: SortOrder
    kronologi?: SortOrder
    lampiranPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnlineReportMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    statusFeedback?: SortOrder
    nama?: SortOrder
    nik?: SortOrder
    hp?: SortOrder
    kecamatan?: SortOrder
    jenis?: SortOrder
    lokasi?: SortOrder
    tanggal?: SortOrder
    jam?: SortOrder
    kronologi?: SortOrder
    lampiranPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOnlineReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OnlineReportStatus | EnumOnlineReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnlineReportStatus[] | ListEnumOnlineReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnlineReportStatus[] | ListEnumOnlineReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnlineReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.OnlineReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOnlineReportStatusFilter<$PrismaModel>
    _max?: NestedEnumOnlineReportStatusFilter<$PrismaModel>
  }

  export type SuratRekapCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    noSurat?: SortOrder
    kepada?: SortOrder
    perihal?: SortOrder
    disposisiKa?: SortOrder
    paraf?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuratRekapAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type SuratRekapMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    noSurat?: SortOrder
    kepada?: SortOrder
    perihal?: SortOrder
    disposisiKa?: SortOrder
    paraf?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuratRekapMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    noSurat?: SortOrder
    kepada?: SortOrder
    perihal?: SortOrder
    disposisiKa?: SortOrder
    paraf?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuratRekapSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PushSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    subscription?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PushSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutCreatedUsersInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SuratRekapCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SuratRekapCreateWithoutCreatedByInput, SuratRekapUncheckedCreateWithoutCreatedByInput> | SuratRekapCreateWithoutCreatedByInput[] | SuratRekapUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SuratRekapCreateOrConnectWithoutCreatedByInput | SuratRekapCreateOrConnectWithoutCreatedByInput[]
    createMany?: SuratRekapCreateManyCreatedByInputEnvelope
    connect?: SuratRekapWhereUniqueInput | SuratRekapWhereUniqueInput[]
  }

  export type NewsCreateNestedManyWithoutSharedByInput = {
    create?: XOR<NewsCreateWithoutSharedByInput, NewsUncheckedCreateWithoutSharedByInput> | NewsCreateWithoutSharedByInput[] | NewsUncheckedCreateWithoutSharedByInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutSharedByInput | NewsCreateOrConnectWithoutSharedByInput[]
    createMany?: NewsCreateManySharedByInputEnvelope
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
  }

  export type EducationCreateNestedManyWithoutSharedByInput = {
    create?: XOR<EducationCreateWithoutSharedByInput, EducationUncheckedCreateWithoutSharedByInput> | EducationCreateWithoutSharedByInput[] | EducationUncheckedCreateWithoutSharedByInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutSharedByInput | EducationCreateOrConnectWithoutSharedByInput[]
    createMany?: EducationCreateManySharedByInputEnvelope
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
  }

  export type PushSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SuratRekapUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SuratRekapCreateWithoutCreatedByInput, SuratRekapUncheckedCreateWithoutCreatedByInput> | SuratRekapCreateWithoutCreatedByInput[] | SuratRekapUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SuratRekapCreateOrConnectWithoutCreatedByInput | SuratRekapCreateOrConnectWithoutCreatedByInput[]
    createMany?: SuratRekapCreateManyCreatedByInputEnvelope
    connect?: SuratRekapWhereUniqueInput | SuratRekapWhereUniqueInput[]
  }

  export type NewsUncheckedCreateNestedManyWithoutSharedByInput = {
    create?: XOR<NewsCreateWithoutSharedByInput, NewsUncheckedCreateWithoutSharedByInput> | NewsCreateWithoutSharedByInput[] | NewsUncheckedCreateWithoutSharedByInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutSharedByInput | NewsCreateOrConnectWithoutSharedByInput[]
    createMany?: NewsCreateManySharedByInputEnvelope
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
  }

  export type EducationUncheckedCreateNestedManyWithoutSharedByInput = {
    create?: XOR<EducationCreateWithoutSharedByInput, EducationUncheckedCreateWithoutSharedByInput> | EducationCreateWithoutSharedByInput[] | EducationUncheckedCreateWithoutSharedByInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutSharedByInput | EducationCreateOrConnectWithoutSharedByInput[]
    createMany?: EducationCreateManySharedByInputEnvelope
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
  }

  export type PushSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneWithoutCreatedUsersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    upsert?: UserUpsertWithoutCreatedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedUsersInput, UserUpdateWithoutCreatedUsersInput>, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SuratRekapUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SuratRekapCreateWithoutCreatedByInput, SuratRekapUncheckedCreateWithoutCreatedByInput> | SuratRekapCreateWithoutCreatedByInput[] | SuratRekapUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SuratRekapCreateOrConnectWithoutCreatedByInput | SuratRekapCreateOrConnectWithoutCreatedByInput[]
    upsert?: SuratRekapUpsertWithWhereUniqueWithoutCreatedByInput | SuratRekapUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SuratRekapCreateManyCreatedByInputEnvelope
    set?: SuratRekapWhereUniqueInput | SuratRekapWhereUniqueInput[]
    disconnect?: SuratRekapWhereUniqueInput | SuratRekapWhereUniqueInput[]
    delete?: SuratRekapWhereUniqueInput | SuratRekapWhereUniqueInput[]
    connect?: SuratRekapWhereUniqueInput | SuratRekapWhereUniqueInput[]
    update?: SuratRekapUpdateWithWhereUniqueWithoutCreatedByInput | SuratRekapUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SuratRekapUpdateManyWithWhereWithoutCreatedByInput | SuratRekapUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SuratRekapScalarWhereInput | SuratRekapScalarWhereInput[]
  }

  export type NewsUpdateManyWithoutSharedByNestedInput = {
    create?: XOR<NewsCreateWithoutSharedByInput, NewsUncheckedCreateWithoutSharedByInput> | NewsCreateWithoutSharedByInput[] | NewsUncheckedCreateWithoutSharedByInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutSharedByInput | NewsCreateOrConnectWithoutSharedByInput[]
    upsert?: NewsUpsertWithWhereUniqueWithoutSharedByInput | NewsUpsertWithWhereUniqueWithoutSharedByInput[]
    createMany?: NewsCreateManySharedByInputEnvelope
    set?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    disconnect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    delete?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    update?: NewsUpdateWithWhereUniqueWithoutSharedByInput | NewsUpdateWithWhereUniqueWithoutSharedByInput[]
    updateMany?: NewsUpdateManyWithWhereWithoutSharedByInput | NewsUpdateManyWithWhereWithoutSharedByInput[]
    deleteMany?: NewsScalarWhereInput | NewsScalarWhereInput[]
  }

  export type EducationUpdateManyWithoutSharedByNestedInput = {
    create?: XOR<EducationCreateWithoutSharedByInput, EducationUncheckedCreateWithoutSharedByInput> | EducationCreateWithoutSharedByInput[] | EducationUncheckedCreateWithoutSharedByInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutSharedByInput | EducationCreateOrConnectWithoutSharedByInput[]
    upsert?: EducationUpsertWithWhereUniqueWithoutSharedByInput | EducationUpsertWithWhereUniqueWithoutSharedByInput[]
    createMany?: EducationCreateManySharedByInputEnvelope
    set?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    disconnect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    delete?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    update?: EducationUpdateWithWhereUniqueWithoutSharedByInput | EducationUpdateWithWhereUniqueWithoutSharedByInput[]
    updateMany?: EducationUpdateManyWithWhereWithoutSharedByInput | EducationUpdateManyWithWhereWithoutSharedByInput[]
    deleteMany?: EducationScalarWhereInput | EducationScalarWhereInput[]
  }

  export type PushSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SuratRekapUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SuratRekapCreateWithoutCreatedByInput, SuratRekapUncheckedCreateWithoutCreatedByInput> | SuratRekapCreateWithoutCreatedByInput[] | SuratRekapUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SuratRekapCreateOrConnectWithoutCreatedByInput | SuratRekapCreateOrConnectWithoutCreatedByInput[]
    upsert?: SuratRekapUpsertWithWhereUniqueWithoutCreatedByInput | SuratRekapUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SuratRekapCreateManyCreatedByInputEnvelope
    set?: SuratRekapWhereUniqueInput | SuratRekapWhereUniqueInput[]
    disconnect?: SuratRekapWhereUniqueInput | SuratRekapWhereUniqueInput[]
    delete?: SuratRekapWhereUniqueInput | SuratRekapWhereUniqueInput[]
    connect?: SuratRekapWhereUniqueInput | SuratRekapWhereUniqueInput[]
    update?: SuratRekapUpdateWithWhereUniqueWithoutCreatedByInput | SuratRekapUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SuratRekapUpdateManyWithWhereWithoutCreatedByInput | SuratRekapUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SuratRekapScalarWhereInput | SuratRekapScalarWhereInput[]
  }

  export type NewsUncheckedUpdateManyWithoutSharedByNestedInput = {
    create?: XOR<NewsCreateWithoutSharedByInput, NewsUncheckedCreateWithoutSharedByInput> | NewsCreateWithoutSharedByInput[] | NewsUncheckedCreateWithoutSharedByInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutSharedByInput | NewsCreateOrConnectWithoutSharedByInput[]
    upsert?: NewsUpsertWithWhereUniqueWithoutSharedByInput | NewsUpsertWithWhereUniqueWithoutSharedByInput[]
    createMany?: NewsCreateManySharedByInputEnvelope
    set?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    disconnect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    delete?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    update?: NewsUpdateWithWhereUniqueWithoutSharedByInput | NewsUpdateWithWhereUniqueWithoutSharedByInput[]
    updateMany?: NewsUpdateManyWithWhereWithoutSharedByInput | NewsUpdateManyWithWhereWithoutSharedByInput[]
    deleteMany?: NewsScalarWhereInput | NewsScalarWhereInput[]
  }

  export type EducationUncheckedUpdateManyWithoutSharedByNestedInput = {
    create?: XOR<EducationCreateWithoutSharedByInput, EducationUncheckedCreateWithoutSharedByInput> | EducationCreateWithoutSharedByInput[] | EducationUncheckedCreateWithoutSharedByInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutSharedByInput | EducationCreateOrConnectWithoutSharedByInput[]
    upsert?: EducationUpsertWithWhereUniqueWithoutSharedByInput | EducationUpsertWithWhereUniqueWithoutSharedByInput[]
    createMany?: EducationCreateManySharedByInputEnvelope
    set?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    disconnect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    delete?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    update?: EducationUpdateWithWhereUniqueWithoutSharedByInput | EducationUpdateWithWhereUniqueWithoutSharedByInput[]
    updateMany?: EducationUpdateManyWithWhereWithoutSharedByInput | EducationUpdateManyWithWhereWithoutSharedByInput[]
    deleteMany?: EducationScalarWhereInput | EducationScalarWhereInput[]
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type AnggotaCreateNestedManyWithoutUnitInput = {
    create?: XOR<AnggotaCreateWithoutUnitInput, AnggotaUncheckedCreateWithoutUnitInput> | AnggotaCreateWithoutUnitInput[] | AnggotaUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: AnggotaCreateOrConnectWithoutUnitInput | AnggotaCreateOrConnectWithoutUnitInput[]
    createMany?: AnggotaCreateManyUnitInputEnvelope
    connect?: AnggotaWhereUniqueInput | AnggotaWhereUniqueInput[]
  }

  export type AnggotaUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<AnggotaCreateWithoutUnitInput, AnggotaUncheckedCreateWithoutUnitInput> | AnggotaCreateWithoutUnitInput[] | AnggotaUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: AnggotaCreateOrConnectWithoutUnitInput | AnggotaCreateOrConnectWithoutUnitInput[]
    createMany?: AnggotaCreateManyUnitInputEnvelope
    connect?: AnggotaWhereUniqueInput | AnggotaWhereUniqueInput[]
  }

  export type AnggotaUpdateManyWithoutUnitNestedInput = {
    create?: XOR<AnggotaCreateWithoutUnitInput, AnggotaUncheckedCreateWithoutUnitInput> | AnggotaCreateWithoutUnitInput[] | AnggotaUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: AnggotaCreateOrConnectWithoutUnitInput | AnggotaCreateOrConnectWithoutUnitInput[]
    upsert?: AnggotaUpsertWithWhereUniqueWithoutUnitInput | AnggotaUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: AnggotaCreateManyUnitInputEnvelope
    set?: AnggotaWhereUniqueInput | AnggotaWhereUniqueInput[]
    disconnect?: AnggotaWhereUniqueInput | AnggotaWhereUniqueInput[]
    delete?: AnggotaWhereUniqueInput | AnggotaWhereUniqueInput[]
    connect?: AnggotaWhereUniqueInput | AnggotaWhereUniqueInput[]
    update?: AnggotaUpdateWithWhereUniqueWithoutUnitInput | AnggotaUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: AnggotaUpdateManyWithWhereWithoutUnitInput | AnggotaUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: AnggotaScalarWhereInput | AnggotaScalarWhereInput[]
  }

  export type AnggotaUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<AnggotaCreateWithoutUnitInput, AnggotaUncheckedCreateWithoutUnitInput> | AnggotaCreateWithoutUnitInput[] | AnggotaUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: AnggotaCreateOrConnectWithoutUnitInput | AnggotaCreateOrConnectWithoutUnitInput[]
    upsert?: AnggotaUpsertWithWhereUniqueWithoutUnitInput | AnggotaUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: AnggotaCreateManyUnitInputEnvelope
    set?: AnggotaWhereUniqueInput | AnggotaWhereUniqueInput[]
    disconnect?: AnggotaWhereUniqueInput | AnggotaWhereUniqueInput[]
    delete?: AnggotaWhereUniqueInput | AnggotaWhereUniqueInput[]
    connect?: AnggotaWhereUniqueInput | AnggotaWhereUniqueInput[]
    update?: AnggotaUpdateWithWhereUniqueWithoutUnitInput | AnggotaUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: AnggotaUpdateManyWithWhereWithoutUnitInput | AnggotaUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: AnggotaScalarWhereInput | AnggotaScalarWhereInput[]
  }

  export type UnitCreateNestedOneWithoutAnggotaInput = {
    create?: XOR<UnitCreateWithoutAnggotaInput, UnitUncheckedCreateWithoutAnggotaInput>
    connectOrCreate?: UnitCreateOrConnectWithoutAnggotaInput
    connect?: UnitWhereUniqueInput
  }

  export type UnitUpdateOneRequiredWithoutAnggotaNestedInput = {
    create?: XOR<UnitCreateWithoutAnggotaInput, UnitUncheckedCreateWithoutAnggotaInput>
    connectOrCreate?: UnitCreateOrConnectWithoutAnggotaInput
    upsert?: UnitUpsertWithoutAnggotaInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutAnggotaInput, UnitUpdateWithoutAnggotaInput>, UnitUncheckedUpdateWithoutAnggotaInput>
  }

  export type UserCreateNestedOneWithoutSharedNewsInput = {
    create?: XOR<UserCreateWithoutSharedNewsInput, UserUncheckedCreateWithoutSharedNewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedNewsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutSharedNewsNestedInput = {
    create?: XOR<UserCreateWithoutSharedNewsInput, UserUncheckedCreateWithoutSharedNewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedNewsInput
    upsert?: UserUpsertWithoutSharedNewsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedNewsInput, UserUpdateWithoutSharedNewsInput>, UserUncheckedUpdateWithoutSharedNewsInput>
  }

  export type UserCreateNestedOneWithoutSharedEducationInput = {
    create?: XOR<UserCreateWithoutSharedEducationInput, UserUncheckedCreateWithoutSharedEducationInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedEducationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutSharedEducationNestedInput = {
    create?: XOR<UserCreateWithoutSharedEducationInput, UserUncheckedCreateWithoutSharedEducationInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedEducationInput
    upsert?: UserUpsertWithoutSharedEducationInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedEducationInput, UserUpdateWithoutSharedEducationInput>, UserUncheckedUpdateWithoutSharedEducationInput>
  }

  export type EnumLetterTypeFieldUpdateOperationsInput = {
    set?: $Enums.LetterType
  }

  export type EnumLetterStatusFieldUpdateOperationsInput = {
    set?: $Enums.LetterStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumOnlineReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.OnlineReportStatus
  }

  export type UserCreateNestedOneWithoutCreatedSuratRekapInput = {
    create?: XOR<UserCreateWithoutCreatedSuratRekapInput, UserUncheckedCreateWithoutCreatedSuratRekapInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSuratRekapInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutCreatedSuratRekapNestedInput = {
    create?: XOR<UserCreateWithoutCreatedSuratRekapInput, UserUncheckedCreateWithoutCreatedSuratRekapInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSuratRekapInput
    upsert?: UserUpsertWithoutCreatedSuratRekapInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedSuratRekapInput, UserUpdateWithoutCreatedSuratRekapInput>, UserUncheckedUpdateWithoutCreatedSuratRekapInput>
  }

  export type UserCreateNestedOneWithoutPushSubscriptionInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionInput, UserUncheckedCreateWithoutPushSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutPushSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionInput, UserUncheckedCreateWithoutPushSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionInput
    upsert?: UserUpsertWithoutPushSubscriptionInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPushSubscriptionInput, UserUpdateWithoutPushSubscriptionInput>, UserUncheckedUpdateWithoutPushSubscriptionInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumLetterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LetterType | EnumLetterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LetterType[] | ListEnumLetterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LetterType[] | ListEnumLetterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLetterTypeFilter<$PrismaModel> | $Enums.LetterType
  }

  export type NestedEnumLetterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LetterType | EnumLetterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LetterType[] | ListEnumLetterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LetterType[] | ListEnumLetterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLetterTypeWithAggregatesFilter<$PrismaModel> | $Enums.LetterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLetterTypeFilter<$PrismaModel>
    _max?: NestedEnumLetterTypeFilter<$PrismaModel>
  }

  export type NestedEnumLetterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LetterStatus | EnumLetterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LetterStatus[] | ListEnumLetterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LetterStatus[] | ListEnumLetterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLetterStatusFilter<$PrismaModel> | $Enums.LetterStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumLetterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LetterStatus | EnumLetterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LetterStatus[] | ListEnumLetterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LetterStatus[] | ListEnumLetterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLetterStatusWithAggregatesFilter<$PrismaModel> | $Enums.LetterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLetterStatusFilter<$PrismaModel>
    _max?: NestedEnumLetterStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumOnlineReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OnlineReportStatus | EnumOnlineReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnlineReportStatus[] | ListEnumOnlineReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnlineReportStatus[] | ListEnumOnlineReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnlineReportStatusFilter<$PrismaModel> | $Enums.OnlineReportStatus
  }

  export type NestedEnumOnlineReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OnlineReportStatus | EnumOnlineReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnlineReportStatus[] | ListEnumOnlineReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnlineReportStatus[] | ListEnumOnlineReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnlineReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.OnlineReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOnlineReportStatusFilter<$PrismaModel>
    _max?: NestedEnumOnlineReportStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserCreateWithoutCreatedUsersInput = {
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdSuratRekap?: SuratRekapCreateNestedManyWithoutCreatedByInput
    sharedNews?: NewsCreateNestedManyWithoutSharedByInput
    sharedEducation?: EducationCreateNestedManyWithoutSharedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedUsersInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSuratRekap?: SuratRekapUncheckedCreateNestedManyWithoutCreatedByInput
    sharedNews?: NewsUncheckedCreateNestedManyWithoutSharedByInput
    sharedEducation?: EducationUncheckedCreateNestedManyWithoutSharedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
  }

  export type UserCreateWithoutCreatedByInput = {
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdSuratRekap?: SuratRekapCreateNestedManyWithoutCreatedByInput
    sharedNews?: NewsCreateNestedManyWithoutSharedByInput
    sharedEducation?: EducationCreateNestedManyWithoutSharedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdSuratRekap?: SuratRekapUncheckedCreateNestedManyWithoutCreatedByInput
    sharedNews?: NewsUncheckedCreateNestedManyWithoutSharedByInput
    sharedEducation?: EducationUncheckedCreateNestedManyWithoutSharedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserCreateManyCreatedByInputEnvelope = {
    data: UserCreateManyCreatedByInput | UserCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SuratRekapCreateWithoutCreatedByInput = {
    tanggal: Date | string
    noSurat: string
    kepada: string
    perihal: string
    disposisiKa?: string | null
    paraf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuratRekapUncheckedCreateWithoutCreatedByInput = {
    id?: number
    tanggal: Date | string
    noSurat: string
    kepada: string
    perihal: string
    disposisiKa?: string | null
    paraf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuratRekapCreateOrConnectWithoutCreatedByInput = {
    where: SuratRekapWhereUniqueInput
    create: XOR<SuratRekapCreateWithoutCreatedByInput, SuratRekapUncheckedCreateWithoutCreatedByInput>
  }

  export type SuratRekapCreateManyCreatedByInputEnvelope = {
    data: SuratRekapCreateManyCreatedByInput | SuratRekapCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type NewsCreateWithoutSharedByInput = {
    title: string
    slug: string
    date: Date | string
    image?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt: string
    content: string
    popularity?: number
    viewCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUncheckedCreateWithoutSharedByInput = {
    id?: number
    title: string
    slug: string
    date: Date | string
    image?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt: string
    content: string
    popularity?: number
    viewCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsCreateOrConnectWithoutSharedByInput = {
    where: NewsWhereUniqueInput
    create: XOR<NewsCreateWithoutSharedByInput, NewsUncheckedCreateWithoutSharedByInput>
  }

  export type NewsCreateManySharedByInputEnvelope = {
    data: NewsCreateManySharedByInput | NewsCreateManySharedByInput[]
    skipDuplicates?: boolean
  }

  export type EducationCreateWithoutSharedByInput = {
    title: string
    slug: string
    date: Date | string
    image?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: string | null
    content: string
    popularity?: number
    viewCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationUncheckedCreateWithoutSharedByInput = {
    id?: number
    title: string
    slug: string
    date: Date | string
    image?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: string | null
    content: string
    popularity?: number
    viewCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationCreateOrConnectWithoutSharedByInput = {
    where: EducationWhereUniqueInput
    create: XOR<EducationCreateWithoutSharedByInput, EducationUncheckedCreateWithoutSharedByInput>
  }

  export type EducationCreateManySharedByInputEnvelope = {
    data: EducationCreateManySharedByInput | EducationCreateManySharedByInput[]
    skipDuplicates?: boolean
  }

  export type PushSubscriptionCreateWithoutUserInput = {
    endpoint: string
    subscription: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUncheckedCreateWithoutUserInput = {
    id?: number
    endpoint: string
    subscription: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionCreateOrConnectWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionCreateManyUserInputEnvelope = {
    data: PushSubscriptionCreateManyUserInput | PushSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedUsersInput = {
    update: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateWithoutCreatedUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdSuratRekap?: SuratRekapUpdateManyWithoutCreatedByNestedInput
    sharedNews?: NewsUpdateManyWithoutSharedByNestedInput
    sharedEducation?: EducationUpdateManyWithoutSharedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSuratRekap?: SuratRekapUncheckedUpdateManyWithoutCreatedByNestedInput
    sharedNews?: NewsUncheckedUpdateManyWithoutSharedByNestedInput
    sharedEducation?: EducationUncheckedUpdateManyWithoutSharedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
  }

  export type UserUpdateManyWithWhereWithoutCreatedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    nrp?: StringNullableFilter<"User"> | string | null
    pangkat?: StringNullableFilter<"User"> | string | null
    satuan?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    ttdJabatan?: StringNullableFilter<"User"> | string | null
    ttdNama?: StringNullableFilter<"User"> | string | null
    ttdPangkat?: StringNullableFilter<"User"> | string | null
    ttdNrp?: StringNullableFilter<"User"> | string | null
    stplkLabel?: StringNullableFilter<"User"> | string | null
    stplkJabatan?: StringNullableFilter<"User"> | string | null
    stplkNama?: StringNullableFilter<"User"> | string | null
    stplkPangkat?: StringNullableFilter<"User"> | string | null
    stplkNrp?: StringNullableFilter<"User"> | string | null
    createdById?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type SuratRekapUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SuratRekapWhereUniqueInput
    update: XOR<SuratRekapUpdateWithoutCreatedByInput, SuratRekapUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SuratRekapCreateWithoutCreatedByInput, SuratRekapUncheckedCreateWithoutCreatedByInput>
  }

  export type SuratRekapUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SuratRekapWhereUniqueInput
    data: XOR<SuratRekapUpdateWithoutCreatedByInput, SuratRekapUncheckedUpdateWithoutCreatedByInput>
  }

  export type SuratRekapUpdateManyWithWhereWithoutCreatedByInput = {
    where: SuratRekapScalarWhereInput
    data: XOR<SuratRekapUpdateManyMutationInput, SuratRekapUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SuratRekapScalarWhereInput = {
    AND?: SuratRekapScalarWhereInput | SuratRekapScalarWhereInput[]
    OR?: SuratRekapScalarWhereInput[]
    NOT?: SuratRekapScalarWhereInput | SuratRekapScalarWhereInput[]
    id?: IntFilter<"SuratRekap"> | number
    tanggal?: DateTimeFilter<"SuratRekap"> | Date | string
    noSurat?: StringFilter<"SuratRekap"> | string
    kepada?: StringFilter<"SuratRekap"> | string
    perihal?: StringFilter<"SuratRekap"> | string
    disposisiKa?: StringNullableFilter<"SuratRekap"> | string | null
    paraf?: StringNullableFilter<"SuratRekap"> | string | null
    createdById?: IntNullableFilter<"SuratRekap"> | number | null
    createdAt?: DateTimeFilter<"SuratRekap"> | Date | string
    updatedAt?: DateTimeFilter<"SuratRekap"> | Date | string
  }

  export type NewsUpsertWithWhereUniqueWithoutSharedByInput = {
    where: NewsWhereUniqueInput
    update: XOR<NewsUpdateWithoutSharedByInput, NewsUncheckedUpdateWithoutSharedByInput>
    create: XOR<NewsCreateWithoutSharedByInput, NewsUncheckedCreateWithoutSharedByInput>
  }

  export type NewsUpdateWithWhereUniqueWithoutSharedByInput = {
    where: NewsWhereUniqueInput
    data: XOR<NewsUpdateWithoutSharedByInput, NewsUncheckedUpdateWithoutSharedByInput>
  }

  export type NewsUpdateManyWithWhereWithoutSharedByInput = {
    where: NewsScalarWhereInput
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyWithoutSharedByInput>
  }

  export type NewsScalarWhereInput = {
    AND?: NewsScalarWhereInput | NewsScalarWhereInput[]
    OR?: NewsScalarWhereInput[]
    NOT?: NewsScalarWhereInput | NewsScalarWhereInput[]
    id?: IntFilter<"News"> | number
    title?: StringFilter<"News"> | string
    slug?: StringFilter<"News"> | string
    date?: DateTimeFilter<"News"> | Date | string
    image?: StringNullableFilter<"News"> | string | null
    images?: JsonNullableFilter<"News">
    excerpt?: StringFilter<"News"> | string
    content?: StringFilter<"News"> | string
    popularity?: IntFilter<"News"> | number
    viewCount?: IntFilter<"News"> | number
    shareCount?: IntFilter<"News"> | number
    sharedByUserId?: IntNullableFilter<"News"> | number | null
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
  }

  export type EducationUpsertWithWhereUniqueWithoutSharedByInput = {
    where: EducationWhereUniqueInput
    update: XOR<EducationUpdateWithoutSharedByInput, EducationUncheckedUpdateWithoutSharedByInput>
    create: XOR<EducationCreateWithoutSharedByInput, EducationUncheckedCreateWithoutSharedByInput>
  }

  export type EducationUpdateWithWhereUniqueWithoutSharedByInput = {
    where: EducationWhereUniqueInput
    data: XOR<EducationUpdateWithoutSharedByInput, EducationUncheckedUpdateWithoutSharedByInput>
  }

  export type EducationUpdateManyWithWhereWithoutSharedByInput = {
    where: EducationScalarWhereInput
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyWithoutSharedByInput>
  }

  export type EducationScalarWhereInput = {
    AND?: EducationScalarWhereInput | EducationScalarWhereInput[]
    OR?: EducationScalarWhereInput[]
    NOT?: EducationScalarWhereInput | EducationScalarWhereInput[]
    id?: IntFilter<"Education"> | number
    title?: StringFilter<"Education"> | string
    slug?: StringFilter<"Education"> | string
    date?: DateTimeFilter<"Education"> | Date | string
    image?: StringNullableFilter<"Education"> | string | null
    images?: JsonNullableFilter<"Education">
    excerpt?: StringNullableFilter<"Education"> | string | null
    content?: StringFilter<"Education"> | string
    popularity?: IntFilter<"Education"> | number
    viewCount?: IntFilter<"Education"> | number
    shareCount?: IntFilter<"Education"> | number
    sharedByUserId?: IntNullableFilter<"Education"> | number | null
    createdAt?: DateTimeFilter<"Education"> | Date | string
    updatedAt?: DateTimeFilter<"Education"> | Date | string
  }

  export type PushSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    update: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    data: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type PushSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: PushSubscriptionScalarWhereInput
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type PushSubscriptionScalarWhereInput = {
    AND?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    OR?: PushSubscriptionScalarWhereInput[]
    NOT?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    id?: IntFilter<"PushSubscription"> | number
    endpoint?: StringFilter<"PushSubscription"> | string
    subscription?: JsonFilter<"PushSubscription">
    userId?: IntNullableFilter<"PushSubscription"> | number | null
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
  }

  export type AnggotaCreateWithoutUnitInput = {
    nama: string
    jabatan: string
    foto_url?: string | null
  }

  export type AnggotaUncheckedCreateWithoutUnitInput = {
    id?: number
    nama: string
    jabatan: string
    foto_url?: string | null
  }

  export type AnggotaCreateOrConnectWithoutUnitInput = {
    where: AnggotaWhereUniqueInput
    create: XOR<AnggotaCreateWithoutUnitInput, AnggotaUncheckedCreateWithoutUnitInput>
  }

  export type AnggotaCreateManyUnitInputEnvelope = {
    data: AnggotaCreateManyUnitInput | AnggotaCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type AnggotaUpsertWithWhereUniqueWithoutUnitInput = {
    where: AnggotaWhereUniqueInput
    update: XOR<AnggotaUpdateWithoutUnitInput, AnggotaUncheckedUpdateWithoutUnitInput>
    create: XOR<AnggotaCreateWithoutUnitInput, AnggotaUncheckedCreateWithoutUnitInput>
  }

  export type AnggotaUpdateWithWhereUniqueWithoutUnitInput = {
    where: AnggotaWhereUniqueInput
    data: XOR<AnggotaUpdateWithoutUnitInput, AnggotaUncheckedUpdateWithoutUnitInput>
  }

  export type AnggotaUpdateManyWithWhereWithoutUnitInput = {
    where: AnggotaScalarWhereInput
    data: XOR<AnggotaUpdateManyMutationInput, AnggotaUncheckedUpdateManyWithoutUnitInput>
  }

  export type AnggotaScalarWhereInput = {
    AND?: AnggotaScalarWhereInput | AnggotaScalarWhereInput[]
    OR?: AnggotaScalarWhereInput[]
    NOT?: AnggotaScalarWhereInput | AnggotaScalarWhereInput[]
    id?: IntFilter<"Anggota"> | number
    nama?: StringFilter<"Anggota"> | string
    jabatan?: StringFilter<"Anggota"> | string
    foto_url?: StringNullableFilter<"Anggota"> | string | null
    unit_id?: IntFilter<"Anggota"> | number
  }

  export type UnitCreateWithoutAnggotaInput = {
    name: string
    logo?: string | null
    description?: string | null
  }

  export type UnitUncheckedCreateWithoutAnggotaInput = {
    id?: number
    name: string
    logo?: string | null
    description?: string | null
  }

  export type UnitCreateOrConnectWithoutAnggotaInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutAnggotaInput, UnitUncheckedCreateWithoutAnggotaInput>
  }

  export type UnitUpsertWithoutAnggotaInput = {
    update: XOR<UnitUpdateWithoutAnggotaInput, UnitUncheckedUpdateWithoutAnggotaInput>
    create: XOR<UnitCreateWithoutAnggotaInput, UnitUncheckedCreateWithoutAnggotaInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutAnggotaInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutAnggotaInput, UnitUncheckedUpdateWithoutAnggotaInput>
  }

  export type UnitUpdateWithoutAnggotaInput = {
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitUncheckedUpdateWithoutAnggotaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutSharedNewsInput = {
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdSuratRekap?: SuratRekapCreateNestedManyWithoutCreatedByInput
    sharedEducation?: EducationCreateNestedManyWithoutSharedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSharedNewsInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdSuratRekap?: SuratRekapUncheckedCreateNestedManyWithoutCreatedByInput
    sharedEducation?: EducationUncheckedCreateNestedManyWithoutSharedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSharedNewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedNewsInput, UserUncheckedCreateWithoutSharedNewsInput>
  }

  export type UserUpsertWithoutSharedNewsInput = {
    update: XOR<UserUpdateWithoutSharedNewsInput, UserUncheckedUpdateWithoutSharedNewsInput>
    create: XOR<UserCreateWithoutSharedNewsInput, UserUncheckedCreateWithoutSharedNewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedNewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedNewsInput, UserUncheckedUpdateWithoutSharedNewsInput>
  }

  export type UserUpdateWithoutSharedNewsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdSuratRekap?: SuratRekapUpdateManyWithoutCreatedByNestedInput
    sharedEducation?: EducationUpdateManyWithoutSharedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedNewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdSuratRekap?: SuratRekapUncheckedUpdateManyWithoutCreatedByNestedInput
    sharedEducation?: EducationUncheckedUpdateManyWithoutSharedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSharedEducationInput = {
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdSuratRekap?: SuratRekapCreateNestedManyWithoutCreatedByInput
    sharedNews?: NewsCreateNestedManyWithoutSharedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSharedEducationInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdSuratRekap?: SuratRekapUncheckedCreateNestedManyWithoutCreatedByInput
    sharedNews?: NewsUncheckedCreateNestedManyWithoutSharedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSharedEducationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedEducationInput, UserUncheckedCreateWithoutSharedEducationInput>
  }

  export type UserUpsertWithoutSharedEducationInput = {
    update: XOR<UserUpdateWithoutSharedEducationInput, UserUncheckedUpdateWithoutSharedEducationInput>
    create: XOR<UserCreateWithoutSharedEducationInput, UserUncheckedCreateWithoutSharedEducationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedEducationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedEducationInput, UserUncheckedUpdateWithoutSharedEducationInput>
  }

  export type UserUpdateWithoutSharedEducationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdSuratRekap?: SuratRekapUpdateManyWithoutCreatedByNestedInput
    sharedNews?: NewsUpdateManyWithoutSharedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedEducationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdSuratRekap?: SuratRekapUncheckedUpdateManyWithoutCreatedByNestedInput
    sharedNews?: NewsUncheckedUpdateManyWithoutSharedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedSuratRekapInput = {
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    sharedNews?: NewsCreateNestedManyWithoutSharedByInput
    sharedEducation?: EducationCreateNestedManyWithoutSharedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedSuratRekapInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    sharedNews?: NewsUncheckedCreateNestedManyWithoutSharedByInput
    sharedEducation?: EducationUncheckedCreateNestedManyWithoutSharedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedSuratRekapInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedSuratRekapInput, UserUncheckedCreateWithoutCreatedSuratRekapInput>
  }

  export type UserUpsertWithoutCreatedSuratRekapInput = {
    update: XOR<UserUpdateWithoutCreatedSuratRekapInput, UserUncheckedUpdateWithoutCreatedSuratRekapInput>
    create: XOR<UserCreateWithoutCreatedSuratRekapInput, UserUncheckedCreateWithoutCreatedSuratRekapInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedSuratRekapInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedSuratRekapInput, UserUncheckedUpdateWithoutCreatedSuratRekapInput>
  }

  export type UserUpdateWithoutCreatedSuratRekapInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    sharedNews?: NewsUpdateManyWithoutSharedByNestedInput
    sharedEducation?: EducationUpdateManyWithoutSharedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedSuratRekapInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    sharedNews?: NewsUncheckedUpdateManyWithoutSharedByNestedInput
    sharedEducation?: EducationUncheckedUpdateManyWithoutSharedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPushSubscriptionInput = {
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdSuratRekap?: SuratRekapCreateNestedManyWithoutCreatedByInput
    sharedNews?: NewsCreateNestedManyWithoutSharedByInput
    sharedEducation?: EducationCreateNestedManyWithoutSharedByInput
  }

  export type UserUncheckedCreateWithoutPushSubscriptionInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdSuratRekap?: SuratRekapUncheckedCreateNestedManyWithoutCreatedByInput
    sharedNews?: NewsUncheckedCreateNestedManyWithoutSharedByInput
    sharedEducation?: EducationUncheckedCreateNestedManyWithoutSharedByInput
  }

  export type UserCreateOrConnectWithoutPushSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPushSubscriptionInput, UserUncheckedCreateWithoutPushSubscriptionInput>
  }

  export type UserUpsertWithoutPushSubscriptionInput = {
    update: XOR<UserUpdateWithoutPushSubscriptionInput, UserUncheckedUpdateWithoutPushSubscriptionInput>
    create: XOR<UserCreateWithoutPushSubscriptionInput, UserUncheckedCreateWithoutPushSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPushSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPushSubscriptionInput, UserUncheckedUpdateWithoutPushSubscriptionInput>
  }

  export type UserUpdateWithoutPushSubscriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdSuratRekap?: SuratRekapUpdateManyWithoutCreatedByNestedInput
    sharedNews?: NewsUpdateManyWithoutSharedByNestedInput
    sharedEducation?: EducationUpdateManyWithoutSharedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPushSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdSuratRekap?: SuratRekapUncheckedUpdateManyWithoutCreatedByNestedInput
    sharedNews?: NewsUncheckedUpdateManyWithoutSharedByNestedInput
    sharedEducation?: EducationUncheckedUpdateManyWithoutSharedByNestedInput
  }

  export type UserCreateManyCreatedByInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    nrp?: string | null
    pangkat?: string | null
    satuan?: string | null
    avatarUrl?: string | null
    ttdJabatan?: string | null
    ttdNama?: string | null
    ttdPangkat?: string | null
    ttdNrp?: string | null
    stplkLabel?: string | null
    stplkJabatan?: string | null
    stplkNama?: string | null
    stplkPangkat?: string | null
    stplkNrp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuratRekapCreateManyCreatedByInput = {
    id?: number
    tanggal: Date | string
    noSurat: string
    kepada: string
    perihal: string
    disposisiKa?: string | null
    paraf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsCreateManySharedByInput = {
    id?: number
    title: string
    slug: string
    date: Date | string
    image?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt: string
    content: string
    popularity?: number
    viewCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationCreateManySharedByInput = {
    id?: number
    title: string
    slug: string
    date: Date | string
    image?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: string | null
    content: string
    popularity?: number
    viewCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionCreateManyUserInput = {
    id?: number
    endpoint: string
    subscription: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdSuratRekap?: SuratRekapUpdateManyWithoutCreatedByNestedInput
    sharedNews?: NewsUpdateManyWithoutSharedByNestedInput
    sharedEducation?: EducationUpdateManyWithoutSharedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdSuratRekap?: SuratRekapUncheckedUpdateManyWithoutCreatedByNestedInput
    sharedNews?: NewsUncheckedUpdateManyWithoutSharedByNestedInput
    sharedEducation?: EducationUncheckedUpdateManyWithoutSharedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nrp?: NullableStringFieldUpdateOperationsInput | string | null
    pangkat?: NullableStringFieldUpdateOperationsInput | string | null
    satuan?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ttdJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNama?: NullableStringFieldUpdateOperationsInput | string | null
    ttdPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    ttdNrp?: NullableStringFieldUpdateOperationsInput | string | null
    stplkLabel?: NullableStringFieldUpdateOperationsInput | string | null
    stplkJabatan?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNama?: NullableStringFieldUpdateOperationsInput | string | null
    stplkPangkat?: NullableStringFieldUpdateOperationsInput | string | null
    stplkNrp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuratRekapUpdateWithoutCreatedByInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    noSurat?: StringFieldUpdateOperationsInput | string
    kepada?: StringFieldUpdateOperationsInput | string
    perihal?: StringFieldUpdateOperationsInput | string
    disposisiKa?: NullableStringFieldUpdateOperationsInput | string | null
    paraf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuratRekapUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    noSurat?: StringFieldUpdateOperationsInput | string
    kepada?: StringFieldUpdateOperationsInput | string
    perihal?: StringFieldUpdateOperationsInput | string
    disposisiKa?: NullableStringFieldUpdateOperationsInput | string | null
    paraf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuratRekapUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    noSurat?: StringFieldUpdateOperationsInput | string
    kepada?: StringFieldUpdateOperationsInput | string
    perihal?: StringFieldUpdateOperationsInput | string
    disposisiKa?: NullableStringFieldUpdateOperationsInput | string | null
    paraf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUpdateWithoutSharedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUncheckedUpdateWithoutSharedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUncheckedUpdateManyWithoutSharedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationUpdateWithoutSharedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationUncheckedUpdateWithoutSharedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationUncheckedUpdateManyWithoutSharedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUpdateWithoutUserInput = {
    endpoint?: StringFieldUpdateOperationsInput | string
    subscription?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    subscription?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    subscription?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnggotaCreateManyUnitInput = {
    id?: number
    nama: string
    jabatan: string
    foto_url?: string | null
  }

  export type AnggotaUpdateWithoutUnitInput = {
    nama?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    foto_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnggotaUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    foto_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnggotaUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    foto_url?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}